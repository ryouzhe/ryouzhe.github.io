<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://ryouzhe.github.io/</id><title>Roypapa</title><subtitle>React, Spring Boot, Javascript</subtitle> <updated>2024-07-24T23:40:35+09:00</updated> <author> <name>Roypapa</name> <uri>https://ryouzhe.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://ryouzhe.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://ryouzhe.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2024 Roypapa </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>C# 프로퍼티</title><link href="https://ryouzhe.github.io/posts/C-07/" rel="alternate" type="text/html" title="C# 프로퍼티" /><published>2024-07-24T00:00:00+09:00</published> <updated>2024-07-24T00:00:00+09:00</updated> <id>https://ryouzhe.github.io/posts/C-07/</id> <content src="https://ryouzhe.github.io/posts/C-07/" /> <author> <name>Roypapa</name> </author> <category term="C#" /> <summary> Property Property는 클래스나 구조체의 필드에 대한 접근을 제어하고, 캡슐화를 제공하는 멤버이다. 프로퍼티의 목적은 다음과 같다. 캡슐화: 필드의 접근을 제어하여 데이터의 무결성을 보호한다. 필드에 대한 접근 제어: 값을 읽거나 쓸 때 추가적인 로직을 수행할 수 있다. 직관적인 사용: 메서드처럼 보이지 않고 필드처럼 사용할 수 있다. C#에서도 멤버에 대한 getter / setter 메소드를 만들어서 멤버에 대한 접근을 제어할 수 있다. 하지만 C#에서는 프로퍼티를 좀 더 지향하는 것 같다. 그 이유는 편해서 라고 생각한다. 우선 프로퍼티와 getter / setter 메소드의... </summary> </entry> <entry><title>C# Interface</title><link href="https://ryouzhe.github.io/posts/C-06/" rel="alternate" type="text/html" title="C# Interface" /><published>2024-07-21T00:00:00+09:00</published> <updated>2024-07-21T00:00:00+09:00</updated> <id>https://ryouzhe.github.io/posts/C-06/</id> <content src="https://ryouzhe.github.io/posts/C-06/" /> <author> <name>Roypapa</name> </author> <category term="C#" /> <summary> Interface Interface는 클래스나 구조체가 구현해야 하는 메서드, 속성, 이벤트 및 인덱서를 정의할 수 있는 계약(contract)을 의미한다. 인터페이스는 이를 구현하는 클래스나 구조체가 반드시 포함해야 하는 멤버들의 목록을 명시하지만, 실제 구현은 제공하지 않는다. 인터페이스는 다음과 같은 특성을 가진다. 인터페이스는 특정 기능을 제공하기 위한 계약을 정의한다. 인터페스를 상속한 클래스나 구조체에서는 인터페이스에 정의된 모든 멤버와 메소드를 강제 구현해야 한다. C#에서 클래스는 다중 상속을 지원하지 않지만, 인터페이스는 다중 상속이 가능하다. Interface 정의 p... </summary> </entry> <entry><title>C# Class 04</title><link href="https://ryouzhe.github.io/posts/C-05/" rel="alternate" type="text/html" title="C# Class 04" /><published>2024-07-17T00:00:00+09:00</published> <updated>2024-07-17T00:00:00+09:00</updated> <id>https://ryouzhe.github.io/posts/C-05/</id> <content src="https://ryouzhe.github.io/posts/C-05/" /> <author> <name>Roypapa</name> </author> <category term="C#" /> <summary> 읽기 전용 필드 readonly 키워드를 사용해서 읽기 전용 필드를 만들 수 있다. 읽기 전용 필드는 클래스나 구조체의 멤버로만 사용할 수 있으며, 생성자를 통해서 한 번만 값이 정해지고 읽기만 가능하여 변경할 수 없다. 만약 생성자가 아닌 곳에서 읽기 전용 필드를 변경하려 하면 컴파일 에러가 발생한다. 값이 한번 정해지면 다시 변경할 수 없는 const와 비슷하다. 하지만 const와 readonly는 분명히 다르다. const는 선언 시에만 초기화 할 수 있고 readonly는 선언 시 또는 생성자에서 초기화할 수 있다. const는 컴파일 시 상수 값이 코드에 직접 삽입되고 readonly는 런타임 시 값이 메모리에 저장된다. ... </summary> </entry> <entry><title>C# Class 03</title><link href="https://ryouzhe.github.io/posts/C-04/" rel="alternate" type="text/html" title="C# Class 03" /><published>2024-07-16T00:00:00+09:00</published> <updated>2024-07-18T00:06:59+09:00</updated> <id>https://ryouzhe.github.io/posts/C-04/</id> <content src="https://ryouzhe.github.io/posts/C-04/" /> <author> <name>Roypapa</name> </author> <category term="C#" /> <summary> 한정자 접근 한정자 내용 public 클래스의 내부/외부에서 모두 접근 가능 protected 클래스의 외부에서 접근 불가/파생 클래스에서 접근 가능 private 클래스의 내부에서만 접근 가능 internal 같은 어셈블리에 있는 코드에서 public으로 접근 가능/다른 어셈블리에 있는 코드에서는 private의 접근 수준 protected internal 같은 어셈블리에서 protected로 접근 가능/다른 어셈블리에 있는 코드에서는 private의 접근 ... </summary> </entry> <entry><title>C# Class 02</title><link href="https://ryouzhe.github.io/posts/C-03/" rel="alternate" type="text/html" title="C# Class 02" /><published>2024-07-10T00:00:00+09:00</published> <updated>2024-07-18T00:06:59+09:00</updated> <id>https://ryouzhe.github.io/posts/C-03/</id> <content src="https://ryouzhe.github.io/posts/C-03/" /> <author> <name>Roypapa</name> </author> <category term="C#" /> <summary> Shallow Copy/Deep Copy 클래스는 참조 형식이다. 참조 형식은 힙 영역에 객체를 할당하고 스택에 있는 참조가 힙 영역에 할당된 메모리를 가리킨다. class MyClass { public int Field1; public int Field2; } MyClass Test1 = new MyClass(); Test1.Field1 = 10; Test1.Field2 = 20; MyClass Test2 = Test1; Test2.Field2 = 30; Console.WriteLine("{0} {1}", Test1.Field1, Test1.Field2); // 10 30 Console.W... </summary> </entry> </feed>
