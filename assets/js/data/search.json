[ { "title": "C# 프로퍼티", "url": "/posts/C-07/", "categories": "C#", "tags": "C#", "date": "2024-07-24 00:00:00 +0900", "snippet": "PropertyProperty는 클래스나 구조체의 필드에 대한 접근을 제어하고, 캡슐화를 제공하는 멤버이다. 프로퍼티의 목적은 다음과 같다. 캡슐화: 필드의 접근을 제어하여 데이터의 무결성을 보호한다. 필드에 대한 접근 제어: 값을 읽거나 쓸 때 추가적인 로직을 수행할 수 있다. 직관적인 사용: 메서드처럼 보이지 않고 필드처럼 사용할 수 있다. C#에서도 멤버에 대한 getter / setter 메소드를 만들어서 멤버에 대한 접근을 제어할 수 있다. 하지만 C#에서는 프로퍼티를 좀 더 지향하는 것 같다.그 이유는 편해서 라고 생각한다.우선 프로퍼티와 getter / setter 메소드의 차이점은 아래와 같다.Property public class Person { public string Name { get; set; } // 자동 구현 프로퍼티 } // 사용 예시 Person person = new Person(); person.Name = &quot;John&quot;; Console.WriteLine(person.Name);Getter / Setter public class Person { private string name; public string GetName() { return name; } public void SetName(string value) { name = value; } } // 사용 예시 Person person = new Person(); person.SetName(&quot;John&quot;); Console.WriteLine(person.GetName()); 프로퍼티를 사용하면 getter와 setter 메서드를 정의하지 않아도 된다. 이로 인해 코드가 간결해지고, 읽기 쉽다. 프로퍼티는 필드 접근과 유사한 구문을 제공하면서도, 내부적으로는 getter와 setter 메서드를 통해 데이터 접근을 제어한다. 이를 통해 캡슐화와 정보 은닉을 보다 자연스럽게 구현할 수 있다. getter와 setter 메서드와 달리, 필요에 따라 접근자를 생략하거나, 읽기 전용/쓰기 전용 프로퍼티를 쉽게 만들 수 있다. 프로퍼티는 유연하다. 초기에는 단순히 자동 구현 프로퍼티로 시작할 수 있으며, 이후 필요에 따라 getter와 setter에 로직을 추가할 수 있다.init 접근자프로퍼티의 데이터 오염을 방지하기 위해서는 생성자를 통해 필드를 초기화하고 get 접근자만 제공하면 된다. public class Person { public Person(int _age) { age = _age; } int age; public int Age {get { return age;}} }init 접근자를 통해 생성자를 통해 초기화하는 과정을 생략할 수 있다. init 접근자를 사용하면 단 한번 값을 지정할 수 있고, 그 이후는 값을 읽는 것만 가능하다. public class Person { public int Age {get; init;} }초기화를 강제하는 한정자로는 required 가 있다. required 한정자로 수식된 프로퍼티는 객체를 생성할 때 초기화를 해주면 된다. public class Person { public required int Age {get; set;} } class MainApp { static void Main(string[] args) { Person person = new Person() {Age = 20}; } }" }, { "title": "C# Interface", "url": "/posts/C-06/", "categories": "C#", "tags": "C#", "date": "2024-07-21 00:00:00 +0900", "snippet": "InterfaceInterface는 클래스나 구조체가 구현해야 하는 메서드, 속성, 이벤트 및 인덱서를 정의할 수 있는 계약(contract)을 의미한다. 인터페이스는 이를 구현하는 클래스나 구조체가 반드시 포함해야 하는 멤버들의 목록을 명시하지만, 실제 구현은 제공하지 않는다.인터페이스는 다음과 같은 특성을 가진다. 인터페이스는 특정 기능을 제공하기 위한 계약을 정의한다. 인터페스를 상속한 클래스나 구조체에서는 인터페이스에 정의된 모든 멤버와 메소드를 강제 구현해야 한다. C#에서 클래스는 다중 상속을 지원하지 않지만, 인터페이스는 다중 상속이 가능하다. Interface 정의 public interface IAnimal { void Speak(); void Eat(); }Interface 구현 public class Dog : IAnimal { public void Speak() { Console.WriteLine(&quot;Bark&quot;); } public void Eat() { Console.WriteLine(&quot;Dog is eating.&quot;); } } public class Cat : IAnimal { public void Speak() { Console.WriteLine(&quot;Meow&quot;); } public void Eat() { Console.WriteLine(&quot;Cat is eating.&quot;); } }Interface 사용 class Program { static void Main() { IAnimal dog = new Dog(); IAnimal cat = new Cat(); dog.Speak(); // 출력: Bark dog.Eat(); // 출력: Dog is eating. cat.Speak(); // 출력: Meow cat.Eat(); // 출력: Cat is eating. } }Interface VS Class VS Abstract Class인터페이스와 클래스는 모두 상속이 가능하다. 하지만 인터페이스는 다중 상속이 가능하고, 클래스는 단일 상속만 가능하다. 그리고 둘은 상속을 하는 사용 목적에서 확실하게 구분이 되어진다.인터페이스의 사용목적은 특정 기능을 여러 클래스에 걸쳐 강제하기 위해 사용한다.클래스는 객체를 생성하고, 데이터와 메서드를 포함하여 실제 동작을 구현하는 데 사용한다.추상 클래스는 공통된 기본 구현을 제공하고, 서브클래스가 이를 확장하고 구체적인 동작을 정의하도록 강제한다. 구분 인터페이스 (Interface) 클래스 (Class) 추상 클래스 (Abstract Class) 정의 계약(Contract) 객체의 설계도 부분적으로 구현된 클래스 멤버 구현 구현 불가 구현 가능 부분적으로 구현 가능 인스턴스 생성 불가 가능 불가 다중 상속 가능 불가 불가 접근 제한자 없음 (모든 멤버는 암묵적으로 public) 모든 접근 제한자 가능 모든 접근 제한자 가능 생성자 없음 있음 있음 (하지만 직접 인스턴스화는 불가) 사용 사례 다중 상속이 필요하거나 특정 계약을 강제할 때 일반적인 객체 지향 프로그래밍 기본 구현을 제공하고 서브클래스가 확장할 때 필드 불가 가능 가능 속성 선언만 가능 가능 가능 메서드 선언만 가능 가능 선언 및 일부 구현 가능 좀 더 편하게 생각하자면 인터페이스는 여러 클래스에서 공통으로 사용하기로 한 약속이다. 따라서 그 약속의 이행은 인터페이스를 상속받은 클래스에서 구현을 통해서 이행하게 된다.예를 들면 동물이라는 인터페이스에 짖다라는 메소드가 있을 때, 이 인터페이스를 상속받은 강아지라는 클래스와 고양이라는 클래스가 짖다를 구현할 때 같은 소리가 나지 않는다. 다른 소리로 짖다를 구현하면서 약속을 이행하게 된다.추상 클래스는 확장이라는 용도로 사용한다. 뭔가 확실히라게 구현하기 애매한 부분들을 확장해서 사용하기 위해 선언만 해놓고 필요할 때 추상 클래스를 상속받은 자식 클래스에서 구현을 해서 알아서 쓴다" }, { "title": "C# Class 04", "url": "/posts/C-05/", "categories": "C#", "tags": "C#", "date": "2024-07-17 00:00:00 +0900", "snippet": "읽기 전용 필드readonly 키워드를 사용해서 읽기 전용 필드를 만들 수 있다. 읽기 전용 필드는 클래스나 구조체의 멤버로만 사용할 수 있으며, 생성자를 통해서한 번만 값이 정해지고 읽기만 가능하여 변경할 수 없다. 만약 생성자가 아닌 곳에서 읽기 전용 필드를 변경하려 하면 컴파일 에러가 발생한다.값이 한번 정해지면 다시 변경할 수 없는 const와 비슷하다. 하지만 const와 readonly는 분명히 다르다. const는 선언 시에만 초기화 할 수 있고 readonly는 선언 시 또는 생성자에서 초기화할 수 있다. const는 컴파일 시 상수 값이 코드에 직접 삽입되고 readonly는 런타임 시 값이 메모리에 저장된다. 구조체와 클래스구조체와 클래스의 가장 큰 차이점은 구조체는 값 타입(Value Type) / 클래스는 참조 타입(Reference Type) 에 있다. 구분 클래스 구조체 타입 참조 타입 (Reference Type) 값 타입 (Value Type) 메모리 할당 힙 (Heap) 스택 (Stack) 기본 값 null 모든 필드가 기본 값으로 초기화됨 상속 지원 지원하지 않음 인터페이스 구현 지원 지원 생성자 기본 생성자 및 사용자 정의 생성자 가능 모든 필드를 초기화하는 생성자 필요 파괴자 지원 지원하지 않음 가비지 컬렉션 가비지 컬렉터에 의해 관리됨 가비지 컬렉션 없음 주된 사용 사례 복잡한 데이터 구조, 상속이 필요한 경우 작은 데이터 구조, 간단한 경우, 메모리 효율성 중시 " }, { "title": "C# Class 03", "url": "/posts/C-04/", "categories": "C#", "tags": "C#", "date": "2024-07-16 00:00:00 +0900", "snippet": "한정자 접근 한정자 내용 public 클래스의 내부/외부에서 모두 접근 가능 protected 클래스의 외부에서 접근 불가/파생 클래스에서 접근 가능 private 클래스의 내부에서만 접근 가능 internal 같은 어셈블리에 있는 코드에서 public으로 접근 가능/다른 어셈블리에 있는 코드에서는 private의 접근 수준 protected internal 같은 어셈블리에서 protected로 접근 가능/다른 어셈블리에 있는 코드에서는 private의 접근 수준 private protected 같은 어셈블리에 있는 클래스에서 상속받은 클래스 내부에서만 접근 가능 여기서 어셈블리는 하나 이상의 원본 파일을 컴파일하여 생성된 DLL(실행파일 또는 동적 라이브러리)을 말한다.주의할 점은 C#에서 접근 한정자를 수식하지 않을 경우 무조건 private로 자동 지정된다는 점이다.상속C#에서는 자식 클래스(파생 클래스)와 부모 클래스(기반 클래스)가 있다. 자식 클래스는 부모 클래스를 상속 받아 부모 클래스의 멤버와 메소드를 가질 수 있다.자식 클래스 뒤에 콜론을 붙이고 부모 클래스를 붙여줌으로써 상속이 이루어 진다. class Base { public BaseMethod() { ... } } class Derived : Base { ... }자식 클래스는 객체를 생성할 때 부모 클래스 생성자를 호출하고 자신의 생성자를 호출한다. 소멸될 때는 반대로 자신의 소멸자를 호출하고 부모 클래스의 소멸자를 호출한다.자식 클래스의 객체를 생성할 때 부모 클래스의 생성자에 매개변수를 전달할 때는 base 키워드를 사용한다. base 키워드를 통해서 부모 클래스의 멤버에 접근할 수 있다.메소드 숨기기메소드 숨기기란 부모 클래스에서 구현된 메소드를 숨기고 자식 클래스에 새로 정의된 메소드만 노출시키는 것이다.자식 클래스의 메소드에 new 키워드를 붙여서 새로 정의한다.이 경우 부모 클래스 객체를 생성할 경우 숨겨진 부모 클래스 버전의 메소드를 불러올 수 있다. class Base { public int Add(int num1, int num2){ return num1 + num2; } } class Derived : Base { public new int Add(int num1, int num2){ return num1 + num2 + 100 } }오버라이딩부모는 자식이 여럿일 수 있다. 오버라이딩은 그런 여러 자식들을 위한 것이다. 오버라이딩은 부모 클래스의 메소드를 자식들이 각자의 개성을 살려 재정의할 수 있게 한다. class Base { public virtual void Character() { ... } } class Derived : Base { public override void Character() { ... } }메소드를 오버라이딩하기 위한 조건은 virtual 키워드로 한정되야 한다는 점이다.virtual 키워드로 한정된 부모 클래스의 메소드는 무한히 오버라이딩 될 수 있다. 이러한 문제점을 방지하기 위해서 sealed 키워드를 사용해서 다시 오버라이딩 되는 것을 방지할 수 있다.단 sealed 한정자는 virtual 키워드로 한정된 메소드를 override로 재정의한 메소드에만 붙일 수 있다. class Base { public virtual void Character() { ... } } class Derived : Base { public sealed override void Character() { // 이제 더이상 override 할 수 없음 ... } }메소드 숨기기는 호출 시 객체의 실제 타입에 따라 어느 메소드가 호출되는지 가 결정된다. 오버라이딩은 객체의 타입과 관계없이 자식 클래스의 오버라이딩된 메소드가 호출된다.메소드 숨기기는 컴파일 시점에 메소드 호출이 결정되는 정적 바인딩에 의해 동작한다. 즉 메소드 호출 시점에 변수가 어떤 타입으로 선언되었는지를 기준으로 메소드를 결정하게되며, 이로 인해 객체를 생성할 때 사용한 클래스 타입의 메소드를 호출하게 된다.메소드 오버라이딩은 런타임 시점에서 메소드 호출이 결정되는 동적 바인딩에 의해 동작한다. 즉 인스턴스 타입(생성된)에 따라 호출할 메소드를 결정한다.컴파일 시점은 코드를 컴파일러가 기계어로 번역되는 순간이니 선언된 타입(참조 타입)을 바라보는 것이니 정적 바인딩으로 이핼할 수 있다.런타임 시점은 프로그램이 실제로 샐행되는 순가이니 이미 객체가 메모리에 할되어 있으며 객체의 타입(인스턴스 타입)을 바라보고 이것은 동적 바인딩이라 할 수 있다." }, { "title": "C# Class 02", "url": "/posts/C-03/", "categories": "C#", "tags": "C#", "date": "2024-07-10 00:00:00 +0900", "snippet": "Shallow Copy/Deep Copy클래스는 참조 형식이다. 참조 형식은 힙 영역에 객체를 할당하고 스택에 있는 참조가 힙 영역에 할당된 메모리를 가리킨다. class MyClass { public int Field1; public int Field2; } MyClass Test1 = new MyClass(); Test1.Field1 = 10; Test1.Field2 = 20; MyClass Test2 = Test1; Test2.Field2 = 30; Console.WriteLine(&quot;{0} {1}&quot;, Test1.Field1, Test1.Field2); // 10 30 Console.WriteLine(&quot;{0} {1}&quot;, Test2.Field1, Test2.Field2); // 10 30Test2는 Test1과 같은 메모리를 가리키게 되어 Test1의 Field2의 값이 30으로 바뀌게 된다. 이렇게 참조만 복사하는 것을 얉은 복사(Shallow Copy)라고 한다.참조를 복사하는 것이 아니라 별도의 힙 공간을 할당해서 값을 복사하는 것을 깊은 복사(Deep Copy)라 하며, C#에서는 깊은 복사를 직접 코드로 만들어 사용한다. class MyClass { public int Field1; public int Field2; //Deep Copy public Myclass DeepCopy() { MyClass newCopy = new MyClass(); newCopy.Field1 = this.MyField1; newCopy.Field2 = this.MyField2; return newCopy; } } MyClass Test1 = new MyClass(); Test1.Field1 = 10; Test1.Field2 = 20; MyClass Test2 = Test1; Test2.Field2 = 30; Console.WriteLine(&quot;{0} {1}&quot;, Test1.Field1, Test1.Field2); // 10 20 Console.WriteLine(&quot;{0} {1}&quot;, Test2.Field1, Test2.Field2); // 10 30thisthis는 객체가 자신을 지칭할 때 사용하는 키워드이다. 객체 내부에서는 자신의 필드나 메소드에 접근할 때 this를 사용한다. class User { private string Name; public void SetName(string Name) { this.Name = Name; } public void GetName() { return Name; } }this()는 생성자를 오버로딩할 때 사용할 수 있다. this()는 자기 자신의 생성자를 가리키며, 생성자에서만 사용이 가능하다. class MyClass { int a, b, c; public MyClass() { this.a = 1; } public MyClass(int b) : this() { // this()는 MyClass()를 가리킨다. this.b = b; } }" }, { "title": "C# Class 01", "url": "/posts/C-02/", "categories": "C#", "tags": "C#", "date": "2024-07-09 00:00:00 +0900", "snippet": "매개변수C# 메소드는 클래스 내부에서 C/C++의 함수와 같은 개념으로 Pass By Value와 Pass By Reference로 나뉜다.Pass By Value는 외부에서 변수를 그대로 전달하며, 값만 전달하는 것으로 외부의 변수와 별개의 메모리 공간을 사용하여 데이터를 복사한다.Pass By Reference는 외부 변수의 메모리 공간을 가르키게 되어 메소드 내부에서 외부의 변수를 직접 접근할 수 있다. using System; namespace PassByRef { class MainApp { static void Swap(ref int a, ref int b) { int temp = b; b = a; a = temp; } static void Main(string[] args) { int x = 3; int y = 4; Console.WriteLine($&quot;x:{x}, y:{y}&quot;); // x:3, y:4 Swap(ref x, ref y); Console.WriteLine($&quot;X:{x}, y:{y}&quot;); // x:4, y:3 } } }클래스클래스는 추상화를 말한다. 클래스 내에 선언되는 요소들을 멤버라고 하며, 멤버는 크게 필드와 메소드로 나누어 진다. 필드는 데이터를 말하고 메소드는 함수를 말한다. 클래스는 선언을 통해서 인스턴스(객체)가 된다. 인스턴스화를 통해서 실체가 생기고 사용할 수 있다.객체는 생성될 때 생성자가 호출되고 소멸될 때 소멸자가 생성된다.생성자는 클래스와 동일한 이름을 가지는 메소드로 별도로 명시하지 않을 경우 객체가 생성될 때 컴파일러에서 자동으로 만들어 주며, 이를 Default Constructor라 한다. 생성자를 사용하는 이유는 주로 클래스의 필드값을 초기화하기 위해서 사용한다.소멸자는 생성자 앞에 ‘~’ 기호가 붙은 이름이며, 사용하는 것이 지양된다. 그 이유는 C#에서 소멸자는 CLR의 가비지 컬렉터가 객체의 소멸 시점을 판단해서 호출하기 때문이다. 소멸자를 명시적으로 사용할 경우 클래스는 상속받은 Finalize() 메소드를 호출하며, 이 경우 프로그램의 성능 저하를 초래할 수 있기 때문에 가급적 사용하지 않는다.정적 필드와 정적 메소드“static은 메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자”static 한정자가 붙은 멤버는 클래스 자체에 소속되어 인스턴스가 아니라도 호출하여 접근할 수 있다.또한 클래스 자체에 소속되기 때문에 프로그램 전체에서 유일하게 존재한다. class Cat { public static string species = &quot;mammalia&quot;; // 정적 필드 public string name; // 필드 public string age; // 필드 public Cat() { // 생성자 name = &quot;Roy&quot;; age = 0; } public void Sleep() { // 메소드 Console.WriteLine($&quot;{name}: zzzzz....&quot;); } }" }, { "title": "C# Nullable Type", "url": "/posts/C-01/", "categories": "C#", "tags": "C#", "date": "2024-07-07 00:00:00 +0900", "snippet": "NullableC# 에서는 변수의 초기화가 강제되며, 변수 초기화가 되지 않은 경우 컴파일러에서 에러가 발생한다.값에 Null이 들러가는 변수가 필요할 때는 Nullable 형식을 사용한다. int? a = null; int? b = 1; double? c = null; Console.WriteLine(a); // Null Console.WriteLine(a.HasValue); // false Console.WriteLine(b.HasValue); // true Console.WriteLine(a.Value); // 예외발생 Console.WriteLine(b.Value); // 1변수형에 ?를 붙여서 Nullable 형식을 사용한다.Nullable 형식은 HasValue 와 Value 두 가지 속성을 가진다. HasValue는 True와 False를 가지고, Value는 값을 나타낸다." }, { "title": "JPA와 MyBatis", "url": "/posts/JPA-MyBatis/", "categories": "Java", "tags": "Java, JPA, MyBatis", "date": "2023-05-23 00:00:00 +0900", "snippet": "JPAJPA는 Java Persistence API의 약자로, 자바에서 관계형 데이터베이스와의 데이터 접근을 편리하게 처리하기 위한 API이다. JPA는 객체 지향 프로그래밍과 관계형 데이터베이스 간의 데이터 매핑 및 조작을 추상화한 인터페이스를 제공하여 개발자가 데이터베이스에 대한 저수준의 작업을 최소화하고, 객체 중심의 프로그래밍 모델을 사용하여 데이터를 다룰 수 있게 해준다.JPA는 ORM(Object-Relational Mapping) 기술의 구현체 중 하나로, 객체와 데이터베이스 간의 매핑을 자동화해주는 기능을 제공한다. 개발자는 JPA를 사용하여 객체를 데이터베이스에 저장, 검색, 수정, 삭제 등의 작업을 할 수 있으며, SQL 쿼리를 직접 작성하지 않고도 객체를 통해 데이터베이스에 접근할 수 있다.JPA를 사용하면 객체 지향적인 코드를 작성할 수 있고, 데이터베이스 구조의 변경에 유연하게 대처할 수 있다. 또한, 데이터베이스 벤더에 종속되지 않는 플랫폼 독립성을 제공하며, 개발 생산성을 향상시키고 코드의 재사용성을 높일 수 있다.MyBatisMyBatis는 SQL 매핑 프레임워크로, Java 언어를 기반으로 한 오픈 소스 프레임워크다. MyBatis는 데이터베이스와의 상호 작용을 단순화하고, SQL 쿼리의 작성 및 실행을 관리하는 데 중점을 둔다.MyBatis는 SQL 매핑 파일(XML 또는 어노테이션)을 통해 객체와 SQL 쿼리를 매핑한다. 개발자는 SQL 매핑 파일에서 SQL 쿼리를 정의하고, 이를 객체와 연결하여 데이터베이스 조작을 수행할 수 있다. MyBatis는 데이터베이스와의 상호 작용을 위해 JDBC를 사용하며, 일반적인 SQL 쿼리와 프로시저를 실행하는 데 유용한 기능을 제공한다.MyBatis의 주요 특징은 아래와 같다. 간단한 설정: XML 또는 어노테이션을 사용하여 SQL 매핑을 정의하고, 데이터베이스 연결 및 트랜잭션 관리와 같은 설정을 간단하게 구성할 수 있다. 유연한 SQL 작성: 복잡한 SQL 문을 쉽게 작성하고 관리할 수 있으며, 동적 쿼리 작성을 위한 기능도 제공한다. 객체 매핑: 객체와 데이터베이스 테이블 간의 매핑을 지원하며, 객체 그래프의 관계를 처리하는 데도 용이한다. 다양한 데이터베이스 지원: 다양한 데이터베이스 시스템과 호환되며, 데이터베이스 벤더에 독립적으로 작동한다. 성능 향상: 캐시 기능을 활용하여 데이터베이스 조회 성능을 향상시킬 수 있다.MyBatis는 간단하고 직관적인 SQL 작성과 유연한 매핑 기능을 제공하여 개발자가 데이터베이스와의 상호 작용을 효과적으로 처리할 수 있도록 도와준다.JPA와 MyBatis의 차이JPA와 MyBatis는 둘 다 Java 언어를 기반으로 한 데이터베이스와의 상호 작용을 도와주는 프레임워크다.1.ORM vs. SQL 매핑JPA는 ORM(Object-Relational Mapping) 프레임워크로, 객체와 데이터베이스 테이블 간의 매핑을 자동으로 처리한다. JPA를 사용하면 객체 지향적인 방식으로 데이터베이스를 다룰 수 있으며, SQL 쿼리를 직접 작성하지 않아도 된다.MyBatis는 SQL 매핑 프레임워크로, SQL 쿼리와 객체를 매핑하는 역할을 담당한다. 개발자는 SQL 쿼리를 직접 작성하고, 이를 객체와 연결하여 데이터베이스 작업을 수행한다.2.영속성 관리JPA는 영속성 컨텍스트를 통해 객체의 상태를 관리한다. 영속성 컨텍스트는 데이터베이스와의 작업을 추상화하고, 객체의 변경 사항을 자동으로 감지하여 적절한 SQL 쿼리를 생성하여 데이터베이스에 반영한다.MyBatis는 개발자가 직접 SQL 쿼리를 작성하고 실행하므로, 영속성 컨텍스트를 사용하지 않습니다. 개발자는 객체와 데이터베이스 간의 매핑을 명시적으로 처리해야 한다.3.개발 방식JPA는 객체 중심의 개발 방식을 지향한다. 개발자는 데이터베이스 스키마를 직접 작성하는 대신, 엔티티 클래스와 애노테이션을 사용하여 객체 모델을 정의하고 관리한다.MyBatis는 SQL 중심의 개발 방식을 따른다. 개발자는 SQL 쿼리를 직접 작성하고, 이를 매핑 파일이나 어노테이션을 통해 객체와 연결한다.4.성능JPA는 영속성 컨텍스트와 지연 로딩 등의 기능을 통해 성능을 최적화하고, 캐시를 효과적으로 활용할 수 있다.MyBatis는 개발자가 직접 SQL 쿼리를 작성하고 실행하므로, 성능 튜닝과 최적화에 유연성을 제공한다. 개발자는 SQL 쿼리를 직접 제어하므로 세밀한 조정이 가능하다.5.복잡성JPA는 ORM 프레임워크로, 객체와 데이터베이스 간의 복잡한 매핑 작업을 자동으로 처리한다. 이에 따라 개발자는 데이터베이스 관련 작업에 대한 부분적인 이해만으로도 개발을 진행할 수 있다.MyBatis는 SQL 매핑 프레임워크로, 개발자는 SQL 쿼리를 직접 작성하고 매핑 작업을 수동으로 처리해야 한다. 이는 매핑 작업에 대한 개발자의 이해와 노력을 요구할 수 있다.6.유연성JPA는 객체와 데이터베이스 간의 유연한 매핑을 지원한다. 관계형 데이터베이스의 특성에 대한 추상화를 제공하고, 다양한 객체 간의 관계를 쉽게 표현할 수 있다.MyBatis는 SQL 쿼리를 직접 작성하므로, 개발자는 복잡한 쿼리와 데이터베이스 특정 기능을 유연하게 활용할 수 있다. MyBatis는 데이터베이스에 대한 직접적인 제어를 허용하기 때문에 고도로 커스터마이징이 가능하다.7.학습 곡선JPA는 ORM 프레임워크로, 객체와 데이터베이스 간의 매핑을 추상화하고 간소화하기 때문에 학습 곡선이 상대적으로 높을 수 있다. JPA의 복잡한 개념과 설정을 익히는 데 시간이 걸릴 수 있다.MyBatis는 SQL 매핑 프레임워크로, 개발자가 직접 SQL 쿼리를 작성하므로 학습 곡선이 더 낮을 수 있다. SQL 문법과 데이터베이스 관련 지식에 대한 이해만 있다면 비교적 쉽게 사용할 수 있다.8.데이터베이스 지원JPA는 다양한 데이터베이스를 지원한다. JPA는 벤더 독립적인 API로, 다양한 데이터베이스 시스템과 호환되며, 데이터베이스 간 이식성을 보장한다.MyBatis는 대부분의 관계형 데이터베이스를 지원하지만, 데이터베이스 종속적인 SQL 쿼리를 작성해야 한다. 데이터베이스 종류에 따라 쿼리 작성에 차이가 있을 수 있다.9.프로젝트 규모JPA는 대규모의 복잡한 프로젝트에서 유용하다. JPA는 객체 간의 관계를 관리하고, 영속성 컨텍스트를 통해 데이터베이스 작업을 최적화할 수 있으며, 자동으로 SQL 쿼리를 생성하여 개발 생산성을 높일 수 있다.MyBatis는 작은 규모의 프로젝트나 SQL 쿼리의 세밀한 제어가 필요한 경우에 적합하다. MyBatis는 SQL 쿼리를 직접 작성하고 매핑하기 때문에, 개발자가 쿼리에 직접적으로 개입할 수 있다.결론적으로, JPA는 객체와 데이터베이스 간의 매핑을 자동화하여 객체 지향적인 개발을 지원하며, 성능 최적화와 생산성을 높일 수 있다. MyBatis는 SQL 쿼리와 객체의 매핑을 개발자가 직접 제어하여 유연성과 성능 튜닝에 용이하다." }, { "title": "Javascript 제너레이터와 async/await", "url": "/posts/generator/", "categories": "Javascript", "tags": "javascript", "date": "2022-08-22 00:00:00 +0900", "snippet": "제너레이터제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수다. 제너레이터의 특징은 다음과 같다. 1. 제너레이터함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.일반 함수를 호출하면 제어권이 함수에게 넘어가고 함수 코드를 일관 실행한다. 함수 호출자는 함수를 호출한 이후 함수 실행을 제어할 수 없다. 반면 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다. 다시 말해, 함수 호출자가 함수 실행을 일시 중지시키거나 재개시킬 수 있다. 2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.제너레이터 함수는 함수 호출자와 양방향으로 함수의 상태를 주고받을 수 있다. 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수도 있다. 3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.제너레이터 함수의 정의 // 제너레이터 함수 선언문 function* genDecFunc() { yield 1; } // 제너레이터 함수 표현식 const getExpFunc() { yield 1; } // 제너레이터 메서드 const obj = { * genObjMethod() { yield 1; } }; // 제너레이터 클래스 메서드 class MyClass { * genClsMethod() { yield 1; } } 제너레이터 함수는 화살표 함수로 정의할 수 없다. 그리고 new 연산자와 함께 생성자로 호출할 수 없다.제너레이터 객체제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블럭을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다. 제너레이터 함수가 반환한 제너레이터 객체는 이터러블이면서 동시에 이터레이터다. 제너레이터 객체는 next 메서드를 가지는 이터레이터이므로 Symbol.iterator 메서드를 호출해서 별도로 이터레이터를 생성할 필요가 없다.제너레이터 객체는 next 메서드를 갖는 이터레이터이지만 이터레이터에는 없는 return, throw 메서드를 갖는다. 해당 메서드는 다음과 같이 동작한다. next 메서드는 제너레이터 함수의 yield 표현식까지 코드 블록을 실행하고 yield 된 값을 value 프로퍼티 값으로, false를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다. return 메서드는 인수로 전달받은 값을 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다. throw 메서드는 인수로 전달받은 에러를 발생시키고 undefined를 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.제너레이터 일시 중지와 재개제너레이터는 yield 키워드와 next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다.yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다. function* genFunc() { yield 1; yield 2; yield 3; } const generator = genFunc(); console.log(generator.next()); // { value: 1, done: false } console.log(generator.next()); // { value: 2, done: false } console.log(generator.next()); // { value: 3, done: false } consoel.log(generator.next()); // { value: undefined, done: true }제너레이터 객체의 next 메서드를 호출하면 yield 표현식까지 실행되고 일시 중지 된다. 이때 함수의 제어권이 호출자로 양도(yield)된다. 제너레이터 객체의 next 메서드는 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이때 반환된 이터레이터 리절트 객체의 value 프로퍼티에는 yield 표현식에서 yield된 값이 할당되고 done 프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지를 나타내는 불리언 값이 할당된다.이터레이터의 next 메서드와 달리 제너레이터 객체의 next 메서드에는 인수를 전달할 수 있다. 제너레이터 객체의 next 메서드에 전달한 인수는 제너레이터 함수의 yield 표현식을 할당받는 변수에 할당된다. yield 표현식을 할당받은 변수에 yield 표현식의 평가 결과가 할당되지 않는 것에 주의하자. function* genFunc() { const x = yield 1; const y = yidel (x + 10); return x + y; } const generator = genFunc(0); // 처음 호출하는 next 메서드에는 인수를 전달하지 않는다. 인수를 전달해도 무시된다. let res = generator.next(); console.log(res); // { value: 1, done: false } // next 메서드에 인수로 전달한 10은 genFunc 함수의 x 변수에 할당된다. let res = generator.next(10); console.log(res); // { value: 20, done: false } // next 메서드에 인수로 전달한 20은 genFunc 함수의 y 변수에 할당된다. let res = generator.next(20); console.log(res); // { value: 30, done: false }제너레이터의 활용제너레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고받을 수 있다. 이러한 특성을 통해 프로미스를 통한 비동기 처리를 동기 처리처럼 구현할 수 있다. const async = generatorFunc =&amp;gt; { const generator = generatorFunc(); const onResolved = arg =&amp;gt; { const result = generator.next(arg); return result.done ? result.value : result.value.then(res =&amp;gt; onResolved(res)); }; return onResolved; }; (async(function* fetchTodo() { const url = &#39;https://jsonplaceholder.typicode.com/todos/1&#39;; const response = yield fetch(url); const todo = yield response.json(); console.log(todo); // {userId: 1, id: 1, title: ... } })());위 코드는 제너레이터 실행기를 이해하기 위한 코드이다. 우선 즉시 실행 함수인 fetchTodo가 실행되면서 제너레이터 객체를 생성하고 onResolved 함수를 반환한다. 여기서 onResolved 함수는 상위 스코프의 generator 변수를 기억하는 클로저다. async 함수가 반환한 onResolved 함수를 즉시 호출하여 제너레이터 객체의 next 메서드를 처음 호출한다.next 메서드가 처음 호출된 후 fetchTodo의 첫 번째 yield 문 까지 실행된다. 이때, 첫 번째 yield 된 fetch 함수가 반환한 프로미스가 resolve 한 Response 객체를 onResolved 함수에 인수로 전달하고 재귀 호출을 한다.onResolved 함수에 인수로 전달된 Response 객체를 next 메서드에 인수로 전달하면서 next 메서드를 두 번재로 호출한다.next 메서드가 반환한 이터레이터 리절트 객체의 done 프로퍼티 값이 false이므로, respone.json 메서드가 반환한 프로미스가 resolve한 todo 객체를 onResolved 함수에 인수로 전달하면서 다시 재귀 호출을 한다.onResolved 함수에 인수로 전달된 todo 객체를 next 메서드에 인수로 전달하면서 next 메서드를 세 번째로 호출 한다.next 메서드가 반환한 이터레이터 리절트 객체의 done 프로퍼티가 true로 바뀌면서 fetchTodo 반환값인 undefined를 반환하고 모든 처리가 종료된다.async/awaitES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리르 동기 처리처럼 동작하도록 구현할 수 있는 async/await가 도입되었다. async/await는 프로미스를 기반으로 동작한다. async function fetchTodo() { const url = &#39;https://jsonplaceholder.typicode.com/todos/1&#39;; const response = await fetch(url); const todo = await response.json(); console.log(todo); } fetchTodo();async 함수await 키워드는 반드시 async 함수 내부에서 사용해야 한다. async 함수는 언제나 프로미스를 반환하며, 명시적으로 프로미스를 반환하지 않더라도 암묵적으로 반환값을 resolve 하는 프로미스를 반환한다. async function foo(n) { return n; } foo(1).then(v =&amp;gt; console.log(v)); // 1 const bar = async function(n) { return n; } bar(2).then(v =&amp;gt; console.log(v)); // 2 const baz = async n =&amp;gt; n; baz(3).then(v =&amp;gt; console.log(v)); // 3 const obj = { async foo(n) { return n; } }; obj.foo(4).then(v =&amp;gt; console.log(v)); // 4 class MyClass { async bar(n) { return n; } } const myClass = new MyClass(); myClass.bar(5).then(v =&amp;gt; console.log(v)); // 5클래스의 constructor 메서드는 async 메서드가 될 수 없다.await 키워드await 키워드는 프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다. await 키워드는 반드시 프로미스 앞에서 사용해야 한다. const getData = async id =&amp;gt; { const res = await fetch(`https://api/users/${id}`); const { name } = await res.json(); console.log(name); } getData(1);fetch 함수가 수행한 HTTP 요청에 대한 응답이 도착해서 fetch 함수가 반환한 프로미스가 settled 상태가 될때까지 첫 번째 await는 대기한다. 이후 프로미가 settled 상태가 되면 프로미스가 resolve한 처리 결과가 res 변수에 할당된다.이러한 async/await 특성은 비동기 처리를 순차적으로 진행해야할 때 사용할 수 있다.에러 처리async/await에서는 try…catch문으로 에러 처리를 할 수 있다. 콜백 함수를 인수로 전달받는 비동기 함수와 달리 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때누에 호출자가 명확하기 때문이다. const foo = async() =&amp;gt; { try { const wrongUrl = &#39;https://wrong.url&#39;; const response = await fetch(wrongUrl); const data = await response.json(); console.log(data); } catch (err) { console.error(err); } }; foo();async 함수 내에서 catch 문을 사용해서 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환한다. 따라서 async 함수를 호출하고 Promise.prototype.catch 후속 처리 메서드를 사용해 에러를 캐치할 수도 있다. const foo = async() =&amp;gt; { cosnt wrongUrl = &#39;https://wrong.url&#39;; const response = await fetch(wrongUrl); const data = await response.json(); return data; }; foo() .then(console.log) .catch(console.error);" }, { "title": "Javascript 프로미스", "url": "/posts/promise/", "categories": "Javascript", "tags": "javascript", "date": "2022-08-19 00:00:00 +0900", "snippet": "콜백 패턴의 단점콜백 헬 const get = url =&amp;gt; { const xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url); xhr.send(); xhr.onload = () =&amp;gt; { if (xhr.status === 200) { console.log(JSON.parse(xhr.response)); } else { console.error(`${xhr.status} ${xhr.statusText}`); } }; }; get(&#39;https://jsonplaceholder.typicode.com/posts/1&#39;);비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않아도 기다리지 않고 즉시 종료된다. 즉, 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다. 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다. 따라서 비동기 함수의 처리 결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다. 이런 후속 처리를 위해 콜백 함수를 전달하게 되면서 콜백 헬이 만들어 진다. const get = (url, callback) =&amp;gt; { const xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url); xhr.send(); xhr.onload = () =&amp;gt; { if(xhr.status === 200) { callback(JSON.parse(xhr.response)); } else { console.error(`${xhr.status} ${xhr.statusText}`); } }; }; const url = &#39;https://jsonplaceholder.typicode.com&#39;; // id가 1인 post의 userId를 취득 get(`${url}/posts/1`, ({ userId }) =&amp;gt; { console.log(userId); // 1 // post의 userId를 사용하여 user 정보를 취득 get(`${url}/users/${userId}`, userInfo =&amp;gt; { console.log(userInfo); }); });이러한 콜백 헬은 가독성이 낮아 실수를 유발할 수 있다.에러 처리콜백 패턴에서 가장 큰 문제점은 에러 처리가 곤란하다는 점이다. try { setTimeout(() =&amp;gt; { throw new Error(&#39;Error!&#39;); }, 1000); } catch (e) { // 캐치 안됨 console.error(e); }setTimeout 함수의 콜백 함수가 실행될 때 setTimeout 함수는 이미 콜 스택에서 제거된 상태다. 이 말은 콜백 함수를 호출한 것이 setTimeout 함수가 아니라는 것을 의미한다. 에러는 호출자 방향으로 전파된다. 따라서 위 코드에서 콜백 함수의 호출자는 setTimeout 함수가 아니며, 에러는 catch 블록에서 캐치되지 않는다.콜백 패턴에서 문제가되는 콜백 헬과 에러 처리 문제를 극복하기 위해 ES6에서 프로미스가 도입되었다.프로미스 생성Promise는 ECMAScript 사양에 정의된 표준 빌트인 객체다. Promise 생성자 함수를 new 연산자와 함께 호출하면 Promise 객체를 생성한다. Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.Promise 생성자 함수는 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행한다. 이때 비동기 처리가 성공하면 콜백 함수의 인수로 전달받은 resolve 함수를 호출하고, 비동기 처리를 실패하면 reject 함수를 호출한다. const promiseGet = url =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { const xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url); xhr.send(); xhr.onload = () =&amp;gt; { if(xhr.status === 200) { resolve(JSON.parse(xhr.response)); } else { reject(new Error(xhr.status)); } }; }); }; promiseGet(&#39;https://jsonplaceholder.typicode.com/posts/1&#39;);비동기 함수인 promiseGet은 함수 내부에서 프로미스를 생성하고 반환한다. 비동기 처리는 Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 수행한다. 프로미스는 아래와 같이 현재 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태 정보를 갖는다. 프로미스의 상태 정보 의미 상태 변경 조건 pending 비동기 처리가 아직 수행되지 않는 상태 프로미스가 생성된 직후 기본 상태 fulfilled 비동기 처리가 수행된 상태(성공) resolve 함수 호출 fulfilled 비동기 처리가 수행된 상태(실패) reject 함수 호출 비동기 처리가 성공하면 프로미스는 pending 상태에서 fulfilled 상태로 변하고 resolve 함수의 결과값을 갖는다. 비동기 처리가 실패하면 프로미스는 pending 상태에서 rejected 상태로 변하고 reject 함수의 결과값을 갖는다. 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.프로미스 후속 처리 메서드프로미스는 처리 결과의 후속 처리를 위해 후속 메서드 then, catch, finally를 제공한다. 프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다. 이때 후속 처리 메서드의 콜백 함수에 프로미스의 처리 결과가 인수로 전달된다.Promise.prototype.thenthen 메서드는 두 개의 콜백 함수를 인수로 받는다. 첫 번째 함수는 프로미스가 fulfilled 상태가 되면 호출된다. 이때 콜백 함수는 프로미스의 비동기 처리 결과를 인수로 전달받는다. 두 번째 함수는 프로미스가 rejected 상태가 되면 호출된다. 이때 콜백 함수는 프로미스의 에러를 인수로 받는다. // fulfilled new Promise(resolve =&amp;gt; resolve(&#39;fulfilled&#39;)) .then(v =&amp;gt; console.log(v), e =&amp;gt; console.error(e)); // rejected new Promise((_, reject) =&amp;gt; reject(new Error(&#39;rejected&#39;))) .then(v =&amp;gt; console.log(v), e =&amp;gt; console.error(e));then 메서드는 언제나 프로미스를 반환한다. then 메서드의 콜백 함수가 프로미스를 반환하면 그 프로미스를 그대로 반환하고, 콜백 함수가 프로미스가 아닌 값을 반환하면 그 값을 암묵적으로 resolve 또는 reject하여 프로미스를 생성해 반환한다.Promise.prototype.catchcatch 메서드는 한 개의 콜백 함수를 인수로 전달받는다. catch 메서드의 콜백 함수는 프로미스가 rejected 상태인 경우만 호출한다. // rejected new Promise((_, reject) =&amp;gt; reject(new Error(&#39;rejected&#39;))) .catch(e =&amp;gt; console.log(e));catch 메서드는 then(undefined. onRejected)과 동일하게 동작한다. 따라서 언제나 프로미스를 반환한다.Promise.prototype.finallyfinally 메서드는 한 개의 콜백 함수를 인수로 전달받는다. finally 메서드의 콜백 함수는 프로미스의 성공 또는 실패와 상관없이 무조건 한 번 호출된다. finally 메서드는 프로미스의 상태와 상관없이 공톡적으로 수행해야 할 처리가 있을 때 유용하다. finally 메서드도 언제나 프로미스를 반환한다. const promiseGet = url =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { const xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url); xhr.send(); xhr.onload = () =&amp;gt; { if(xhr.status === 200) { resolve(JSON.parse(xhr.response)); } else { reject(new Error(xhr.status)); } }; }); }; promiseGet(&#39;https://jsonplaceholder.typicode.com/posts/1&#39;) .then(res =&amp;gt; console.log(res)) .catch(err =&amp;gt; console.error(err)) .finally(() =&amp;gt; console.log(&#39;Bye&#39;));프로미스 에러 처리프로미스는 then 메서드의 두 번째 콜백 함수와 catch 메서드를 통해서 에러를 처리할 수 있다. // then 메서드의 두 번째 콜백 함수를 통한 에러 처리 promiseGet(wrongUrl).then( res =&amp;gt; console.log(res), err =&amp;gt; console.error(err) ); // catch 메서드를 통한 에러 처리 promiseGet(wrongUrl) .then(res =&amp;gt; console.log(res)) .catch(err =&amp;gt; console.error(err));단, then 메서드의 두 번째 콜백 함수는 첫 번쨰 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드의 가독성이 떨어진다. 따라서 에러 처리는 catch 메서드에서 처리하는 것이 권장된다.프로미스 체이닝 const url = &#39;https://jsonplaceholder.typicode.com&#39;; promiseGet(`${url}/posts/1`) .then(({ userId }) =&amp;gt; promiseGet(`${url}/users/${userId}`)) .then(userInfo =&amp;gt; console.log(userInfo)) .catch(err =&amp;gt; console.error(err));then, catch, finally 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있다. 이것을 프로미스 체이닝이라 한다. 프로미스는 프로미스 체이닝을 통해 비동기 처리 결과를 전달받아 후속 처리를 하므로 비동기 처리를 위한 콜백 패턴에서 발생하던 콜백 헬이 발생하지 않는다.프로미스의 정적 메서드Promise.resolve/Promise.rejectPromise.resolve/Promise.reject 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.Promise.allPromise.all 메서드는 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용한다. const requestData1 = () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(1), 3000)); const requestData2 = () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(2), 2000)); const requestData3 = () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(3), 1000)); Promise.all[requestData1(), requestData2(), requestData3()] .then(console.log) // [1, 2, 3] .catch(console.error);Promise.all 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다. 전달받은 모든 프로미스가 fulfilled 상태가 되면 모든 처리 결과를 배열에 저장해 새로운 프로미스를 반환한다. 따라서 Promise.all 메서드를 종료하는데 걸리는 시간은 가장 늦게 fulfilled 상태가 되는 프로미스가 처리되는 시간이다.Promise.all 메서드는 어떤 프로미스가 먼저 fulfilled 상태가 되는지와 관계없이 순서가 보장된다.Promise.all 메서드는 인수로 전달받은 배열의 프로미스가 하나라도 rejected 상태가 되면 나머지 프로미스가 fulfilled 상태가 되는 것을 기다리지 않고 즉시 종료된다.Promise.racePromise.race는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다. Promise.all과 차이점은 Promise.all 메서드처럼 모든 프로미스가 fulfilled 상태가 되는 것을 기다리는 것이 아니라 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve하는 새로운 프로미스를 반환한다. const requestData1 = () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(1), 3000)); const requestData2 = () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(2), 2000)); const requestData3 = () =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(3), 1000)); Promise.race[requestData1(), requestData2(), requestData3()] .then(console.log) // 3 .catch(console.error);Promise.allSettledPromise.allSetteled 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받은다. Promise.all과 달리 fulfilled 또는 rejected 상태와 관계없이 모든 프로미스들의 처리 결과를 모두 담아 반환한다. Promise.allSetteled([ new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; resolve(1), 2000)), new Promise((_, reject) =&amp;gt; setTimeout(() =&amp;gt; reject(new Error(&#39;Error&#39;)), 1000)) ]).then(console.log); /* [ {status: &quot;fulfilled&quot;, value: 1}, {status: &quot;rejected&quot;, reason: Error: Error} ] */프로미스가 fulfilled 상태인 경우에는 status 와 value 프로퍼티를 갖는다. 프로미가 rejected 상태인 경우에는 status 와 reason 프로퍼티를 갖는다.마이크로태스크 큐 setTimeout(() =&amp;gt; console.log(1), 0); Promise.resolve() .then(() =&amp;gt; console.log(2)) .then(() =&amp;gt; console.log(3));위 코드를 실행하면 1 &amp;gt; 2 &amp;gt; 3 이 출력될 것으로 보이지만 실제로는 2 &amp;gt; 3 &amp;gt; 1 이 출력된다. 그 이유는 프로미스의 후속 처리 메서드의 콜백 함수는 태스크 큐가 아니라 마이크로태스크 큐에 저장되기 때문이다.마이크로태스크 큐에는 프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장된다. 그 외 비동기 함수의 콜백 함수나 이벤트 핸들러는 태스크 큐에 일시 저장된다. 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다. 즉, 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 실행한다.fetchfetch 함수는 XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API다. fetch 함수는 XMLHttpRequest 객체보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다.fetch 함수는 HTTP 요청을 전송할 URL과 HTTP 요청 메서드, HTTP 요청 헤더, 페이로드 등을 설정한 객체를 전달한다. fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다. fetch(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;) // response는 HTTP 응답을 나타내는 Response 객체 // json 메서드를 사용해서 역직렬화 .then(response =&amp;gt; response.json()) .then(json =&amp;gt; console.log(json));fetch 함수에서는 에러 처리에 주의해야 한다. fetch(wrongUrl) .then(() =&amp;gt; console.log(&#39;ok&#39;)) .catch(() =&amp;gt; console.log(&#39;error&#39;));위 코드를 실행하면 ‘ok’가 출력된다. fetch 함수가 반환하는 프로미스는 기본적으로 404, 500 에러가 발생해도 에러를 reject하지 않고 불리언 타입의 ok 상태를 false로 설정한 Response 객체를 resolve 한다. 오프라인 등의 네트워크 장애나 CROS 에러에 의해 요청이 완료되지 못한 경우에만 프로미스를 reject 한다.따라서 fetch 함수가 반환한 프로미스가 resolve한 불리언 타입의 ok 상태를 확인해서 명시적으로 에러를 처리해야 한다. fetch(wrongUrl) .then(response =&amp;gt; { if(!response.ok) throw new Error(response.statusText); return response.json(); }) .then(todo =&amp;gt; console.log(todo)) .catch(err =&amp;gt; console.error(err));axios는 클라이언트 단에서 서버에 요청을 보내기 위해 사용하는 비동기 통신 라이브러리로 fetch와 다르게 모든 HTTP 에러를 reject하는 프로미스를 반환한다. 따라서 모든 에러를 catch로 처리할 수 있어 편리하다. axios와 fetch를 상황에 맞게 잘 활용하자. GET 요청 request.get(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;) .then(response =&amp;gt; { if(!request.ok) throw new Error(response.statusText); return response.json(); }) .then(todos =&amp;gt; console.log(todos)) .catch(err =&amp;gt; console.error(err)); POST 요청 request.post(&#39;https://jsonplaceholder.typicode.com/todos&#39;, { userId: 1, title: &#39;JS&#39;, completed: false }) .then(response =&amp;gt; { if(!response.ok) throw new Error(response.statusText); return response.json(); }) .then(todos =&amp;gt; console.log(todos)) .catch(err =&amp;gt; console.error(err)); PATCH 요청 request.patch(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;, { completed: true }) .then(response =&amp;gt; { if(!response.ok) throw new Error(response.statusText); return response.json(); }) .then(todos =&amp;gt; console.log(todos)) .catch(err =&amp;gt; console.error(err)); DELETE 요청 request.delete(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;) .then(response =&amp;gt; { if(!response.ok) throw new Error(response.statusText); return response.json(); }) .then(todos =&amp;gt; console.log(todos)) .catch(err =&amp;gt; console.error(err));" }, { "title": "Javascript 비동기 프로그래밍", "url": "/posts/async/", "categories": "Javascript", "tags": "javascript", "date": "2022-08-17 00:00:00 +0900", "snippet": "동기 처리와 비동기 처리함수가 실행되려면 함수 코드 평가 과정에서 생성된 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되어야 한다. 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문이다.자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 즉 2개 이상의 함수를 동시에 실행할 수 없다. 실행 컨텍스트 스택의 최상위 요소인 실행 중인 컨텍스트를 제외한 모든 실행 컨텍스트는 실행 대기 중인 태스크들이다.이처럼 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작한다. 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행할 경우 블로킹(작업 중단)이 발생한다.이처럼 현재 실행 중인 태스크가 종료할 때까지 다음 실행될 태스크가 대기하는 방식을 동기 처리라 한다.setTimeout 함수를 생각해 보자. setTimeout 함수는 일정 시간이 경과한 후 콜백 함수를 호출하며, setTimeout 함수 이후 블로킹 없이 다음 태스크를 실행한다.이처럼 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 처리라 한다.동기 처리의 경우 태스크가 블로킹되는 단점이 있지만 실행 순서를 보장한다는 장점이 있다. 반면 비동기 처리의 경우 태스크가 블로킹되지 않지만 실행 순서를 보장할 수 없다는 단점이 있다.이벤트 루프와 태스크 큐자바스크립트는 싱글 스레드로 동작하지만 브라우저의 동작을 살펴보면 태스크가 동시에 처리되는 것처럼 느껴진다. 자바스크립트는 이벤트 루프를 통해 동시성을 지원한다. 이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나이다. 이벤트 루프와 브라우저 환경을 도식화 하면 아래 그림과 같다.함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다. 실행 컨텍스트는 힙에 저장된 객체를 참조한다. 콜 스택과 힙으로 구성된 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다. 비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다. 비동기 처리의 스케줄을 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.태스크 큐는 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다. 이벤트 루프는 콜 스택에서 현재 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지를 반복적으로 확인한다. 만약 콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다. 콜 스택으로 이동한 함수는 실행된다.중요한 점은 자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다는 것이다." }, { "title": "Javascript Ajax", "url": "/posts/Ajax/", "categories": "Javascript", "tags": "javascript", "date": "2022-08-17 00:00:00 +0900", "snippet": "Ajax(Asynchronous Javascript and XML)란 브라우저가 서버에 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹 페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다. Ajax는 브라우저에서 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작한다. XMLHttpRequest는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공한다.Ajax는 다음과 같은 장점을 가진다. 변경할 부분을 갱신하는데 필요한 데이터만 서버로부터 전송받기 때문에 불필요한 데이터 통신이 발생하지 않는다. 변경할 필요가 없는 부분은 다시 렌더링하지 않는다. 비동기 방식으로 동작하기 때문에 서버에게 요청을 보낸 후 블로킹이 발생하지 않는다. JSONJSON(JavaScript Object Notation)은 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다.JSON 표기 방식JSON은 객체 리터럴과 유사하게 키와 값으로 구성된 순수한 텍스트다. JSON의 키는 큰따옴표로 묶고, 값은 객체 리터럴과 같은 표기법을 그대로 사용할 수 있다. 하지만 문자열은 반드시 큰따옴표로 묶어야 한다.{ &quot;name&quot;: &quot;Roy&quot;, &quot;age&quot;: 7, &quot;hobby&quot;: [&quot;Photosynthesis&quot;, &quot;chur&quot;]}JSON.stringifyJSON.stringify 메서드는 객체를 JSON 포맷의 문자열로 변환한다. 클라이언트가 서버로 객체를 전송하려면 객체를 문자열화해야 하며 이를 직렬화라 한다. const obj = { &quot;name&quot;: &quot;Roy&quot;, &quot;age&quot;: 7, &quot;hobby&quot;: [&quot;Photosynthesis&quot;, &quot;chur&quot;] }; // 객체를 JSON 포맷 문자열로 변환 const json = JSON.stringify(obj); console.log(typeof json, json); // string {&quot;name&quot;:&quot;Roy&quot;, &quot;age&quot;:7, &quot;hobby&quot;:[&quot;Photosynthesis&quot;,&quot;chur&quot;]} // 들여쓰기 const prettyJson = JSON.stringify(obj, null, 2); console.log(typeof prettyJson, prettyJson); /* string { &quot;name&quot;:&quot;Roy&quot;, &quot;age&quot;:7, &quot;hobby&quot;:[ &quot;Photosynthesis&quot;, &quot;chur&quot; ] } */JSON.stringify 메서드는 객체뿐만 아니라 배열도 JSON 포맷의 문자열로 변환한다. const todos = [ {id: 1, content: &#39;HTML&#39;, completed: false}, {id: 2, content: &#39;CSS&#39;, completed: true}, {id: 3, content: &#39;Javascript&#39;, completed: false}, ]; const json = JSON.stringify(todos, null, 2); console.log(typeof json, json); /* string [ { &quot;id&quot;: 1, &quot;content&quot;: &quot;HTML&quot;, &quot;completed&quot;: false }, { &quot;id&quot;: 2, &quot;content&quot;: &quot;CSS&quot;, &quot;completed&quot;: true }, { &quot;id&quot;: 3, &quot;content&quot;: &quot;Javascript&quot;, &quot;completed&quot;: false } ] */JSON.parseJSON.parse 메서드는 JSON 포맷의 문자열을 객체로 변환한다. 서버로부터 클라이언트에게 전송된 JSON 데이터는 문자열이다. 이것을 객체로 사용하기위해 JSON 포맷의 문자열을 객체화 해야하고 이를 역직렬화라 한다. const obj = { &quot;name&quot;: &quot;Roy&quot;, &quot;age&quot;: 7, &quot;hobby&quot;: [&quot;Photosynthesis&quot;, &quot;chur&quot;] }; const json = JSON.stringify(obj); const parsed = JSON.parse(json); console.log(typeof parsed, parsed); // object {name:&quot;Roy&quot;, age:7, hobby:[&quot;Photosynthesis&quot;,&quot;chur&quot;]}XMLHttpRequest자바스크립트를 사용하여 HTTP 요청을 전송하려면 XMLHttpRequest 객체를 사용한다. Web API인 XMLHttpReqeust 객체는 HTTP 요청 전송과 HTTP 응답 수신을 위한 다양한 메서드와 프로퍼티를 제공한다.HTTP 요청 전송HTTP 요청을 전송하는 경우 다음 순서를 따른다. XMLHttpRequest.prototype.open 메서드로 HTTP 요청을 초기화한다. 필요에 따라 XMLHttpRequest.prototype.setRequestHeader 메서드로 특정 HTTP 요청의 헤더 값을 설정한다. XMLHttpRequest.prototype.send 메서드로 HTTP 요청을 전송한다. // XMLHttpRequest 객체 생성 const xhr = new XMLHttpRequest(); // HTTP 요청 초기화 xhr.open(&#39;GET&#39;, &#39;/users&#39;); // HTTP 요청 헤더 설정 // 클라이언트가 서버로 전송할 데이터의 MIME 타입 지정: json xhr.setRequestHeader(&#39;content-type&#39;, &#39;application/json&#39;); //HTTP 요청 전송 xhr.send();HTTP 응답 처리서버가 전송한 응답을 처리하려면 XMLHttpRequest 객체가 발생시키는 이벤트를 캐치해야 한다. XMLHttpRequest 객체가 가지는 이벤트 핸들러 프로퍼티를 통해 이벤트를 캐치하고 HTTP 응답을 처리할 수 있다. const xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;https://jsonplaceholder.typicode.com/todos/1&#39;); xhr.send(); xhr.onreadystatechange = () =&amp;gt; { if(xhr.readyState !== XMLHttpRequest.DONE) return; if(xhr.status === 200) { console.log(JSON.parse(xhr.response)); } else { console.log(&#39;Error&#39;, xhr.status, xhr.statusText); } };readystatechange 이벤트는 HTTP 요청의 현재 상태를 나타내는 readyState 프로퍼티가 변경될 때마다 발생한다. readystatechange 이벤트 대신 load 이벤트를 캐치해도 좋다. load 이벤트는 HTTP 요청이 성공적으로 완료된 경우 발생한다. const xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;https://jsonplaceholer.typicode.com/todos/1&#39;); xhr.send(); xhr.onload = () =&amp;gt; { if(xhr.status === 200) { console.log(JSON.parse(xhr.response)); } else { console.error(&#39;Error&#39;, xhr.status, xhr.statusText); } };" }, { "title": "Javascript Timer", "url": "/posts/Timer/", "categories": "Javascript", "tags": "javascript", "date": "2022-08-12 00:00:00 +0900", "snippet": "호출 스케줄링함수를 명시적으로 호출하지 않고 일정 시간 경과 후 호출되도록 함수 호출을 예약하려면 타이머 함수를 사용한다. 자바스크립트에서는 타이머를 생성할 수 있는 타이머 함수 setTimeout과 setInterval, 타이머를 제거할 수 있는 타이머 함수 clearTimeout과 clearInterval을 제공한다.타이머 함수 setTimeout과 setInterval은 모두 일정 시간이 경과된 이후 콜백 함수가 호출되도록 타이머를 생성한다. setTimeout 함수로 생성한 타이머는 단 한 번 동작하고, setInterval 함수가 생성한 타이머는 반복 동작한다.자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는 싱글 스레드로 동작한다. 이런 이유로 타이머 함수 setTimeout과 setInterval은 비동기 처리 방식으로 동작한다.타이머 함수setTimeout / clearTimeout // 첫 번째 인수로 콜백 함수를 전달한다. // 두 번째 인수인 1000은 1초(1000ms) 이다. setTimeout(() =&amp;gt; console.log(&#39;Hello&#39;), 1000); // 세 번째 이후의 인수는 콜백 함수로 전달할 인수이다. setTimeout(() =&amp;gt; name =&amp;gt; console.log(`${name}`), 1000, &#39;Roy&#39;); // 두 번째 인수를 생략할 경우 기본값 0이 지정된다. setTimeout(() =&amp;gt; console.log(&#39;Hello&#39;)); // setTimeout 함수는 생성된 타이머를 식별할 수 있는 고유한 타이머 id를 반환함 const timerId = setTimeout(() =&amp;gt; console.log(&#39;Hello&#39;), 1000); // clearTimeout 함수는 타이머 id를 인수로 전달받아 해당 타이머를 제거한다. clearTimeout(timerId);setInterval / clearInterval let count = 1; // 1초 간격으로 콜백 함수 호출 const timeoutId = setInterval(() =&amp;gt; { console.log(count); // count가 5일 경우 clearInterval 함수로 타이머 제거 if(count++ === 5) clearInterval(timeoutId); }, 1000);디바인스와 스로틀scroll, resize, input, mousemove와 같은 이벤트는 짧은 시간에 연속적으로 발생한다. 이러한 이벤트에 바인딩한 이벤트 핸들러를 과도하게 호출되어 성능에 문제가 발생한다. 디바운스와 스로틀은 이러한 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법이다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button&amp;gt;click&amp;lt;/button&amp;gt; &amp;lt;pre&amp;gt;일반 이벤트 카운터 &amp;lt;span class=&quot;normal&quot;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;/pre&amp;gt; &amp;lt;pre&amp;gt;디바운스 이벤트 카운터 &amp;lt;span class=&quot;debounce&quot;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;/pre&amp;gt; &amp;lt;pre&amp;gt;스로틀 이벤트 카운터 &amp;lt;span class=&quot;throttle&quot;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;/pre&amp;gt; &amp;lt;script&amp;gt; const $button = document.querySelector(&#39;button&#39;); const $normal = document.querySelector(&#39;.normal&#39;); const $debounce = document.querySelector(&#39;.debounce&#39;); const $throttle = document.querySelector(&#39;.throttle&#39;); const debounce = (callback, delay) =&amp;gt; { let timerId; return event =&amp;gt; { // delay가 경과하기 이전의 이벤트가 발생하면 이전 타이머를 취소하고 새로운 타이머 설정 // delay보다 짧은 간격으로 이벤트가 발생하면 callback은 호출되지 않는다. if(timerId) clearTimeout(timerId); timerId = setTimeout(callback, delay, event); }; }; const throttle = (callback, delay) =&amp;gt; { let timerId; return event =&amp;gt; { // delay가 경과하기 이전에 이벤트가 발생하면 아무것도 하지 않는다. // delay가 경과했을 때 이벤트가 발생하면 타이머를 재설정한다. // delya 간격으로 callback 함수를 호출 if(tiemrId) return; timerId = setTimeout(() =&amp;gt; { callback(event); timerId = null; }, delay, event); }; }; $button.addEventListener(&#39;clcick&#39;, () =&amp;gt; { $normal.textContent = +$normal.textContent + 1; }); $button.addEventListener(&#39;clcik&#39;, debounce(() =&amp;gt; { $debounce.textContent = +$debounce.textContent + 1; }, 500)); $button.addEventListener(&#39;click&#39;, throttle(() =&amp;gt; { $throttle.textContent = +$throttle.textContent + 1; }, 500)); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;디바운스는 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러는 호출하지 않다가 일정 시간이 경과한 이후 이벤트 핸들러가 한 번만 호출되도록 한다. 디바운스는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다.마지막 이벤트에만 이벤트 핸들러를 호출하는 디바운스는 Ajax 요청과 같이 무서운 처리를 수행할 경우 적합하다. 또는 resize 이벤트 처리, 버튼 중복 클릭 방지 처리에 유용하다. 실무에서는 Underscore의 debounce 함수나 Lodash의 debounce 함수를 사용할 것을 권장한다.스로틀은 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한번만 호출되도록 한다. 즉, 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.스로틀은 일정 시간 간격으로 이벤트가 발생하며 scroll 이벤트 처리나 무한 스크롤 UI 구현 등에 유용하게 사용된다. 실무에서는 Underscore의 throttle 함수나 Lodash의 throttle 함수를 사용하는 것을 권장한다." }, { "title": "Javascript Event_02", "url": "/posts/event-02/", "categories": "Javascript", "tags": "javascript", "date": "2022-08-09 00:00:00 +0900", "snippet": "이벤트 객체이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다. 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;click&amp;lt;/p&amp;gt; &amp;lt;em class=&quot;message&quot;&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;script&amp;gt; const $msg = document.querySelector(&#39;.message&#39;); function printXY(e) { $msg.textContent = `clientX: ${e.clientX}, clientY: ${e.clientY}`; } document.onclick = printXY; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트에 의해 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달되어 매개변수 e에 암묵적으로 할당된다. 이벤트 객체를 전달받으려면 이벤트 핸들러를 정의할 때 이벤트 객체를 전달받을 매개변수를 명시적으로 선언해야 한다.이벤트 핸들러 어트리뷰트 방식으로 이벤트 핸들러를 등록한 경우 아래와 같이 이벤트 객체를 전달받을 수 있다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; html, body { height: 100%; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body onclick=&quot;printXY(event)&quot;&amp;gt; &amp;lt;p&amp;gt;click&amp;lt;/p&amp;gt; &amp;lt;em class=&quot;message&quot;&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;script&amp;gt; const $msg = document.querySelector(&#39;.message&#39;); function printXY(e) { $msg.textContent = `clientX: ${e.clientX}, clientY: ${e.clientY}`; } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트 핸들러 어트리뷰트 방식의 경우 이벤트 객체를 전달받으려면 이벤트 핸들러의 첫 번째 매개변수 이름을 반드시 event이어야 한다. 만약 다른 이름으로 매개변수를 선언하면 이벤트 객체를 전달받지 못한다.이벤트 전파DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파된다. 이벤트 전파는 이벤트 객체가 전파되는 방향에 따라 다음과 같이 3단계로 구분할 수 있다. 캡처링 단계 : 이벤트가 상위 요소에서 하위 요소 방향으로 전파 타깃 단계 : 이벤트가 이벤트 타깃에 도달 버블링 단계 : 이벤트가 하위 요소에서 상위 요소 방향으로 전파 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만 캐치할 수 있다. 하지만 addEventListener 메서드 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계뿐만 아니라 캡처링 단계의 이벤트도 선별적으로 캐치할 수 있다. 캡처링 단계의 이벤트를 캐치하려면 addEventListener 메서드의 3번째 인수로 true를 전달해야 한다. 3번째 인수를 생략하거나 false를 전달하면 타깃 단계와 버블링 단계의 이벤트만 캐치할 수 있다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul id=&quot;ul&quot;&amp;gt; &amp;lt;li id=&quot;aaa&quot;&amp;gt;aaa&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;bbb&quot;&amp;gt;bbb&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;ccc&quot;&amp;gt;ccc&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; const $ul = document.getElementById(&#39;ul&#39;); const $aaa = document.getElementById(&#39;aaa&#39;); $ul.addEventListener(&#39;click&#39;, e =&amp;gt; { console.log(`이벤트 단계: ${e.eventPhase}`); // 캡처링 단계 console.log(`이벤트 타깃: ${e.target}`); console.log(`커런트 타깃: ${e.currentTarget}`); }, true); $aaa.addEventListener(&#39;click&#39;, e =&amp;gt; { console.log(`이벤트 단계: ${e.eventPhase}`); // 타깃 단계 console.log(`이벤트 타깃: ${e.target}`); console.log(`커런트 타깃: ${e.currentTarget}`); }); $ul.addEventListener(&#39;click&#39;, e =&amp;gt; { console.log(`이벤트 단계: ${e.eventPhase}`); // 버블링 단계 console.log(`이벤트 타깃: ${e.target}`); console.log(`커런트 타깃: ${e.currentTarte}`); }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다. DOM 트리를 통해 전파되는 이벤트는 이벤트 패스에 위치한 모든 DOM 요소엥서 캐치할 수 있다.이벤트 위임이벤트 위임은 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다. 이벤트 전파에서 살펴본 것 처럼 이벤트는 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다. 이벤트 위임을 통해 상위 DOM 요소에 이벤트 핸들러를 등록하면 여러 개의 하위 DOM 요소에 이벤트 핸들러를 등록할 필요가 없다. 또한 동적으로 하위 DOM 요소를 추가하더라도 일일이 추가된 DOM 요소에 이벤트 핸들러를 등록할 필요가 없다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; #ul { display: flex; list-style-type: none; padding: 0; } #ul li { width: 100px; cursor: pointer; } #ul .active { color: red; text-decoration: underline; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;nav&amp;gt; &amp;lt;ul id=&quot;ul&quot;&amp;gt; &amp;lt;li id=&quot;aaa&quot; class=&quot;active&quot;&amp;gt;aaa&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;bbb&quot;&amp;gt;bbb&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;ccc&quot;&amp;gt;ccc&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;div&amp;gt;Select li: &amp;lt;em class=&quot;msg&quot;&amp;gt;aaa&amp;lt;/em&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const $ul = document.getElementById(&#39;ul&#39;); const $msg = document.getElementById(&#39;.msg&#39;); function activate({ target }) { if(!target.matches(&#39;#ul &amp;gt; li&#39;)) return; [...$ul.children].forEach($ul =&amp;gt; { $ul.classList.toggle(&#39;active&#39;, $ul === target); $msg.textContent = target.id; }); } $ul.onclick = activate; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트 위임을 통해 하위 DOM 요소에서 발생한 이벤트를 처리할 때 주의할 점은 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트 타깃, 즉 이벤트를 실제로 발생시킨 DOM 요소가 개발자가 기대한 DOM 요소가 아닐 수 도 있다는 것이다.일반적으로 이벤트 객체의 target 프로퍼티와 currentTarget 프로퍼티는 동일한 DOM 요소를 가리키지만 이벤트 위임을 통해 상위 DOM 요소에 이벤트를 바인딩한 경우 이벤트 객체의 target 프로퍼티와 currentTarget 프로퍼티가 다른 DOM 요소를 가리킬 수 있다.이벤트 핸들러 내부의 this이벤트 핸들러 어트리뷰트의 값으로 지정한 문자열은 암묵적으로 생성되는 이벤트 핸들러의 문이다. 따라서 일반 함수로 호출된다. 일반 함수로서 호출되는 함수 내부의 this는 전역 객체를 가리킨다. 따라서 이벤트 핸들러 어트리뷰트로 지정한 이벤트 핸들러의 this는 전역 객체 window를 가리킨다.단, 이벤트 핸들러를 호출할 때 인수로 전달한 this는 이벤트를 바인딩한 DOM 요소를 가리킨다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button onclick=&quot;handleClick(this)&quot;&amp;gt;Click&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function handleClick(button) { console.log(button); // button 요소 console.log(this); // window } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다. 즉, 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button class=&quot;btn1&quot;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn2&quot;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button1 = document.querySelector(&#39;.btn1&#39;); const $button2 = document.querySelector(&#39;.btn2&#39;); // 이벤트 핸들러 프로퍼티 방식 $button1.onclick = function (e) { console.log(this); // $button1 console.log(e.currentTarget); // $button1 console.log(this === e.currentTarget); // true ++this.textContent; }; // addEventListener 메서드 방식 $button2.addEventListener(&#39;click&#39;, function (e) { console.log(this); // $button2 console.log(e.currentTarget); // $button2 console.log(this === e.currentTarget); // true ++this.textContent; }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킨다. 화살표 함수는 함수 자체의 this 바인등을 갖지 않는다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button class=&quot;btn1&quot;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn2&quot;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button1 = document.querySelector(&#39;.btn1&#39;); const $button2 = document.querySelector(&#39;.btn2&#39;); $button1.onclick = e =&amp;gt; { // 화살표 함수 내부의 this는 상위 스코프의 this console.log(this); // window console.log(e.currentTarget); // $button1 console.log(this === e.currentTarget); // false // this는 window를 가리키므로 window.textContent에 NaN을 할당한다. ++this.textContent; }; $button2.addEventListener(&#39;click&#39;, e =&amp;gt; { console.log(this); // window console.log(e.currentTarget); // $button2 console.log(this === e.currentTarget); // false ++this.textContent; }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;클래스에서 이벤트 핸들러를 바인딩하는 경우 this에 주의해야 한다. 클래스 메서드 내부의 this는 클래스가 생성할 인스턴스를 가리키지 않는다. 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리키기 때문에 클래스 메서드 내부의 this는 이벤트 핸들러가 바인딩된 요소를 가리킨다. 따라서 클래스 메서드를 이벤트 핸들러로 바인딩할 때 bind 메서드를 사용해서 this를 전달하여 클래스 메서드 내부의 this가 클래스가 생성할 인스턴스를 가리키도록 해야 한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button class=&quot;btn&quot;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; class App { constructor() { this.$button = document.querySelector(&#39;.btn&#39;); this.count = 0; this.$button.onclick = this.increase.bind(this); } increase() { this.$button.textContent = ++this.count; } } new App(); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트 핸들러에 인수 전달이벤트 어트리뷰트 방식은 함수 호출문을 사용할 수 있기 때문에 인수를 전달할 수 있지만 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식의 경우 함수 호출문이 아닌 함수 자체를 등록해야 한다. 따라서 인수를 전달할 수 없다. 이 경우 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;label&amp;gt;User name &amp;lt;input type=&#39;text&#39;&amp;gt;&amp;lt;/label&amp;gt; &amp;lt;em class=&#39;message&#39;&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;script&amp;gt; const MIN_USER_NAME_LENGTH = 5; const $input = document.querySelector(&#39;input[type=text]&#39;); const $msg = document.querySelector(&#39;.message&#39;); const checkUserNameLength = min =&amp;gt; { $msg.textContent = $input.value.length &amp;lt; min ? `이름은 ${min}자 이상 입력해 주세요` : &#39;&#39;; }; $input.onblur = () =&amp;gt; { checkUserNameLength(MIN_USER_NAME_LENGTH); }; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;또는 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수 있다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;label&amp;gt;User name &amp;lt;input type=&#39;text&#39;&amp;gt;&amp;lt;/label&amp;gt; &amp;lt;em class=&#39;message&#39;&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;script&amp;gt; const MIN_USER_NAME_LENGTH = 5; const $input = document.querySelector(&#39;input[type=text]&#39;); const $msg = document.querySelector(&#39;.message&#39;); // 이벤트 핸들러를 반환하는 함수 const checkUserNameLength = min =&amp;gt; e =&amp;gt; { $msg.textContent = $input.value.length &amp;lt; min ? `이름은 ${min}자 이상 입력해 주세요` : &#39;&#39;; }; // 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달 $input.onblur = checkUserNameLength(MIN_USER_NAME_LENGTH); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;" }, { "title": "Javascript Event_01", "url": "/posts/event-01/", "categories": "Javascript", "tags": "javascript", "date": "2022-08-08 00:00:00 +0900", "snippet": "이벤트 드리븐 프로그래밍애플리케이션이 특정 타입의 이벤트에 대한 반응하여 어떤 일을 하고 싶다면 해당하는 타입의 이벤트가 발생했을 때 호출될 함수를 브라우저에게 알려 호출을 위임한다. 이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러(event handler)라고, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button&amp;gt;Btn1&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button = document.querySelector(&#39;button&#39;); $button.onclick = () =&amp;gt; { alert(&#39;button click&#39;); }; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트와 그에 대응하는 이벤트 핸들러를 통해 사용자와 애플리케이션은 상호작용을 할 수 있다. 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리브 프로그래밍이라 한다.이벤트 타입마우스 이벤트 이벤트 타입 이벤트 발생 시점 click 마우스 버튼을 클릭했을 때 dbclick 마우스 버튼을 더블 클릭했을 때 mousedown 마우스 버튼을 눌렀을 때 mouseup 누르고 있던 마우스 버튼을 놓았을 때 mousemove 마우스 커서를 움직였을 때 mouseenter 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 되지 않는다) mouseover 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 된다) mouseleave 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 된다) mouseover 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링 된다) 키보드 이벤트 이벤트 타입 이벤트 발생 시점 keydown 모든 키를 눌렀을 때 발생(문자, 숫자, 특수문자, enter 키 눌렀을 때 연속적으로 발생하지만 그 외의 키는 눌렀을 때는 한 번만 발생) keypress 문자 키를 눌렀을 때 연속적으로 발생(deprecated 되었으므로 사용하지 않은 것을 권장) keyup 누르고 있던 키를 놓았을 때 한 번만 발생 포커스 이벤트 이벤트 타입 이벤트 발생 시점 focus HTML 요소가 포커스 받았을 때(버블링되지 않는다) blur HTML 요소가 포커스 잃었을 때(버블링되지 않는다) focusin HTML 요소가 포커스 받았을 때(버블링된다) focusout HTML 요소가 포커스 잃었을 때(버블링된다) 폼 이벤트 이벤트 타입 이벤트 발생 시점 submit form 요소 내의 input, select 입력 필드(textarea 제외)에서 엔터키 눌렀을 때 또는, form 요소 내의 submit 버튼 클릭했을 때(submit 이벤트는 form 요소에서 발생한다) reset form 요소 내의 reset 버튼을 클릭했을 때(최근에는 사용 안 함) 값 변경 이벤트 이벤트 타입 이벤트 발생 시점 input input(text, checkbox, radio), select, textarea 요소의 값이 입력되었을 때 change input(text, checkbox, radio), select, textarea 요소의 값이 변경되었을 때(사용자가 입력을 하고 있을 때는 input 이벤트가 발생하고 사용자 입력이 종료되어 값이 변경되어 change 이벤트가 발생한다) readystatechange HTML 문서의 로드와 파싱 상태를 나타내는 document.readyState 프로퍼티 값(‘loading, interactive’, ‘complete’)이 변경될 때 DOM 뮤테이션 이벤트 이벤트 타입 이벤트 발생 시점 DOMContentLoaded HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 때 뷰 이벤트 이벤트 타입 이벤트 발생 시점 resize 브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생(오직 window 객체에서만 발생한다) scroll 웹페이지 또는 HTML 요소를 스크롤할 때 연속적으로 발생 리소스 이벤트 이벤트 타입 이벤트 발생시점 load DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스의 로딩이 완료되었을 때 unload 리소스가 언로드 될 때 abort 리소스 로딩이 중단되었을 때 error 리소스 로딩이 실패했을 때 이벤트 핸들러 등록이벤트 핸들러를 등록하는 방법은 3가지다.이벤트 핸들러 어트리뷰트 방식이벤트 핸들러 어트리뷰트의 이름은 onclick과 같이 on 접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이루어져 있다. 이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등의 문(statement)을 할당하면 이벤트 핸들러가 등록된다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button onclick=&quot;print(&#39;hello world&#39;)&quot;&amp;gt;Btn1&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function print(content) { console.log(content); } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;주의할 점은 이벤트 핸들러 어트리뷰트 값으로 함수 참조가 아닌 함수 호출문 등의 문을 할당한다는 것이다.이벤트 핸들러를 등록할 때 콜백 함수와 마찬가지로 함수 참조를 등록해야 브라우저가 이벤트 핸들러를 호출할 수 있다. 만약 함수 참조가 아니라 함수 호출문을 등록하면 함수 호출문의 평가 결과가 이벤트 핸들러로 등록된다. 함수가 아닌 값을 반환하는 함수 호출문을 이벤트 핸들러로 등록하면 브라우저가 이벤트 핸들러를 호출할 수 없다.위 예제에서는 이벤트 핸들러 어트리뷰트 값으로 함수 호출문을 할당했다. 이때 이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다.이벤트 핸들러 어트리뷰트 값으로 다음과 같이 여러 개의 문을 할당할 수 있다. &amp;lt;button onclick=&quot;console.log(&#39;hello world&#39;); console.log(&#39;HTML&#39;);&quot;&amp;gt;Btn1&amp;lt;/button&amp;gt;이 방법은 예전에 많이 사용했던 방법으로 알아둘 필요는 있지만 더는 사용하지 않는 것이 좋다. 하지만 CBD(Component Based Development)방식의 Angular/React/Svelte/Vue.js 같은 프레임워크/라이브러리에서는 이벤트 핸들러 어트리뷰트 방식으로 이벤트를 처리한다. &amp;lt;!-- Angular --&amp;gt; &amp;lt;button (click)=&quot;handleClick($event)&quot;&amp;gt;Svae&amp;lt;/button&amp;gt; &amp;lt;!-- React --&amp;gt; &amp;lt;button onClick={hnadleClick}&amp;gt;Save&amp;lt;/button&amp;gt; &amp;lt;!-- Svelte --&amp;gt; &amp;lt;button on:click={handleClick}&amp;gt;Save&amp;lt;/button&amp;gt; &amp;lt;!-- Vue.js --&amp;gt; &amp;lt;button v-on:click=&quot;handleClick($event)&quot;&amp;gt;Save&amp;lt;/button&amp;gt;이벤트 핸들러 프로퍼티 방식window 객체와 Document, HTMLElement 타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다. 이벤트 핸들러 프로퍼티의 키는 이벤트 핸들러 어트리뷰트와 마찬가지로 onclick과 같이 on 접두사와 이벤트 종류를 나타내는 이벤트 타입으로 이루어져 있다. 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록된다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button&amp;gt;Btn1&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button = document.querySelector(&#39;button&#39;); $button.onclick = function() { console.log(&#39;button click&#39;); }; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트 핸들러를 등록하기 위해서는 이벤트를 발생시킬 객체인 이벤트 타깃과 이벤트의 종류를 나타내는 문자열인 이벤트 타입 그리고 이벤트 핸들러를 지정해야 한다.이벤트 핸들러는 대부분 이벤트를 발생시킬 이벤트 타깃에 바인딩한다. 하지만 반드시 이벤트 타깃에 이벤트 핸들러를 바인딩해야 하는 것은 아니다. 이벤트 핸들러 프로퍼티 방식은 이벤트 핸들러 어트리뷰트 방식과 결과적으로 동일하다. 하지만 이벤트 핸들러 프로퍼티 방식을 사용하면 HTML과 자바스크립트가 뒤섞이는 문제를 해결할 수 있다. 단 이벤트 핸들러 프로퍼티 방식은 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있다.addEventListener 메서드 방식DOM Level 2에서 도입된 EventTarget.prototype.addEventListener 메서드를 사용하여 이벤트 핸들러를 등록할 수 있다.첫 번째 매개변수에는 이벤트 종류를 나타내는 문자열인 이벤트 타입을 전달한다. 이 때 이벤트 핸들러 프로퍼티 방식과는 달리 on 접두사를 붙이지 않는다. 두 번째 매개변수에는 이벤트 핸들러를 전달한다. 마지막 매개변수는 이벤트를 캐치할 이벤트 전파 단계를 지정한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button&amp;gt;Btn1&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button = document.querySelector(&#39;button&#39;); $button.addEventListener(&#39;click&#39;, function() { console.log(&#39;button click&#39;); }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트 핸들러 프로퍼티 방식은 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩하지만 addEventListener 메서드에는 이벤트 핸들러를 인수로 전달한다.동일한 HTML 요소에서 발생한 동일한 이벤트에 대해 이벤트 핸들러 프로퍼티 방식은 하나 이상의 이벤트 핸들러를 등록할 수 없지만 addEventListener 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다. 이때 이벤트 핸들러는 등록된 순서대로 호출된다.단, addEventListener 메서드를 통해 참조가 동일한 이벤트 핸들러를 중복 등록하면 하나의 이벤트 핸들러만 등록된다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button&amp;gt;Btn1&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button = document.querySelector(&#39;button&#39;); const handleClick = () =&amp;gt; console.log(&#39;button click&#39;); // 참조가 동일할 경우 하나의 핸들러만 등록 $button.addEventListener(&#39;click&#39;, handleClick); $button.addEventListener(&#39;click&#39;, handleClick); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;이벤트 핸들러 제거addEventListener 메서드로 등록한 이벤트 핸들러를 제거하려면 EventTarget.prototype.removeEventListener 메서드를 이용한다. removeEventListener 메서드에 전달할 인수는 addEventListener 메서드와 동일하다. 단, addEventListener 메서드와 인수가 동일하지 않으면 이벤트 핸들러가 제거되지 않는다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button&amp;gt;Btn1&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button = document.querySelector(&#39;button&#39;); const handleClick = () =&amp;gt; console.log(&#39;button click&#39;); $button.addEventListener(&#39;click&#39;, handleClick); $button.removeEventListener(&#39;click&#39;, handleClick, true); // false $button.removeEventListener(&#39;click&#39;, handleClick); // success &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;removeEventListener 메서드는 addEventListener 메서드와 전달 인수가 동일해야 하며, 따라서 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다. 단, 기명 이벤트 핸들러 내부에서 removeEventListener 메서드를 호출하여 이벤트 핸들러를 제거하는 것은 가능하다. 이 경우 이벤트 핸들러는 단 한번만 호출된다. $button.addEventListener(&#39;click&#39;, function foo() { console.log(&#39;hello world&#39;); $button.removeEventListener(&#39;click&#39;, foo); });이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 removeEventListener 메서드로 제거할 수 없다. 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러를 제거하려면 이벤트 핸들러 프로퍼티에 null을 할당한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;button&amp;gt;Btn1&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; const $button = document.querySelector(&#39;button&#39;); const handleClick = () =&amp;gt; console.log(&#39;button click&#39;); $button.onclick = handleClick; $button.onclick = null; // 이벤트 핸들러 프로퍼티에 null을 할당하여 이벤트 핸들러를 제거 &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;" }, { "title": "Javascript DOM_04", "url": "/posts/DOM_04/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-29 00:00:00 +0900", "snippet": "어트리뷰트HTML 요소의 동작을 제어하기 위한 추가적인 정보를 제공하는 HTML 어트리뷰트는 HTML 요소의 시작 태그에 어트리뷰트 이름=”어트리뷰트 값” 형식으로 정의한다.HTML 문서가 파싱될 때 HTML 요소의 어트리뷰트는 어트리뷰트 노드로 변환되어 요소 노드와 연결된다. 모든 어트리뷰트 노드의 참조는 유사 배열 객체이자 이터러블인 NamedNodeMap 객체에 담겨서 요소의 attributs 프로퍼티에 저장된다. 요소 노드의 모든 어트리뷰트 노드는 요소 노드의 Element.prototype.attributes 프로퍼티로 취득이 가능하고, attributes 프로퍼티는 getter만 존재하는 읽기 전용 프로퍼티이다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input id=&quot;user&quot; type=&quot;text&quot; value=&quot;test&quot;&amp;gt; &amp;lt;script&amp;gt; // NamedNodeMap 객체를 반환한다. const { attributes } = document.getElementById(&#39;user&#39;); console.log(attributes); // NamedNodeMap {0: id, 1: type, 2: value, id: id, type: type, value: value, length: 3} console.log(attributes.id.value); // user console.log(attributes.type.value); // text console.log(attributes.value.value);// test &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; HTML 어트리뷰트 조작attributes 프로퍼티는 읽기 전용 프로퍼티기 때문에 어트리뷰트를 변경할 수 없다. Element.prototype.getAttribute/setAttribute 메서드를 사용하면 요소 노드에서 메서드를 통해 직접 HTML 어트리뷰트 값을 취득하거나 변경할 수 있다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input id=&quot;user&quot; type=&quot;text&quot; value=&quot;test&quot;&amp;gt; &amp;lt;script&amp;gt; const $input = document.getElementById(&#39;user&#39;); const inputValue = $input.getAttribute(&#39;value&#39;); console.log(inputValue); // test $input.setAttribute(&#39;value&#39;, &#39;foo&#39;); console.log($input.getAttribute(&#39;value&#39;)); // foo // value 어트리뷰트 존재 확인 if($input.hasAttribute(&#39;value&#39;)) { // value 어트리뷰트 삭제 $input.removeAttribute(&#39;value&#39;); } console.log($input.hasAttribute(&#39;value&#39;)); // false &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;HTML 어트리뷰트 vs DOM 프로퍼티요소 노드 객체에는 HTML 어트리뷰트에 대응하는 DOM 프로퍼티가 존재한다. DOM 프로퍼티들은 HTML 어트리뷰트 값을 초기값으로 가지고 있다. DOM 프로퍼티는 getter와 setter 모두 존재하는 프로퍼티다. 따라서 DOM 프로퍼티는 참조와 변경이 가능하다.HTML 개발자도구에서 HTML 어트리뷰트와 DOM 프로퍼티를 확인하면 중복으로 관리되는 것 처럼 보인다. 하지만 사실 그렇지 않다. HTML 어트리뷰트의 역할은 HTML 요소의 초기 상태를 지정하는 것이다. 즉, HTML 어트리뷰트 값은 HTML 요소의 초기 상태를 의미하며 이는 변하지 않는다.요소 노드는 상태(state)를 가지고 있다. 따라서 사용자에 의해 요소 노드의 상태는 변할 수 있다. 사용자에 의해 상태가 변한 경우 초기 상태 값을 관리하지 않으면 웹페이지를 처음 표시하거나 새로고침할 때 초기 상태를 표시할 수 없다.즉, 요소 노드는 초기 상태과 최신 상태로 2개의 상태를 관리해야 한다. 요소 노드의 초기 상태는 어트리뷰트 노드가 관리하며, 요소 노드의 최신 상태는 DOM 프로퍼티가 관리한다. 어트리뷰트 노드 : HTML 어트리뷰트로 지정한 HTML 요소의 초기 상태는 어트리뷰트 노드에서 관리한다. 사용자의 입력값이 들어와도 요소의 초기 상태를 그대로 유지한다. DOM 프로퍼티 : 사용자가 입력한 최신 상태는 HTML 어트리뷰트에 대응하는 요소 노드의 DOM 프로퍼티가 관리한다. DOM 프로퍼티는 사용자의 입력에 의한 상태 변화에 반응하여 언제나 최신 상태를 유지한다. data 어트리뷰트와 dataset 프로퍼티data 어트리뷰트와 dataset 프로퍼티를 사용하면 HTML 요소에 정의한 사용자 정의 어트리뷰트와 자바스크립트 간에 데이터를 교환할 수 있다. data 어트리뷰트는 data-user-id, data-role과 같이 data- 접두사 다음에 임의의 이름을 붙여 사용한다.data 어트리뷰트의 값은 HTMLElement.dataset 프로퍼티로 취득할 수 있다. dataset 프로퍼티는 HTML 요소의 모든 data 어트리뷰트의 정보를 제공하는 DOMStringMap 객체를 반환한다. DOMStringMap 객체는 data 어트리뷰트의 data- 접두사 다음에 붙인 임의의 이름을 카멜 케이스로 변환한 프로퍼티를 가지고 있다.data 어트리뷰트의 data- 접두사 다음에 존재하지 않는 이름을 키로 사용하여 dataset 프로퍼티에 값을 할당하면 HTML 요소에 data 어트리뷰트가 추가된다. dataset 프로퍼티에 추가한 카멜케이스 프로퍼티 키는 data 어트리뷰트의 data- 접두사 다음에 케밥케이스로 자동 변경되어 추가된다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul class=&quot;users&quot;&amp;gt; &amp;lt;li id=&quot;1&quot; data-user-id=&quot;1111&quot;&amp;gt;A&amp;lt;/li&amp;gt; &amp;lt;li is=&quot;2&quot; data-user-id=&quot;2222&quot;&amp;gt;B&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; const users = [...document.querySelector(&#39;.users&#39;).children]; const user = users.find(user =&amp;gt; user.dataset.userId === &quot;1111&quot;); user.dataset.role = &#39;admin&#39;; console.log(user.dataset); /* DOMStringMap {userId: &quot;1111&quot;, role: &quot;admin&quot;} &amp;gt;&amp;gt; &amp;lt;li id=&quot;1&quot; data-user-id=&quot;1111&quot; data-role=&quot;admin&quot;&amp;gt;A&amp;lt;/li&amp;gt; */ &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;스타일인라인 스타일 조작HTMLElement.prototype.style 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 인라인 스타일을 취득하거나 추가 또는 변경한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div style=&quot;color: red&quot;&amp;gt;Hello World&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const $div = document.querySelector(&#39;div&#39;); console.log($div.style); // CSSStyleDeclaration { 0: &quot;color&quot;, ...} $div.style.color = &#39;blue&#39;; $div.style.width = &#39;100px&#39;; $div.style.height = &#39;100px&#39;; $div.style.backgroundColor = &#39;yellow&#39;; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;style 프로퍼티를 참조하면 CSSStyleDeclaration 타입의 객체를 반환한다. 이 객체는 다양한 CSS 프로퍼에 대응하는 프로퍼티를 가지고 있으며, 이 프로퍼티에 값을 할당하면 인라인 스타일로 HTML 요소에 추가되거나 변경된다. CSS 프로퍼티는 케밥 케이스를 따른다. 이에 대응하는 CSSStyleDeclaration 객체의 프로퍼티는 카멜 케이스를 따른다.클래스 조작class 어트리뷰트에 대응하는 DOM 프로퍼티는 class가 아니라 className과 classList다. 자바스크립트에서 class는 예약어이기 때문이다.Element.prototype.className 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 HTML 요소의 class 어트리뷰트 값을 취득하거나 변경한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .box { width: 100px; height: 100px; background-color: gray; } .red { color: red; } .blue { color: blue; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;box red&quot;&amp;gt;Hello World&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const $box = document.querySelector(&#39;.box&#39;); console.log($box.className); // &#39;box red&#39; $box.className = $box.className.replace(&#39;red&#39;, &#39;blue&#39;); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;className 프로퍼티의 경우 문자열을 반환하므로 공백으로 구분된 여러 개의 클래스를 반환하는 경우 다루기가 불편하다.Element.prototype.classList 프로퍼티는 class 어트리뷰트의 정보를 담은 DOMTokenList 객체를 반환한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .box { width: 100px; height: 100px; background-color: gray; } .red { color: red; } .blue { color: blue; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;box red&quot;&amp;gt;Hello world&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const $box = document.querySelector(&#39;.box&#39;); console.log($box.classList); // DOMTokenList(2) [length: 2, value: &quot;box red&quot;, 0: &quot;box&quot;, 1: &quot;red&quot; ] $box.classList.replace(&#39;red&#39;, &#39;blue&#39;); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;DOMTokenList 객체는 class 어트리뷰트의 정보를 나타내는 컬렉션 객체로서 유사 배열 객체이면서 이터러블이다. DOMTokenList 객체는 다움과 같은 메서드를 제공한다.- add(…className) : 인수로 전달한 1개 이상 문자열을 class 어트리뷰트 값으로 추가한다.- remove(…className) : 인수로 전달된 1개 이상 문자열과 일치하는 클래스를 class 어트리뷰트에서 삭제한다. 일치하는 클래스가 없을 경우 에러 없이 무시된다.- item(index) : 인수로 전달한 index에 해당하는 클래스를 class 어트리뷰트에서 반환한다.- contains(className) : 인수로 전달한 문자열과 일치하는 클래스가 class 어트리뷰트에 포함되어 있는지 확인한다.- replace(oldClassName, newClassName) : 첫 번째로 전달한 문자열을 두 번째 인수로 전달한 문자열로 변경하여 클래스를 적용한다.- toggle(className[, force]) : class 어트리뷰트에서 첫 번째 인수로 전달한 문자열과 일치하는 클래스가 존재하면 제거하고, 존재하지 않으면 추가한다. 두 번째 인수로 불리언 값으로 평가되는 조건식을 전달할 수 있으며, true일 경우 강제로 첫 번째 인수로 전달받은 문자열을 추가하고, false일 경우 강제로 첫 번째 인수로 전달받은 문자열을 제거한다." }, { "title": "Javascript DOM_03", "url": "/posts/DOM-03/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-28 00:00:00 +0900", "snippet": "DOM 조작DOM 조작은 새로운 노드를 추가하거나 기존 노드를 삭제 또는 교체하는 것을 말한다. DOM이 변하면 리플로우나 리페인트가 발생하므로 성능에 영향을 준다. 따라서 DOM을 조작할 때는 성능 최적화를 고려해야 한다.innerHTMLElement.prototype.innerHTML 프로퍼티는 setter와 getter 모두 존재하는 프로퍼티로서 요소 노드의 HTML 마크없을 취득하거나 변경한다. 이때 요소 노드 내 포함된 HTML 마크업은 문자열로 반환한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;foo&quot;&amp;gt;Hello &amp;lt;span&amp;gt;world!&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; console.log(document.getElementById(&#39;foo&#39;).innerHTML); // &quot;Hello &amp;lt;span&amp;gt;world!&amp;lt;/span&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;textContent 프로퍼티는 HTML 마크업을 무시하고 텍스트만 반환하지만 innerHTML 프로퍼티는 HTML 마크업을 포함한 문자열을 반환한다. innerHTML의 경우 문자열을 할당할 경우 요소 노드의 모든 자식 노드는 제거되고 할당한 문자열에 포함된 HTML 마크업을 파싱하여 요소 노드의 자식 노드로 DOM에 반영한다.innerHTML은 사용자의 입력 데이터에서 HTML 마크업을 파싱하므로 크로스 사이트 스크링팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. HTML 마크업 내 악성 코드가 포함되어 있다면 실행될 가능성이 있기 때문이다.기본적으로 HTML5는 innerHTML 프로퍼티에 삽입된 script 코드를 실행하지 않는다. 하지만 script 요소 없이도 크로스 사이트 스크립팅 공격은 가능하므로 innerHTML 사용은 안하는 것이 좋다.innerHTML의 또 다른 단점은 innerHTML 프로퍼티에 HTML 마크업 문자열을 할당할 경우 요소 노드의 모든 자식 노드를 제거하고 할당한 HTML 마크업을 파싱한다는 점이다. 이는 제거되지 않아야 할 자식 노드를 삭제하게 되고, 필요할 경우 기존 자식들을 innerHTML에 다시 할당해야 한다.또 새로운 요소를 삽일할 때 삽입될 위치를 지정할 수 없다는 단점도 있다.따라서 innerHTML 프로퍼티는 복잡하지 않은 요소를 새롭게 추가할 때 유용하지만 기존 요소를 제거, 또는 새로운 요소를 추가할 때는 사용하지 않는 것이 좋다.insertAdjacentHTMLElement.prototype.insertAdjacentHTML 메서드는 기존 요소를 제거하지 않고 위치를 지정해서 새로운 요소를 삽입한다. 첫 번째 인수로 위치를 전달하고 두 번째 인수로 HTML 마크업 문자열을 전달한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- beforebegin --&amp;gt; &amp;lt;div id=&quot;foo&quot;&amp;gt; &amp;lt;!-- afterbegin --&amp;gt; text &amp;lt;!-- beforeend --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- afterend --&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $foo = document.getElementById(&#39;foo&#39;); $foo.insertAdjacentHTML(&#39;beforebegin&#39;, &#39;&amp;lt;p&amp;gt;beforebegin&amp;lt;/p&amp;gt;&#39;); $foo.insertAdjacentHTML(&#39;afterbegin&#39;, &#39;&amp;lt;p&amp;gt;beforebegin&amp;lt;/p&amp;gt;&#39;); $foo.insertAdjacentHTML(&#39;beforeend&#39;, &#39;&amp;lt;p&amp;gt;beforebegin&amp;lt;/p&amp;gt;&#39;); $foo.insertAdjacentHTML(&#39;afterend&#39;, &#39;&amp;lt;p&amp;gt;beforebegin&amp;lt;/p&amp;gt;&#39;); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;단, innerHTML 프로퍼티와 마찬가지로 insertAdjacentHTML 메서드는 HTML 마크업 문자열을 파싱하므로 크로스 사이트 스크립팅 공격에 취약하다.노드 생성과 추가DOM은 노드를 직접 생성/삽입/삭제/치환하는 메서드를 제공한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul id=&quot;fruits&quot;&amp;gt; &amp;lt;li&amp;gt;Apple&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $fruits = document.getElementById(&#39;fruits&#39;); // 1. 요소 노드 생성 const $li = document.createElement(&#39;li&#39;); // 2. 텍스트 노드 생성 const $textNode = document.createTextNode(&#39;Banana&#39;); // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가 $li.appendChild(textNode); // 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가 $fruits.appendChild($li); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;복수의 노드 생성과 추가 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul id=&quot;fruits&quot;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $fruits = document.getElementById(&#39;fruits&#39;); [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Orange&#39;].forEach(text =&amp;gt; { // 1. 요소 노드 생성 const $li = document.createElement(&#39;li&#39;); // 2. 텍스트 노드 생성 const textNode = document.createTextNode(text); // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가 $li.appendChild(textNode); // 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가 $fruits.appendChild($li); }); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;위 코드처럼 순회를 이용해서 복수의 노드를 생성하고 추가하는 방법이 있다. 하지만 이 코드는 문제가 있다. 3개의 요소를 생성하고 3개의 요소를 DOM에 추가하면서 리플로우와 리페인트가 3번 발생한다. 따라서 위 코드는 비효율적이다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul id=&quot;fruits&quot;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $fruits = document.getElementById(&#39;fruits&#39;); // 컨테이너 요소 노드 생성 const $container = document.createElement(&#39;div&#39;); [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Orange&#39;].forEach(text =&amp;gt; { // 1. 요소 노드 생성 const $li = document.createElement(&#39;li&#39;); // 2. 텍스트 노드 생성 const textNode = document.createTextNode(text); // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가 $li.appendChild(textNode); // 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가 $container.appendChild($li); }); // 5. 컨테이너 요소 노드를 #fruits 요소 노드 마지막에 추가 $fruits.appendChild($container); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;위 코드의 경우 DOM의 변화가 한 번만 일어나므로 성능에 유리하다. 하지만 컨테이너 요소가 불필요하게 추가되는 부작용이 있다. 이러한 문제는 DocumentFragment 노드를 통해 해결할 수 있다.DocumentFragment 노드는 문서, 요소, 어트리뷰트, 텍스트 노드와 같은 노드 객체의 일종으로, 부모 노드가 없어서 기존 DOM과 별도로 존재한다. DocumentFragment 노드는 위 코드의 컨테이너 노드와 같이 자식 노드들의 부모 노드로서 별도의 서브 DOM을 구성하여 기존 DOM에 추가하기 위한 용도로 사용한다.DocumentFragment 노드는 DOM에 추가하면 자신은 제거되고 자식 노드만 DOM에 추가된다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul id=&quot;fruits&quot;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $fruits = document.getElementById(&#39;fruits&#39;); // DocumentFragment 노드 생성... // Document.prototype.createDocumentFragment 메서드는 비어있는 DocumentFragment 노드를 생성 후 반환 const $fragment = document.createDocumentFragment(); [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Orange&#39;].forEach(text =&amp;gt; { // 1. 요소 노드 생성 const $li = document.createElement(&#39;li&#39;); // 2. 텍스트 노드 생성 const textNode = document.createTextNode(text); // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가 $li.appendChild(textNode); // 4. $li 요소 노드를 DocumentFragment 노드의 마지막 자식 노드로 추가 $fragment.appendChild($li); }); // 5. DocumentFragment 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가 $fruits.appendChild($fragment); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;여러 개의 요소 노드를 DOM에 추가하는 경우 DocumentFragment 노드를 사용하는 것이 효율적이다." }, { "title": "Javascript DOM_02", "url": "/posts/DOM-02/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-27 00:00:00 +0900", "snippet": "노드 탐색요소 노드를 취득한 다음, 취득한 요소 노드를 기점으로 부모, 형제, 자식 노드 등을 탐색할 수 있다. Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공한다.노드 탐색 프로퍼티는 모두 접근자 프로퍼티다. 단, 노드 탐색 프로퍼티는 setter없이 getter만 존재하여 읽기 전용 프로퍼티다.자식 노드 탐색 프로퍼티 설명 Node.prototype.childNodes 자식 노드를 모두 탐색하여 NodeList에 담아 반환한다. childNodes 프로퍼티가 반환된 NodeList에는 요소 노드뿐만 아니라 텍스트 노드도 포함되어 있을 수 있다. Element.prototype.children 자식 노드 중에서 요소 노드만 모두 탐색하여 HTMLCollection에 담아 반환한다. children 프로퍼티가 반환한 HTMLCollection에는 텍스트 노드가 포함되지 않는다. Node.prototype.firstChild 첫 번째 자식 노드를 반환한다. firstChild 프로퍼티가 반환하는 노드는 텍스트 노드이거나 요소 노드이다. Node.prototype.lastChild 마지막 자식 노드를 반환한다. lastChild 프로퍼티가 반환한 노드는 텍스트 노드이거나 요소 노드다. Element.prototype.firstElementChild 첫 번째 자식 노드를 반환한다. firstElementChild 프로퍼티는 요소 노드만 반환한다. Element.prototype.lastElementChild 마지막 자식 요소 노드를 반환한다. lastElementChild 프로퍼티는 요소 노드만 반환한다. 부모 노드 탐색부모 노드를 탐색하려면 Node.prototype.parentNode 프로퍼티를 사용한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul id=&quot;fruits&quot;&amp;gt; &amp;lt;li class=&quot;apple&quot;&amp;gt;Apple&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;banana&quot;&amp;gt;Banana&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;orange&quot;&amp;gt;Orange&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $banana = document.querySelector(&#39;.banana&#39;); console.log($banana.parentNode); // ul#fruits &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;형제 노드 탐색형제 노드 탐색 시 어트리뷰트 노드는 요소 노드와 연결되어 있지만 부모 노드가 같은 형제 노드가 아니기 때문에 반환되지 않는다. 즉, 아래 프로퍼티는 텍스트 노드 또는 요소 노드만 반환한다. 프로퍼티 설명 Node.prototype.previousSibling 부모 노드가 같은 형제 노드 중에서 자신이 이전 형제 노드를 탐색하여 반환한다. 요소 노드뿐만 아니라 텍스트 노드도 반환이 가능하다. Node.prototype.nextSibling 부모 노드가 같은 형제 노드 중에서 자신의 다음 형제 노드를 탐색하여 반환한다. 요소 노드뿐만 아니라 텍스트 노드도 반환이 가능하다. Element.prototype.previousElementSibling 부모 노드가 같은 형제 요소 노드 중에서 자신의 이전 형제 요소 노드를 탐색하여 반환한다. previousElementSibling 프로퍼티는 요소 노드만 반환한다. Element.prototype.nextElementSibling 부모 노드가 같은 형제 요소 노드 중에서 자신의 다음 형제 요소 노드를 탐색하여 반환한다. nextElementSibling 프로퍼티는 요소 노드만 반환한다. 요소 노드의 텍스트 조작nodeValueNode.prototype.nodeValue 프로퍼티는 setter와 getter가 모두 존재하는 프로퍼디다. 노드 객체의 nodeValue 프로퍼티를 참조하면 노드 객체의 값을 반환한다. 노드 객체의 값이란 텍스트 노드의 텍스트를 말한다. 따라서 문서 노드나 요소 노드의 nodeValue 프로퍼티를 참조하면 null을 반환한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;foo&quot;&amp;gt;Hello&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; console.log(document.nodeValue); // null const $foo = document.getElementById(&#39;foo&#39;); console.log($foo.nodeValue); // null const $textNode = $foo.firstChild; console.log($textNode.nodeValue); // Hello &amp;lt;/script&amp;gt;nodeValue 프로퍼티에 값을 할당하면 텍스트 노드의 값, 즉 텍스트를 변경할 수 있다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;foo&quot;&amp;gt;Hello&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $textNode = document.getElementById(&#39;foo&#39;).firstChild; // textNode 취득 $textNode.nodeValue = &#39;World&#39;; console.log($textNode.nodeValue); // World &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;textContentNode.prototype.textContent 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경한다. 요소 노드의 textContent 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역 내의 모든 텍스트를 모두 반환한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;foo&quot;&amp;gt;Hello &amp;lt;span&amp;gt;world!&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; console.log(document.getElementById(&#39;foo&#39;).textContent); // Hello world! &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;textContent 프로퍼티 참조 시 #foo 내부의 텍스트 노드인 ‘Hello’와 하위 노드인 span 내부의 ‘world!’ 모두 반환된 모습이다. 요소 노드의 textContent 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 이때 할당한 문자열에 HTML 마크업이 포함되어도 문자열 그대로 인식되어 텍스트로 취급된다.textContent 프로퍼티와 유사한 동작을 하는 프로퍼티로 innerText 프로퍼티가 있다. 하지만 innerText 프로퍼티는 아래와 같은 이유로 사용하지 않는 것이 좋다. innerText 프로퍼티는 CSS에 순종적이다. innerText 프로퍼티는 CSS에서 비표시(hidden 처리)로 지정된 요소 노드의 텍스트를 반환하지 않는다. innerText 프로퍼티는 CSS를 고려해야 하므로 textContent 프로퍼티보다 속도가 느리다. " }, { "title": "Javascript DOM_01", "url": "/posts/DOM-01/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-22 00:00:00 +0900", "snippet": "DOM(Document Object Model)은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조다.노드HTML 요소는 HTML문서를 구성하는 개별적인 요소를 말한다. HTML 요소는 렌더링 엔진에 의해 파싱 후 DOM을 구성하는 요소 노드 객체로 변환된다.HTML 요소 간에는 중첩 관계에 의해 계층적인 부모-자식 관계가 형성되고, 이 관계를 반영하여 노드 객체를 트리 자료구조로 구성한다. 이 노드 객체들로 구성된 트리 자료구조를 DOM(Document Object Model)이라 하고, DOM 트리라고 부르기도 한다.다음 코드를 DOM으로 나타내면 그림과 같다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li id=&quot;apple&quot;&amp;gt;Apple&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;banana&quot;&amp;gt;Banana&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;orange&quot;&amp;gt;Orange&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script src=&quot;app.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;DOM은 노드 객체의 계층적 구조로 구성된다. 노드 객체는 총 12개의 타입이 있으며, 이 중 중요한 노드 타입은 다음 4가지다. 문서 노드(document node): DOM 트리 최상위에 존재하는 루트 노드로서 document 객체를 가리킨다. HTML 문서당 document 객체는 유일하다. 또한 document 객체는 DOM 트리의 루트 노드로 DOM 트리 노드들에 접근하기 위한 진입점이다. 요소 노드(element node): 요소 노드는 HTML 요소를 가리키는 객체다. 요소 노드는 HTML 요소 간의 중첩에 의해 부자 관계를 가지며, 이 부자 관계를 통해 정보를 구조화한다. 따라서 요소 노드는 문서의 구조를 표현한다고 할 수 있다. 어트리뷰트 노드(attribute node): HTML 요소의 어트리뷰트를 가리키는 객체다. 어트리뷰트 노드는 어트리뷰트가 지정된 HTML 요소의 요소 노드와 연결되어 있다. 어트리뷰트 노드에 접근하여 어트리뷰트를 참조하거나 변경하려면 먼저 요소 노드에 접근해야 한다. 텍스트 노드(text node): 텍스트 노드는 HTML 요소의 텍스트를 가리키는 객체다. 텍스트 노드는 요소 노드의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드다. 텍스트 노드는 DOM 트리의 최종단이다. DOM을 구성하는 노드 객체는 자신의 구조와 정보를 제어할 수 있는 DOM API를 사용할 수 있다. 이 API를 통해서 노드 객체는 자신의 부모, 형제, 자식을 탐색할 수 있으며, 자신의 어트리뷰트와 텍스트를 조작할 수 있다.요소 노드 취득id를 이용한 요소 노드 취득Document.prototype.getElementById 메서드는 인수로 전달한 id 어트리뷰트 값을 갖는 하난의 요소 노드를 탐색하여 반환한다. getElementById 메서드는 Document.prototype의 프로퍼티로 반드시 문서 노드인 document를 통해 호출한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li id=&quot;apple&quot;&amp;gt;Apple&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;banana&quot;&amp;gt;Banana&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;orange&quot;&amp;gt;Orange&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; const $elem = document.getElementById(&#39;banana&#39;); $elem.style.color = &#39;red&#39;; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;id 값은 HTML 문서 내에서 유일한 값이어야 하며, class 어트립트와는 달리 공백 문자로 구분하여 여러 개의 값을 가질 수 없다. 중복된 id 값을 갖는 요소가 있어도 에러가 발생하진 않지만, getElementById 메서드는 인수로 전달된 id 값을 갖는 첫 번째 요소 노드만 반환한다.만약 인수로 전달된 id 값을 갖는 HTML 요소가 존재하지 않는 경우 getElementById 메서드는 null을 반환한다.태그 이름을 이용한 요소 노드 취득getElementsByTagName 메서드는 인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환한다. getElementsByTagName 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li id=&quot;apple&quot;&amp;gt;Apple&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;banana&quot;&amp;gt;Banana&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;orange&quot;&amp;gt;Orange&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; const $elems = document.getElementsByTagName(&#39;li&#39;); [...$elems].forEach(elem =&amp;gt; { elem.style.color = &#39;red&#39;; }); &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;DOM 컬렉션 객체인 HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.class를 이용한 요소 노드 취득getElementsByClassName 메서드는 인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환한다. getElementsByClassName 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환한다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li class=&quot;fruit apple&quot;&amp;gt;Apple&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;fruit banana&quot;&amp;gt;Banana&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;fruit orange&quot;&amp;gt;Orange&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; // class가 &#39;fruit&#39;인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다. const $elem = document.getElementsByClassName(&#39;fruit&#39;); [...$elems].forEach(elec =&amp;gt; { elem.style.color = &#39;red&#39;; }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;만약 인수로 전달된 class 값을 갖는 요소가 없을 경우 getElementsByClassName 메서드는 빈 HTMLCollection 객체를 반환한다.CSS 선택자를 이용한 요소 노드 취득CSS 선택자는 스타일을 적용하고자 하는 HTML 요소를 특정할 때 사용하는 문법이다. /* 전체 선택자: 모든 요소를 선택 */ * { ... } /* 태그 선택자: 모든 p 태그 요소를 모두 선택 */ p { ... } /* id 선택자: id 값이 &#39;foo&#39;인 요소를 모두 선택 */ #foo { ... } /* class 선택자: class 값이 &#39;foo&#39;인 요소를 모두 선택 */ .foo { ... } /* 어트리뷰트 선택자: input 요소 중에 type 어트리뷰트 값이 &#39;text&#39;인 요소를 모두 선택 */ input[type=text] { ... } /* 후손 선택자: div 요소의 후손 요소 중 p 요소를 모두 선택 */ div p { ... } /* 자식 선택자: div 요소의 자식 요소 중 p 요소를 모두 선택 */ div &amp;gt; p { ... } /* 인접 형제 선택자: p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택 */ p + ul { ... } /* 일반 형제 선택자: p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택 */ p ~ ul { ... } /* 가상 클래스 선택자: hover 상태인 a 요소를 모두 선택 */ a: hover { ... } /* 가상 요소 선택자: p 요소의 콘텐츠의 앞에 위치하는 공간을 선택, 일반적으로 content 프로퍼티와 함께 사용함 */ p::before { ... }querySelector 메서드는 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환한다. 인수로 전달한 CSS 선택자를 만족시키는 요소 노드가 여러 개인 경우 첫 번째 요소 노드만 반환한다. 인수로 전달된 CSS 선택자를 만족시키는 요소 노드가 존재하지 않는 경우 null을 반환한다. 인수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생한다. querySelectorAll 메서드는 인수로 전달한 CSS 선택자를 만족시키는 모든 요소 노드를 탐색하여 반환한다. querySelectorAll 메서드는 DOM 컬렉션 객체인 NodeList 객체를 반환하며, NodeList 객체는 유사 배열 객체이면서 이터러블이다. 인수로 전달된 CSS 선택자를 만족시키는 요소가 존재하지 않는 경우 빈 NodeList 객체를 반환한다. 인수로 전달된 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생한다. CSS 선택자 문법 메서드는 getElementById, getElementsBy* 메서드보다 느린 것으로 알려져 있다. 하지만 CSS 선택자 문법은 좀 더 구체적인 조건으로 요소 노드를 취득할 수 있고 일관된 방식으로 요소 노드를 취득할 수 있다는 장점이 있다. **따라서 id 어트리뷰트가 있는 요소 노드를 취득할 경우에는 getElementById 메서드를 사용하고 그 외의 경우는 querySelector, querySelectorAll 메서드를 사용하는 것을 권장한다." }, { "title": "Javascript 브라우저 렌더링", "url": "/posts/rendering/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-20 00:00:00 +0900", "snippet": "렌더링(rendering)은 HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다. 브라우저는 다음과 같은 과정을 거쳐 렌더링을 수행한다. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 계산하고 브라우저 화면에 HTML 요소를 페인팅한다. HTML 파싱과 DOM 생성HTML문서는 문자열로 이루어진 순수한 텍스트다. 브라우저 렌더링 엔진은 아래 그림과 같은 과정을 통해서 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM(Document Object Medel)을 생성한다.브라우저는 서버가 응답한 HTML문서를 바이트 형태로 받는다. 그리고 HTML문서의 meta 태그의 charset을 기준으로 응답받은 HTML문서를 문자열로 변환한다. 그 다음 문자열로 변환된 HTML문서를 문법적 의미를 갖는 최소 단위인 토큰들로 분해한다.각 토큰들은 객체로 변환하여 노드를 생성한다. 이 노드들은 DOM을 구성하는 기본 요소가 된다.HTML문서는 HTML요소들의 집합으로 이루어지며 HTML요소는 중첩 관계를 갖는다. 이 중첩 관계에 의해 부모-자식 관계가 형성된다. 그리고 부모-자식 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이 노드들로 구성된 트리 자료구조를 DOM(Document Object Medel)이라 부른다. DOM은 HTML문서를 파싱한 결과물이다.CSS 파싱과 CSSOM 생성렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나간다. 이때 CSS를 로드하는 link태그나 style태그를 만나면 DOM 생성을 일시 중단하고, CSS를 HTML과 동일한 파싱 과정을 거치며 CSSOM(CSS Object Model)을 생성한다. 이후 CSS 파싱이 완료되면 중단시점부터 HTML을 파싱해서 DOM 생성을 재개한다.렌더 트리 생성렌더링 엔진은 HTML과 CSS를 파싱하여 DOM과 CSSOM를 생성한다. 그리고 DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다. 렌더 트리는 렌더링을 위한 트리 구조의 자료구조다. 즉, 렌더 트리는 브라우저 화면에 렌더링되는 노드만으로 구성된다. 브라우저에 렌더링되지 않는 노드와 CSS에 의해 비표시되는 노드는 포함하지 않는다.이후 완성된 렌더 트리는 각 HTML요소의 레이아웃을 계산하는 데 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다.브라우저의 렌더링 과정은 아래의 경우에 반복해서 실행될 수 있다. 자바스크립트에 의한 노드 추가 또는 삭제 브라우저 창 리사이징에 의한 뷰포트 크기 변경 HTML요소의 레이아웃에 변경을 발생시키는 스타일 변경 리렌더링은 비용이 많이 드는 작업이므로 가급적 리렌더링이 빈번하게 발생하지 않도록 주의해야 한다.파싱과 실행HTML문서를 파싱한 결과물로 생성된 DOM은 HTML문서의 구조와 정보뿐만 아니라 HTML요소와 스타일 등을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다. 자바스크립트에서 DOM API를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.렌더링 엔진은 HTML문서를 순차적으로 파싱하며 DOM을 생성해 나가다가 자바스크립트를 로드하는 script태그나 자바스크립트 코드를 콘텐츠로 담은 script태그를 만다면 DOM 생성을 중단한다. 그리고 자바스크립트 엔진에 제어권을 넘겨 자바스크립트 코드를 파싱하고 실행한 후 다시 렌더링 엔진으로 제어권을 넘긴다.자바스크립트 엔진은 렌더링 엔진이 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하듯이 자바스크립트를 해석해서 AST(Abstract Syntax Tree)를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다. 토크나이징(tokenizing) : 자바스크립트 코드를 문법적 의미를 갖는 코드의 최소 단위인 토큰으로 분해하는 과정 파싱(parsing) : 토큰을 기반으로 AST(Abstract Syntax Tree)를 생성한다. 바이트코드 생성과 실행 : AST를 인터프리터가 실행할 수 있는 바이트코드로 변환되고 인터프리터에 의해 실행된다. 자바스크립트의 실행 순서렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고 직렬적으로 파싱을 수행한다. 이처럼 브라우저는 동기적으로, 위에서 아래 방향으로 순차적 파싱을 한다. 따라서 script태그의 위치에 따라 HTML파싱이 블로킹되어 DOM생성이 지연될 수 있다는 것이다. 따라서 script태그의 위치가 중요하다. &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&amp;gt; &amp;lt;script&amp;gt; const $apple = ducument.getElementById(&#39;apple&#39;); $apple.style.color = &#39;red&#39;; // TypeError: Cannot read property &#39;style&#39; of null &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li id=&quot;apple&quot;&amp;gt;Apple&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;peach&quot;&amp;gt;Peach&amp;lt;/li&amp;gt; &amp;lt;li id=&quot;melon&quot;&amp;gt;Melon&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;위 코드에서 렌더링 엔진이 DOM을 파싱하다가 script태그를 만나면 파싱을 멈추고 자바스크립트 엔진으로 주도권을 전달한다. 이때 아직 아이디 apple의 li태그가 파싱되어 있지 않기 때문에 스크립트 코드는 에러가 발생한다.이러한 문제를 회피하기 위해 body요소의 가장 아래에 자바스크립트를 위치시키는 것이 좋다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있다. 자바스크립트 로딩/파싱/실행으로 인해 HTML요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. " }, { "title": "Javascript Set 과 Map", "url": "/posts/SetMap/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-13 00:00:00 +0900", "snippet": "SetSet 객체는 중복되지 않은 유일한 값들의 집합이다. Set 은 배열과 유사지만 다음과 같은 차이가 있다. 구분 배열 Set 동일한 값을 중복하여 포함할 수 있음 O X 요소 순서에 의미가 있음 O X 인덱스로 요소 접근이 가능 O X Set 은 수학적 집합을 구현하기 위한 자료구조이다. 따라서 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.Set 생성Set 객체는 생성자 함수로 생성하며, 인수를 전달하지 않을 경우 빈 Set객체를 생성한다. Set 생성자 함수는 이터러블을 인수로 전달받는다. 이때 중복된 값은 Set 객체에 요소로 저장되지 않는다. 이러한 특성을 이용해 배열의 중복된 요소를 제거할 수 있다. const set1 = new Set(); console.log(set1); // Set(0) {} const set2 = new Set(&#39;hello&#39;); console.log(set2); // Set(4) {&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;} const set3 = array =&amp;gt; [...new Set(array)]; console.log(set3([1, 2, 3, 4, 3, 2, 1])); // [1, 2, 3, 4]Set 요소 개수 확인Set 객체의 요소 개수는 Set.prototype.size 프로퍼티를 사용한다. const { size } = new Set([1, 2, 3, 3]); console.log(size); // 3size 프로퍼티는 setter 함수는 없고 getter 함수만 존재한다. 따라서 size 프로퍼티에 숫자를 할당해도 요소 개수를 변경할 수 없다.Set 요소 추가Set 객체에 요소를 추가할 때는 Set.prototype.add 메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add메서드는 연속적으로 호출이 가능하다. 이때 동일한 요소를 추가할 경우 무시된다. const set = new Set(); set.add(1); // Set(1) {1} set.add(1).add(2).add(3); // Set(3) {1, 2, 3}Set 객체는 객체나 배열과 같이 자바스크립트의 모든 값을 요소로 저장할 수 있다.Set 요소 존재 여부 확인Set 객체의 요소 존재 확인은 Set.prototype.has 메서드를 이용한다. const set = new Set([1, 2, 3]); console.log(set.has(2)); // true console.log(set.has(4)); // falseSet 요소 삭제Set 객체에서 특정 요소의 삭제는 Set.prototype.delete 메서드를 이용한다. delete 메서드는 삭제 후 불리언 값으로 삭제의 성공과 실패를 반환한다. 주의할 점은 Set 객체는 인덱스를 갖지 않기 때문에 반드시 요소값을 인수로 전달해야 한다는 점이다.존재하지 않는 요소값을 전달할 경우 에러가 발생하지 않고 무시된다. 또한 add 메서드와 달리 반환값이 불리언이기 때문에 add 메서드처럼 연속적으로 사용할 수 없다. const set = new Set([1, 2, 3]); const res1 = set.delete(2); console.log(res1); // true console.log(set); // Set(2) {1, 3} const res2 = set.delete(0); console.log(res2); // false console.log(set); // Set(2) {1, 3}Set 요소 일괄 삭제Set 요소를 모두 삭제하려면 Set.prototype.clear 메서드를 사용한다. clear 메서드는 언제나 undefined를 반환한다. const set = new Set([1, 2, 3]); set.clear(); console.log(set); // Set(0) {}Set 요소 순회Set 객체에서 요소를 순회하려면 Set.prototype.forEach 메서드를 사용한다. 해당 메서드는 Array.prototype.forEach 메서드와 유사하게 콜백 함수와 forEach 메서드 콜백 함수 내부에서 this로 사용될 객체를 인수로 전달한다. 첫 번째 인수 : 현재 순회 중인 요소값 두 번째 인수 : 현재 순회 중인 요소값 세 번째 인수 : 현재 순회 중인 Set 객체 첫 번째 인수와 두 번째 인수는 같은 값이다. 이 모양은 단지 Array.prototype.forEach 메서드와 인터페이스를 통일하기 위한 모양이다. Array.prototype.forEach 메서드는 두 번째 인수에 요소의 인덱스를 전달 받는다.또한, Set 객체는 이터러블로 for…of 문으로 순회할 수 있고 스프레드 문법과 배열 구조 분할 할당의 대상이 될 수 있다. const set = new Set([1, 2, 3]); set.forEach((v1, v2, set) =&amp;gt; console.log(v1, v2, set)); // 1 1 Set(3) {1, 2, 3} // 2 2 Set(3) {1, 2, 3} // 3 3 Set(3) {1, 2, 3} for(const value of set) { console.log(value); // 1 // 2 // 3 }Set 객체는 요소의 순서에 의미를 갖지 않지만 Set 객체를 순회하는 순서는 요소가 추가된 순서로 순회한다.MapMap 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. Map 객체는 객체와 유사하지만 아래와 같은 차이가 있다. 구분 객체 Map 객체 키로 사용할 수 있는 값 문자열 또는 심벌 값 객체를 포함한 모든 값 이터러블 X O 요소 개수 확인 Object.keys(obj).length map.size Map 객체 생성Map 객체는 생성자 함수로 생성한다. 인수를 전달하지 않으면 빈 Map 객체가 생성된다. Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.Map 객체는 중복된 키를 갖는 요소가 존재하면 값을 덮어쓴다. 따라서 Map 객체는 중복된 키를 갖은 요소가 존재하지 않는다. const map = new Map(); console.log(map); // Map(0) {} const map1 = new Map([[&#39;key1&#39;, &#39;value1&#39;], [&#39;key2&#39;, &#39;value2&#39;]]); console.log(map1); // Map(2) {&quot;key1&quot; =&amp;gt; &quot;value1&quot;, &quot;key2&quot; =&amp;gt; &quot;value2&quot;} const map2 = new Map([1, 2]); // TypeError: Iterator value 1 is not an entry object const map3 = new Map([[&#39;key1&#39;, &#39;value1&#39;], [&#39;key1&#39;, &#39;value2&#39;]]); console.log(map3); // Map(1) {&quot;key1&quot; =&amp;gt; &quot;value2&quot;}Map 요소 개수 확인Map 객체의 요소 개수 확인은 Map.prototype.size 프로퍼티를 사용한다. const { size } = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]); console.log(size); // 2Map 객체의 size 프로퍼티는 Set 객체와 마찬가지로 setter 함수 없이 getter 함수만 존재한다. 따라서 size 프로퍼티에 숫자를 할당해도 Map 객체의 요소 개수는 변경되지 않는다.Map 요소 추가Map 객체의 요소 추가는 Map.prototype.set 메서드를 사용한다. const map = new Map(); console.log(map); // Map(0) {} map.set(&#39;key1&#39;, &#39;value1&#39;); console.log(map); // Map(1) {&quot;key1&quot; =&amp;gt; &quot;value1&quot;}set 메서드는 새로운 요수가 추가된 Map 객체를 반환한다. 따라서 Set 객체의 add 메서드와 마찬가지로 연속적인 호출이 가능하다. 다만, Set 객체의 add 메서드에서 중복되는 값은 무시되는 것과 다르게 Map 객체의 set 메서드에서는 중복되는 키를 갖은 요소를 추가하면 값을 덮어쓴다.일반 객체와 Map 객체의 가장 큰 차이는 키 값의 타입에 있다. 일반 객체는 문자열 또는 심벌 값만 키로 사용 가능하다. 하지만 Map 객체는 키 타입에 제한이 없어 객체를 포함한 모든 값을 키로 사용할 수 있다.Map 요소 취득Map 객체에서 특정 요소를 취득하려면 Map.prototype.get 메서드를 사용한다. get 메서드의 인수로 키를 전달하면 Map 객체에서 키에 맞는 값을 반환한다. 전달한 키를 갖는 요소가 없을 경우 undefined를 반환한다. const map = new Map(); const Lee = { name: &#39;Lee&#39; }; const Kim = { name: &#39;Kim&#39; }; map .set(lee, &#39;developer&#39;) .set(kim, &#39;designer&#39;); console.log(map.get(lee)); // developer console.log(map.get(&#39;park&#39;)); // undefinedMap 요소 존재 여부 확인Map 객체에서 특정 요소의 존재를 확인할 경우 Map.prototype.has 메서드를 사용한다. has 메서드는 특정 요소의 존재 여부를 불리언 값으로 반환한다. const lee = { name: &#39;Lee&#39; }; const kim = { name: &#39;Kim&#39; }; const map = new Map([[lee, &#39;developer&#39;], [kim, &#39;designer&#39;]]); console.log(map.has(lee)); // true console.log(map.has(&#39;park&#39;)); // falseMap 요소 삭제Map 객체의 요소를 삭제하려면 Map.protytype.delete 메서드를 사용한다. delete 메서드는 삭제 성공 여부를 불리언 값으로 반환한다.존재하지 않는 키로 Map 객체의 요소를 삭제할 경우 에러 없이 무시된다. Set 객체의 delete와 마찬가지로 반환값이 불리언이기 때문에 연속적으로 호출이 불가하다. const lee = { name: &#39;Lee&#39; }; const kim = { name: &#39;Kim&#39; }; const map = new Map([[lee, &#39;developer&#39;], [kim, &#39;designer&#39;]]); const res1 = map.delete(kim); const res2 = map.delete(&#39;park&#39;); console.log(res1); // treu console.log(res2); // false console.log(map); // Map(1) { {name: &#39;Lee&#39;} =&amp;gt; &quot;developer&quot; }Map 요소 일괄 삭제Map 객체의 요소를 일괄 삭제하려면 Map.prototype.clear 메서드를 사용한다. clear 메서드는 언제나 undefined를 반환한다. const map = new Map([[&#39;key1&#39;, &#39;value1&#39;], [&#39;key2&#39;, &#39;value2&#39;]]); map.clear(); console.log(map); // Map(0) {}Map 요소 순회Map 객체의 요소를 순회하려면 Map.prototype.forEach 메서드를 사용한다. Array.prototype.forEach 메서드와 유사하게 콜백 함수와 forEach 메서드의 콜백 함수 내부에서 this로 사용될 객체를 전달받는다. 첫 번째 인수 : 현재 순회 중인 요소값 두 번째 인수 : 현재 순회 중인 요소키 세 번째 인수 : 현재 순회 중인 Map 객체 Array.prototype.forEach 메서드에서는 두 번째 인수가 인덱스를 가지고, Set.prototype.forEach 메서드에서는 첫 번째 인수와 동일한 값, Map.prototype.forEach 메서드에서는 요소키를 가진다는 차이가 있다. const lee = { name: &#39;Lee&#39; }; const kim = { name: &#39;Kim&#39; }; const map = new Map([[lee, &#39;developer&#39;], [kim, &#39;designer&#39;]]); map.forEach((value1, value2, map) =&amp;gt; console.log(value1, value2, map)); // developer { name: &quot;Lee&quot; } Map(2) { { name: &quot;Lee&quot;} =&amp;gt; &quot;developer&quot;, { name: &quot;Kim&quot;} =&amp;gt; &quot;designer&quot; } // designer { name: &quot;Kim&quot; } Map(2) { { name: &quot;Lee&quot;} =&amp;gt; &quot;developer&quot;, { name: &quot;Kim&quot;} =&amp;gt; &quot;designer&quot; }Map 객체도 이터러블이므로 for…of 문으로 순회할 수 있으며, 스프레드 문법과 배열 구조 분해 할당의 대상이 될 수 있다.Map 객체는 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다. Map 메서드 설명 Map.prototype.keys Map 객체에서 요소키를 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. Map.prototype.values Map 객체에서 요소값을 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. Map.prototype.entries Map 객체에서 요소키와 요소값을 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. " }, { "title": "Javascript 구조 분해 할당", "url": "/posts/destructing/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-13 00:00:00 +0900", "snippet": "디스트럭처링 할당은 구조 분해 할당이다. 이는 배열과 같은 이터러블 또는 객체를 비구조화 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 이터러블 또는 객체 리터럴에서 필요한 값만 추출할 때 유용하다.배열 구조 분해 할당배열 구조 분해 할당의 대상은 이터러블이여야 하며, 할당의 기준은 배열의 인덱스이다. const arr = [1, 2, 3]; const [one, two, three] = arr; console.log(one); // 1 console.log(two); // 2 console.log(three); // 3배열 구조 분해 할당에서 우변에 이터러블을 할당하지 않으면 에러가 발생한다. const [x, y]; // SyntaxError: Missing initializer in destructuring declaration const [a, b] = {}; // TypeError: {} is not iterable배열 구조 분해 할당에서 변수의 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다. const [a, b] = [1, 2]; console.log(a, b); // 1 2 const [c, d] = [1]; console.log(c, d); // 1 undefined const [e, f] = [1, 2, 3]; console.log(e, f); // 1 2 const [g, , h] = [1, 2, 3]; console.log(g, h); // 1 3배열 구조 분해 할당에서는 변수의 기본값을 설정할 수 있다. 하지만 기본값보다 할당값이 우선한다. const [a, b, c = 3] = [1, 2]; console.log(a, b, c); // 1 2 3 const [e, f = 10, g = 20] = [1, 2, 3]; console.log(e, f, g); // 1 2 3배열 구조 분해 할당을 위한 변수에서는 Rest 요소를 사용할 수 있으며, 이 때 Rest 요소는 마지막에 위치해야 한다. const [x, ...y] = [1, 2, 3]; console.log(x, y); // 1 [2, 3]객체 구조 분해 할당ES6 객체 구조 분해 할당은 객체의 각 프로퍼티를 객체로 추출하여 1개 이상의 변수에 할당한다. 이때 객체 구조 분해 할당의 대상은 객체이여야 하며, 할당 기준은 프로퍼티 키다. 즉, 순서는 의미가 없으며 선언된 변수 이름과 프로퍼티 키가 일치해야 한다. const user = { id: 1, nick: &#39;Lee&#39; }; const { nick, id } = user; console.log(id, nick); // 1 &#39;Lee&#39;겍체 구조 분해 할당에서 객체 리터럴 형태로 선언한 변수는 프로퍼티의 축약 표현이다. 아래 두 코드는 동일한 의미이다. const { id, nick } = user; const { id: id, nick: nick } = user;따라서 객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받을 수 있다. const user = { id: 1, nick: &#39;Lee&#39; }; const { id: id_num, nick: name } = user; console.log(id_num, name); // 1 &#39;Lee&#39;객체 구조 분해 할당은 객체에서 필요한 프로퍼티 값만 추출할 때 유용하다. const data = { id: 1, content: &#39;AAA&#39; }; const { id } = data; console.log(id); // 1객체 구조 분해 할당은 객체를 인수로 전달받는 함수의 매개변수에서도 유용하다. function printData({ id, content }) { console.log(`ID: ${id}, CONTENT: ${content}`); }중첩 객체의 경우 프로퍼티 키로 객체를 추출한 후 해당 객체의 프로퍼티 키로 값을 추출할 수 있다. const user = { neme: &#39;Lee&#39;, address: { city: &#39;A&#39; } }; const { address: { city } } = user; console.log(city); // A " }, { "title": "Javascript 스프레드 문법", "url": "/posts/spread-syntax/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-12 00:00:00 +0900", "snippet": "스프레드 문법은 ES6에서 도입된 문법으로 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 이러한 스프레드 문법은 for…of 문으로 순회할 수 있는 이터러블에 한정된다. console.log(...[1, 2, 3]); // 1, 2, 3 console.log(...&#39;Hello&#39;); // H e l l o console.log(...{a: 1, b: 2}); // TypeError: Found non-callable @@iterator // 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.스프레드 문법의 결과는 값이 아니다. 이터러블의 요소들을 펼쳐서 만든 개별적인 값들의 목록이다. 따라서 스프레드 문법의 결과물은 값으로 사용할 수 없고, 다음과 같이 쉽표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.- 함수 호출문의 인수 목록- 배열 리터럴의 요소 목록- 객체 리터럴의 프로퍼티 목록함수 호출문의 인수 목록에서 사용하는 경우 const arr = [1, 2, 3]; const max1 = Math.max(arr); // NaN // Math.max(...[1, 2, 3])은 Math.max(1, 2, 3)과 같다. const max2 = Math.max(...arr); // 3스프레드 문법은 Rest 파라미터와 형태가 동일하여 혼동할 수 있다. Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다. Rest 파라미터는 목록을 배열로 만들고, 스프레드 문법은 이터러블을 펼쳐서 값들의 목록으로 만든다.배열 리터럴 내부에서 사용하는 경우스프레드 문법을 활용하면 기존에 사용하던 배열 빌드인 함수를 대체할 수 있다. // 2개의 배열을 1개의 배열로 결합하는 경우 // ES5 var arr1 = [1, 2].concat([3, 4]); console.log(arr1); // [1, 2, 3, 4] // ES6 const arr2 = [...[1, 2], ...[3, 4]]; console.log(arr2); // [1, 2, 3, 4] // 배열을 복사하는 경우 // ES5 var origin1 = [1, 2]; var copy1 = origin1.slice(); console.log(copy1); // [1, 2] console.log(copy1 === origin1); // false // ES6 const origin2 = [1, 2]; const copy2 = [...origin2]; console.log(copy2); // [1, 2] console.log(copy2 === origin2); // false배열을 복사하는 경우 스프레드 문법과 slice 메서드 모두 얕은 복사를 통해 새로운 복사본을 생성한다.객체 리터럴 내부에서 사용하는 경우Rest 프로퍼티와 함께 2021년 1월 현재 TC39 프로세스의 stage 4 단계에 제안되어 있는 스프레드 프로퍼티를 사용하면 객체 리러털의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다. 스프레드 문법은 이터러블에서만 제한되었지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다. //스프레드 프로퍼티 const obj = { x: 1, y: 2 }; const copy = { ...obj }; console.log(copy); // { x: 1, y: 2 } console.log(obj === copy); // false // 객체 병합 const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } }; console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }프로퍼티가 중복되는 경우, 특정 프로퍼티의 병경 및 추가는 아래와 같다. // 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다. const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } }; console.log(merged); // { x: 1, y: 10, z: 3 } // 특정 프로퍼티 변경 const changed = { ...{ x: 1, y: 2 }, y: 100 }; console.log(changed); // { x: 1, y: 100 } // 프로퍼티 추가 const added = { ...{ x: 1, y: 2 }, z: 0 }; console.log(added); // { x: 1, y: 2, z: 0 }" }, { "title": "Javascript 이터러블", "url": "/posts/iterable/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-11 00:00:00 +0900", "snippet": "ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위해 정의된 규약이다. ES6에서는 순회 가능한 데이터 컬렉션을 이터러블로 통일하여 for…of문, 스프레드 문법, 배열 디스트럭팅 할당의 대상으로 사용할 수 있다.이터러블이터러블은 Symbol.iterator 를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다. const arr = [1, 2, 3]; //배열은 Array.prototype의 Symbol.iterator 메서드를 상속받은 이터러블이다. console.log(Symbol.iterator in arr); // true // for...of 문으로 순회 가능하다. for(const item of arr) { console.log(item); } // 1 // 2 // 3 // 이터러블은 스프레드 문법의 대상으로 사용이 가능하다. console.log([...arr]); // [1, 2, 3] // 이터러블은 배열 디스트럭팅 할당의 대상으로 사용이 가능하다. const [a, ...rest] = arr; console.log(a, rest); // 1, [2, 3]이터레이터이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터를 반환한다. 반환된 이터레이터는 next 메서드를 갖는다. next 메서드는 이터러블의 각 요소를 순회하기 위한 포인터의 역할을 한다. 즉, next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다. const arr = [1, 2, 3]; const iterator = arr[Symbol.iterator](); console.log(iterator.next()); // { value: 1, done: false} console.log(iterator.next()); // { value: 2, done: false} console.log(iterator.next()); // { value: 3, done: false} console.log(iterator.next()); // { value: undefined, done: true}이 때 value 프로퍼티는 현재 순회 중인 이터러블의 값을 나타내고 done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.빌트인 이터러블 빌트인 이터러블 Symbol.iterator 메서드 Array Array.prototype[Symbol.iterator] String String.prototype[Symbol.iterator] Map Map.prototype[Symbol.iterator] Set Set.prototype[Symbol.iterator] TypedArray TypedArray.prototype[Symbol.iterator] arguments arguments[Symbol.iterator] DOM 컬렉션 NodeList.prototype[Symbol.iterator] HTMLCollection.prototype[Symbol.iterator] for…of 문for…of 문은 이터러블을 순회하면서 이터러블 요소를 변수에 할당한다. for…of 문은 for…in 문과 유사하다. for (변수선언문 of 이터러블) { … } for (변수선언문 in 객체) { … }for…in 문의 경우 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다. 이때 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다.for…of 문은 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티의 값을 for…of문의 변수에 할당한다. for…of문은 done 프로퍼티 값이 true가 되면 순회를 중단한다.이터러블과 유사 배열 객체유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근이 가능하며, length 프로퍼티를 갖는 객체를 말한다. 유사 배열 객체는 이터러블이 아닌 일반 객체이다. 따라서 유사 배열 객체는 Symbol.iterator 메서드가 없기 때문에 for…of 문으로 순회할 수 없다.단, arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다. ES6에서 이터러블의 도입과 함께 arguments, NodeList, HTMLCollection 객체에 Symbol.iterator 메서드를 구현하여 이터러블이 되었다. 이터러블이 된 이후에도 여전히 length 프로퍼티를 가지며 인덱스로 접근이 가능한다.위 세 경우를 제외한 유사 배열 객체도 ES6에서 추가된 Array.from 메서드를 사용하면 배열로 변환할 수 있다. // 유사 배열 객체 const obj = { 0: 1, 1: 2, 2: 3, length: 3 }; for(const item of obj) { console.log(item); } // TypeError: obj is not iterable const arr = Array.from(obj); console.log(arr); // [1, 2, 3]" }, { "title": "Javascript String", "url": "/posts/string/", "categories": "Javascript", "tags": "javascript", "date": "2022-07-06 00:00:00 +0900", "snippet": "String 객체표준 빌트인 객체인 String 객체는 생성자 함수 객체다. new 연산자를 통해 호출하면 인수를 전달받아 [[StringData]] 내부 슬롯에 인수를 할당한 String 래퍼 객체를 생성한다.String 래퍼 객체는 배열과 마찬가지로 length 프로퍼티와 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 각 문자를 값으로 갖는 유사 배열 객체이면서 이터러블이다.문자열은 원시 값이므로 변경할 수 없다.String 메서드String 객체의 메서드는 언제나 새로운 문자열을 반환한다. 문자열은 불변한 원시 값이기 때문에 String 래퍼 객체도 읽기 전용 객체로 제공한다.String.prototype.indexOfindexOf 메서드는 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스를 반환한다. 검색에 실패할 경우 -1을 반환한다. const str = &#39;Hello World&#39;; str.indexOf(&#39;l&#39;); // 2 str.indexOf(&#39;l&#39;, 3); // 두 번째 전달한 인수는 검색을 시작할 인덱스를 의미 &amp;gt; 3 if (str.indexOf(&#39;Hello&#39;) !== -1) { // str에 &#39;Hello&#39;가 있을 경우를 처리... } if (str.includes(&#39;Hello&#39;)) { // 위와 동일한 처리가 가능함 }String.prototype.searchsearch 메서드는 대상 문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색해서 일치하는 문자열의 인덱스를 반환한다. 검색에 실패할 경우 -1을 반환한다. const str = &#39;Hello World&#39;; const regExp = /[l]/g; str.search(/o/); // 4 str.search(/x/); // -1 str.search(regExp); // 처음 검색된 인덱스를 반환 &amp;gt; 2String.prototype.includesincludes 메서든는 ES6에서 도입된 메서드로 대상 문자열에 인수로 전달받은 문자열이 포함되었는지 여부를 불리언으로 반환한다. const str = &#39;Hello World&#39;; str.includes(&#39;Hello&#39;); // true str.includes(&#39;&#39;); // true str.includes(); // false str.includes(&#39;H&#39;, 3); // 3 번째 인덱스부터 검색을 시작 &amp;gt; falseString.prototype.charAtcharAt 메서드는 대상 문자열에서 인수로 전달받은 인덱스에 위치한 검색을 반환한다. 문자열의 범위를 벗어난 인덱스를 전달할 경우 빈 문자열을 반환한다. const str = &#39;Hello&#39;; for(let i=0; i&amp;lt;str.length; i++) { console.log(str.charAt(i)); // H // e // l // l // o } str.charAt(5); // &#39;&#39;String.prototype.substringsubstring 메서드는 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치한 문자의 바로 이전 문자까지 부분 문자열을 반환한다.두 번째 인수를 생략할 경우 마지막 문자까지의 부분 문자열을 반환한다. const str = &#39;Hello World&#39;; str.substring(1, 4); // 인덱스 1번부터 인덱스 4번 직전인 인덱스 3번까지의 문자열 &amp;gt; &#39;ell&#39; str.substring(1); // 인덱스 1번부터 마지막 문자까지 &amp;gt; &#39;ello World&#39; // 첫 번째 인수 &amp;gt; 두 번째 인수인 경우 두 인수는 교환된다. str.substring(4, 1); // &#39;ell&#39; // 인수 &amp;lt; 0 또는 NaN인 경우 0으로 취급된다. str.substring(-2); // &#39;Hello World&#39; // 인수 &amp;gt; 문자열의 길이인 경우 인수는 문자열의 길이로 취급된다. str.substring(1, 100); // &#39;ello World&#39; str.substring(20); // &#39;&#39;String.prototype.sliceslice 메서드는 substring과 동일하게 동작한다. 단, slice 메서드는 음수인 인수를 전달할 수 있으며, 음수를 전달할 경우 문자열의 가장 뒤에서부터 시작하여 문자열을 잘라 반환한다. const str = &#39;Hello World&#39;; str.slice(-5); // 뒤에서 5자리 &amp;gt; &#39;World&#39;String.prototype.trimtrim 메서드는 대상 문자열 앞뒤에 공백 문자를 제거한 후 문자열을 반환한다. 문자열 사이에 있는 공백은 제거하지 않는다. const str = &#39; Hello World &#39;; str.trim(); // &#39;Hello World&#39;String.prototype.replacereplace 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 문자열 또는 정규표현식을 검색하여 두 번째 인수로 전달한 문자열로 치환하여 문자열을 반환한다. 검색된 문자열이 여럿 존재할 경우 첫 번째 검색된 문자열만 치환한다.검색된 문자열 모두를 검색하려면 정규식을 사용하면 된다. const str = &#39;Hello World World&#39;; str.replace(&#39;World&#39;, &#39;world&#39;); // &#39;Hello world World&#39;; str.replace(/World/gi, &#39;world&#39;); // &#39;Hello world world&#39;;String.prototype.splitsplit 메서드는 대상 문자열에서 첫 번째 인수로 전달한 문자열 또는 정규표현식을 섬색하여 문자열을 구분한 후 분리된 각 문자열을 배열로 반환한다. 빈 문자열을 전달할 경우 각 문자를 모두 분리하고, 인수를 생략하면 문자열을 단일 요소로 반환한다.두 번째 인수는 배열의 길이를 지정할 수 있다. 배열을 길이를 작게 잡으면 길이를 넘어가는 요소는 잘려나간다. const str = &#39;AA BB&#39;; str.split(&#39; &#39;); // [&quot;AA&quot;, &quot;BB&quot;] str.split(&#39;&#39;); // [&quot;A&quot;, &quot;A&quot;, &quot; &quot;, &quot;B&quot;, &quot;B&quot;] str.split(); // [&quot;AA BB&quot;] str.split(&#39; &#39;, 1); // [&quot;AA&quot;]" }, { "title": "Javascript 정규식", "url": "/posts/RegExp/", "categories": "Javascript", "tags": "javascript, regexp", "date": "2022-07-05 00:00:00 +0900", "snippet": "정규 표현식정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어이다. 이러한 정규 표현식은 문자열을 대상으로 패턴 매칭 기능을 제공한다. 패턴 매칭 기능이란 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능이다.만약 정규 표현식을 사용하지 않는다면 반복문과 조건문을 통해 각 문자를 체크해야하지만 정규 표현식을 사용하면 반복문과 조건문 없이 패턴을 정의하고 테스트하는 것이 가능하다. 다만 정규 표현식은 주석이나 공백을 허용하지 않고 여러 가지 기호를 사용하기 때문에 가독성이 좋이 않다.일반적으로 정규 표현식은 정규 표현식 리터럴을 사용하며 정규 표현식 리터럴은 패턴과 플래그로 구성된다. const target = &#39;Is this all there is?&#39;; // 패턴 : is // 플래그 : i, 대소문자 구별하지 않고 검색 const regexp = /is/i; regexp.test(target); // trueRegExp 메서드RegExp.prototype.execexec 메서드는 인수로 받은 문자열에 대한 정규식 패턴을 검색해서 매칭 결과를 배열로 반환한다. 매칭 결과가 없으면 null을 반환한다. const target = &#39;Is this all there is?&#39;; const regExp = /is/; regExp.exec(target); // [&quot;is&quot;, index: 5, input: &quot;Is this all there is?&quot;, groups: undefined]exec 메서드는 플래그를 지정해도 첫 매칭 결과만 반환하므로 주의해야 한다.RegExp.prototype.testtest 메서드는 패던 검색을 해서 매칭 결과를 불리언으로 반환한다. input의 형식을 검사할 때 사용한다. const target = &#39;Is this all there is?&#39;; const regExp = /is/; regExp.test(target); // trueString.prototype.matchString 표준 빌트인 객체가 제공하는 match 함수이다. 정규식과의 매칭 결과를 배열로 반환한다. match 함수는 exec 함수와 다르게 모든 패턴을 검색하는 g 플래그를 지정하면 모든 매칭 결과를 배열로 반환한다. const target = &#39;Is this all there is?&#39;; const regExp = /is/g; target.match(regExp); // [&quot;is&quot;, &quot;is&quot;]플래그플래그는 정규식 검색 방식을 설정하기 위해 사용한다. 플래그는 총 6개가 있다. 플래그는 옵션으로 선택적으로 사용이 가능하며, 순서와 상관없이 하나 이상의 플래그 설정이 가능하다. 플래그 설명 i 대소문자 구분 없이 검색 g 패턴과 일치하는 모든 것을 검색, g 플래그가 없을 경우 일치하는 첫 번째 결과만 반환 m 다중 행 모드를 활성화, 문자열의 행이 바뀌더라도 패턴 검색을 계속함 s 개행문자와 .이 일치함 u 유니코드 전체를 지원함 y 문자 내 특정 위치에서 검색을 진행하는 sticky 모드를 활성화 패턴임의의 문자열 검색.은 임의의 문자 한 개를 의미한다. …의 경우 문자의 내용과 상관없이 3자리 문자열과 매치한다. const target = &#39;Is this all there is?&#39;; const regExp = /.../g; target.match(regExp); // [&quot;Is &quot;, &quot;thi&quot;, &quot;s a&quot;, &quot;ll &quot;, &quot;the&quot;, &quot;re &quot;, &quot;is?&quot;]반복 검색{m,n}은 앞선 패턴이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백은 없어야한다.{n}은 앞선 패턴이 n번 반복되는 문자열을 의미한다. {n,n}과 의미가 같다.{n,}은 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.+는 패턴이 최소 한번 이상 반복되는 문자열로 {1,}과 같다.?는 패턴이 최대 한번 이상(0번 포함) 반복되는 문자열을 의미한다. 즉, {0,1}과 같다. const target_1 = &#39;A AA B BB Aa Bb AAA&#39;; const regExp_1 = /A{1,2}/g; const regExp_2 = /A{2}/g; const regExp_3 = /A{2,}/g; const regExp_4 = /A+/g; target_1.match(regExp_1); // [&quot;A&quot;, &quot;AA&quot;, &quot;A&quot;, &quot;AA&quot;, &quot;A&quot;] target_1.match(regExp_2); // [&quot;AA&quot;, &quot;AA&quot;] target_1.match(regExp_3); // [&quot;AA&quot;, &quot;AAA&quot;] target_1.match(regExp_4); // [&quot;A&quot;, &quot;AA&quot;, &quot;A&quot;, &quot;AAA&quot;] const target_2 = &#39;color colour&#39;; const regExp_5 = /colou?r/g; // colo 다음 u가 최대 한번(0번 포함) 이상 반복되고 &#39;r&#39;이 이어지는 문자열 검색 target_2.match(regExp_5); // [&quot;color&quot;, &quot;colour&quot;]OR 검색 const target = &#39;A AA B BB Aa Bb&#39;; const regExp = /A|B/g; // A 또는 B target.match(regExp); // [&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;]분해되지 않은 문자열을 검색할 때 +를 조합하면 된다. const target = &#39;A AA B BB Aa Bb&#39;; const regExp = /A+|B+/g; target.match(regExp); // [&quot;A&quot;, &quot;AA&quot;, &quot;B&quot;, &quot;BB&quot;, &quot;A&quot;, &quot;B&quot;]OR 패턴은 간단히 대괄호로 표현할 수 있다. 범위를 지정할 경우 대괄호 내에 -를 사용한다. const target_1 = &#39;A AA B BB Aa Bb&#39;; const target_2 = &#39;AA BB ZZ Aa Bb&#39;; const target_3 = &#39;AA BB Aa Bb 12&#39;; const target_4 = &#39;AA BB 12,345&#39;; const regExp_1 = /[AB]+/g; const regExp_2 = /[A-Z]+/g; const regExp_3 = /[A-Za-z]+/g; const regExp_4 = /[0-9]+/g; const regExp_5 = /[0-9,]+/g; target_1.match(regExp_1); // [&quot;A&quot;, &quot;AA&quot;, &quot;B&quot;, &quot;BB&quot;, &quot;A&quot;, &quot;B&quot;] target_2.match(regExp_2); // [&quot;AA&quot;, &quot;BB&quot;, &quot;ZZ&quot;, &quot;A&quot;, &quot;B&quot;] target_3.match(regExp_3); // [&quot;AA&quot;, &quot;BB&quot;, &quot;Aa&quot;, &quot;Bb&quot;] target_4.match(regExp_4); // [&quot;12&quot;, &quot;345&quot;] target_4.match(regExp_5); // [&quot;12,345&quot;][0-9]는 숫자를 의미하며 \\d와 같은 표현이다. \\D는 \\d와 반대로 문자를 의미한다. const target = &#39;AA BB 12,345&#39;; let regExp = /[\\d,]+/g; target.match(regExp); // [&quot;12,345&quot;] regExp = /[\\D,]+/g; target.match(regExp); // [&quot;AA&quot;, &quot;BB&quot;, &quot;,&quot;]\\w는 알파벳, 숫자, 언더스코어를 의미한다. 즉, [A-Za-z0-9_]와 같다. \\W는 \\w와 반대로 알파벳, 숫자, 언더스코어를 제외한 문자를 의미한다. const target = &#39;Aa Bb 12,345 _$%&amp;amp;&#39;; let regExp = /[\\w,]+/g; target.match(regExp); // [&quot;Aa&quot;, &quot;Bb&quot;, &quot;12,345&quot;, &quot;_&quot;] regExp = /[\\W,]+/g; target.match(regExp); // [&quot; &quot;, &quot; &quot;, &quot;,&quot;, &quot; $%&amp;amp;&quot;]NOT 검색[…] 안의 ^은 not의 의미를 가진다. const target = &#39;AA BB 12 Aa Bb&#39;; const regExp = /[^0-9]+/g; target.match(regExp); // [&quot;AA BB &quot;, &quot; Aa Bb&quot;]시작 위치와 끝 위치[…] 밖의 ^은 문자열의 시작을 의미한다. $는 문자열의 마지막을 의미한다. const target = &#39;https://poiemaweb.com&#39;; // https로 시작하는지 검사 const regExp_1 = /^https/; // com으로 끝나는지 검사 const regExp_2 = /com$/; regExp_1.test(target); // true regExp_2.test(target); // true" }, { "title": "Javascript Array_04", "url": "/posts/array-04/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-26 00:00:00 +0900", "snippet": "배열 고차 함수고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말한다. 고차 함수는 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.Array.prototype.sortsort 메서드는 배열의 요소를 정렬한다. 기본적으로 오름차순으로 요소를 정렬한다. const fruits = [&#39;banana&#39;, &#39;orange&#39;, &#39;apple&#39;]; fruits.sort(); console.log(fruits); // [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;]숫자 요소의 배열을 정렬할 때 주의가 필요하다. sort 메서드는 배열의 요소가 숫자 타입이라 할지라도 배열의 요소를 일시적으로 문자열로 변환한 후 유니코드 코드 포인트의 순서를 기준으로 정렬한다. 따라서 숫자 요소를 정렬할 경우 sort 메서드에 정렬 순소를 정의하는 비교 함수를 인수로 전달해야 한다. const points = [5, 4, 3, 2, 1]; // 숫자 배열의 오름차순 정렬, 비교 함수의 반환값이 0보다 작으면 a를 우선하여 정렬한다. points.sort((a, b) =&amp;gt; a -b); console.log(points); // [1, 2, 3, 4, 5]Array.prototype.forEachforEach 함수는 for문을 대체할 수 있는 고차함수이다. forEach 함수는 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출한다. const numbers = [1, 2, 3]; const pows = []; numbers.forEach(i =&amp;gt; pows.push(i ** 2)); console.log(pows); // [1, 4, 9]forEach 메서드는 for 문과 달리 break, continue 문을 사용할 수 없다. 그리고 희소 배열의 경우 존재하지 않는 요소는 순회 대상에서 제외된다.Array.prototype.mapmap 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값들로 구성된 배열을 반환한다.forEach 메서드와 마찬가지로 원본 배열은 변경되지 않는다. const numbers = [1, 4, 9]; const roots = numbers.map(i =&amp;gt; Math.sqrt(i)); console.log(roots); // [1, 2, 3] console.log(numbers); // [1, 4, 9]forEach 메서드와 map 메서드의 공통점은 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다는 점이다. 차이점은 forEach 메서드는 언제나 undefined를 반환하지만 map 메서드는 콜백 함수의 반환값으로 이루어신 새로운 배열을 반환한다는 점이다.map 메서드가 생성하여 반환하는 새로운 배열의 length 프로퍼티 값은 map 메서드를 호출한 배열의 length 프로퍼티 값과 반드시 일치한다. 즉, map 메서드를 호출한 배열과 map 메서드가 생성하여 반환한 배열은 1:1 매핑한다.Array.prototype.filterfilter 메서드는 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다. filter 메서드는 map 메서드와 달리 filter 메서드가 생성한 배열의 length 프로퍼티 값과 filter 메서드를 호출한 length 프로퍼티 값이 일치하지 않는다.이러한 filter 메서드는 자신을 호출한 배열에서 특정 요소를 제거하기 위해 사용하기도 한다. const numbers = [1, 2, 3, 4, 5]; const odds = numbers.filter(i = &amp;gt; i % 2); console.log(odds); // [1, 3, 5]Array.prototype.reducereduce 메서드는 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 하나의 결과값을 만들어 반환한다. reduce 함수는 첫 번째 인수로 콜백 함수를, 두 번째 인수로 초기값을 전달받는다. const numbers = [1, 2, 3, 4]; const sum = numbers.reduce((acc, cur) =&amp;gt; acc + cur, 0); // acc 는 초기값 이후 콜백 함수의 반환값이 들어감 // cur 는 배열의 요소들이 차례로 들어감 console.log(sum); // 10이러한 과정을 반복한 후 reduce 메서드는 하나의 값을 반환한다.Array.prototype.somesome 메서드는 콜백 함수의 반환값이 한번이라도 참이면 true, 아니면 false를 반환한다. 단 some 메서드는 빈 배열의 경우 항상 false를 반환한다. [1, 2, 3].some(i =&amp;gt; i &amp;gt; 2); // true [1, 2, 3].some(i =&amp;gt; i &amp;lt; 1); // false [].some(i =&amp;gt; i &amp;lt; 3); // false Array.prototype.everyevery 메서드는 콜백 함수의 반환값이 모두 참이면 true, 한번이라도 거짓이면 false를 반환한다. 단 every 메서드는 빈 배열의 경우 항상 treu를 반환한다. [1, 2, 3].every(i =&amp;gt; i &amp;lt; 4); // true [1, 2, 3].every(i =&amp;gt; i &amp;lt; 3); // false [].every(); // trueArray.prototype.findfind 메서드는 반환값이 true인 첫 번째 요소를 반환한다. 만약 true인 요소가 없다면 undefined를 반환한다. find 메서드는 요소를 반환하는 것에 주의하자. const arr = [ { id: 1, text: &#39;a&#39;}, { id: 2, text: &#39;b&#39;}, { id: 3, text: &#39;c&#39;}, ] arr.find(i =&amp;gt; i.id === 2); // { id: 2, text: &#39;b&#39; }Array.prototype.findIndexfindIndex 메서드는 반환값이 true인 첫 번째 요소의 인덱스를 반환한다. 만약 true인 요소가 없다면 -1 을 반환한다. const arr = [ { id: 1, text: &#39;a&#39;}, { id: 2, text: &#39;b&#39;}, { id: 3, text: &#39;c&#39;}, ] arr.findIndex(i =&amp;gt; i.id === 2); // 2" }, { "title": "Javascript Array_03", "url": "/posts/array-03/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-23 00:00:00 +0900", "snippet": "Array 메서드자바스크립트는 배열에 대한 다양한 빌트인 메서드를 제공한다. Array 생성자 함수는 정적 메서드를 제공하며, Array.prototype은 프로토타입 메서드를 제공한다.배열에는 원본 배열을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수효과가 있기 때문에 가급적 원본 배열을 변경하지 않는 메서드를 사용하는 것이 좋다.Array.isArrayArray.isArray는 Array 생성자 함수의 정적 메서드다. Array.isArray 메서드는 전달된 인수가 배열이면 true, 배열이 아니면 false를 반환한다. Array.isArray([]); // true Array.isArray({}); // falseArray.prototype.indexOfindexOf 메서드는 원본 배열에서 인수로 전달된 요소의 인덱스를 반환한다. 이때 배열에 인수로 전달된 요수가 중복되는 경우 첫 번째로 검색된 요소의 인덱스를 반환한다. 그리고 인수로 전달된 요소가 존재하지 않을 경우 -1을 반환한다. const arr = [1, 2, 2, 3]; arr.indexOf(2); // 1 arr.indexOf(4); // -1indexOf는 배열에 특정 요소가 존재하는지 확인할 때 유용하다.Array.prototype.pushpush 메서드는 인수로 전달받은 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. const arr = [1, 2]; let result = arr.push(3, 4); console.log(result); // 4 console.log(arr); // [1, 2, 3, 4]push 메서드는 원본 배열을 직접 변경한다. 따라서 스프레트 문법을 사용해서 배열의 복사본을 만들면서 요소를 추가하는 것이 좋다. const arr = [1, 2]; const newArr = [...arr, 3]; console.log(newArr); // [1, 2, 3]Array.prototype.poppop 메서드는 원본 배열의 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열일 경우 undefined를 반환한다. pop는 원본 배열을 직접 변경한다. const arr = [1, 2]; let result = arr.pop(); console.log(result); // 2 console.log(arr); // [1]Array.prototype.unshiftunshift 메서드는 전달받은 값을 원본 배열 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. const arr = [1, 2]; let result = arr.unshift(3, 4); console.log(result); // 4 console.log(arr); // [3, 4, 1, 2]unshift 메서드도 원본 배열을 직접 변경한다. 따라서 스프레드 문법을 사용하는 것이 좋다. const arr = [1, 2]; const newArr = [3, 4, ...arr]; console.log(newArr); // [3, 4, 1, 2]Array.prototype.shiftshift 메서드는 원본 배열의 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 빈 배열일 경우 undefined를 반환한다. shift 메서드는 원본 배열을 직접 변경한다. const arr = [1, 2]; let result = arr.shift(); console.log(result); // 1 console.log(arr); // [2]Array.prototype.concatconcat 메서드는 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달된 값이 배열일 경우 배열을 해체하여 새로운 배열의 요소로 추가하며, 원본 배열은 변경되지 않는다. const arr1 = [1, 2]; const arr2 = [3, 4]; let result = arr1.concat(arr2); console.log(arr1); // [1, 2, 3, 4] result = arr2.concat(arr1); console.log(arr2); // [3, 4, 1, 2]concat 메서드는 원본 배열을 변경하지는 않지만 스프레드 문법으로 대체가 가능하므로 push, unshift, concat 대신 스프레드 문법을 사용하는 것을 추천한다. const arr1 = [1, 2]; const arr2 = [3, 4]; let result = [...arr2, ...arr1]; console.log(result); // [3, 4, 1, 2]Array.prototype.splicesplice 메서드는 원본 배열의 중간에 요소를 추가하거나 제거할 수 있다. splice는 원본 배열을 직접 변경한다.splice 메서드는 3개의 매개변수를 가진다. // arr.splice(start, deleteCount, items); // start : 시작 인덱스 // deleteCount : 시작 인덱스로부터 제거할 요소의 개수 // items : 제거한 위치에 삽입할 요소들, 생략할 경우 제거하기만 함 const arr = [1, 2, 3, 4, 5]; const result = arr.splice(1, 2, 4); console.log(result); // [2, 3] &amp;gt;&amp;gt; 제거한 요소를 반환 console.log(arr); // [1, 4, 4, 5]splice 메서드의 deleteCount를 0으로 지정하면 요소의 제거없이 새로운 요소를 삽입할 수 있다. 또 deleteCount를 생략할 경우 시작 인덱스 이후의 모든 요소를 제거한다.Array.prototype.sliceslice 메서드는 인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. 원본 배열은 젼경되지 않는다. // arr.slice(start, end); // start : 복사를 시작할 인덱스, 음수의 경우 배열의 끝에서 센다. // end : 복사를 종료할 인덱스, 해당 인덱스는 복사되지 않는다. 생략 시 기본값으로 length 프로퍼티 값 const arr = [1, 2, 3]; arr.slice(0, 1); // [1] arr.slice(1, 2); // [2]slice 메서드의 인수를 모두 생략할 경우 원본 배열의 복사본을 생성하여 반환한다. 이때 생성된 복사본은 얕은 복사를 통해 생성된다. const arr = [1, 2, 3]; const copy = arr.slice(); console.log(copy); // [1, 2, 3] console.log(copy === arr); // falseArray.prototype.joinjoin 메서드는 원본 배열의 모든 요소를 문자열로 변환 후, 인수로 전달받은 문자열" }, { "title": "Javascript Array_02", "url": "/posts/array-02/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-21 00:00:00 +0900", "snippet": "배열의 생성배열 리터럴가장 일반적이고 간편한 배열 생성 방식은 배열 리터럴을 사용하는 것이다. 배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 대괄호로 묶는다. 배열 리터럴은 객체 리터럴과 달리 프로퍼티 키가 없고 값만 존재한다. const arr_1 = [1, 2, 3]; console.log(arr_1.length); // 3 const arr_2 = []; console.log(arr_2.length); // 0 const arr_3 = [1, , 3]; // 희소배열 console.log(arr_3.length); // 3 console.log(arr_3[1]); // undefinedArray 생성자 함수Array 생성자 함수를 통해 배열을 생성할 수 있다. 단, Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작하므로 주의가 필요하다.- 전달된 인수가 1개이고 숫자인 경우 length 프로퍼티 값이 인수인 배열을 생성한다. 이때 생성된 배열은 희소 배열이다. length 프로퍼티 값은 0 이지만 실제로 배열의 요소는 존재하지 않는다. const arr = new Array(10); console.log(arr); // [ 비어있음 x 10 ] console.log(arr.length); // 10- 전달된 인수가 없는 경우 빈 배열을 생성한다. new Array(); // []- 전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다. 또 Array 생성자 함수는 함수 내부에서 new.target을 확인하기 때문에 new 연산자 없이도 동작한다. new Array(1, 2, 3); // [1, 2, 3] new Array({}); // [{}] Array(1, 2, 3); // [1, 2, 3]Array.ofES6에서 도입된 메서드로 전달된 인수를 요소로 갖는 배열을 생성한다. Array.of는 Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자라도 인수를 요소로 가진다. Array.of(1); // [1]Array.fromArray.of 와 마찬가지로 ES6에서 도입된 메서드이며, 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환해서 반환한다. Array.from({ length: 2, 0: &#39;a&#39;, 1: &#39;b&#39;}); // [&#39;a&#39;, &#39;b&#39;] Array.from(&#39;Hello&#39;); // [&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;] Array.from({ length: 3 }); // [undefined, undefined, undefined] Array.from({ length: 3 }, (_, i) =&amp;gt; i); // [0, 1, 2]Array.from 메서드는 두 번째 인수로 전달한 콜백 함수에 첫 번째 인수에 의해 생성된 배열의 요소값과 인덱스를 순차적으로 전달하면서 호출하고, 콜백 함수의 반환값으로 구성된 배열을 반환한다.요소의 참조배열 요소를 참조할 때에는 대괄호를 사용한다. 대괄호 안에 인덱스를 넣어 참조할 수 있다. 인덱스는 객체의 프로퍼티 키와 같은 역할이다. const arr = [1, 2]; console.log(arr[0]); // 1 console.log(arr[1]); // 2 console.log(arr[2]); // undefined배열은 사실 인덱스를 나타내는 문자열을 프로퍼티 키로 갖는 객체다. 따라서 존재하지 않는 요소를 참조하면 객체와 마찬가지로 undefined를 반환한다.배열 요소의 추가와 갱신배열은 존재하지 않는 인덱스를 사용해 값을 할당하면 새로운 요소가 추가된다. 이때 length 프로퍼티 값은 자동으로 갱신된다. 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 요소를 추가할 경우 희소 배열이 된다. 주의할 점은 값을 명시적으로 할당하지 않으면 요소는 생성되지 않는다. 이미 존재하는 요소에 값을 할당하면 요소값이 갱신된다. const arr = [0]; arr[1] = 1; // 배열 요소의 추가 console.log(arr); // [0, 1] console.log(arr.length); // 2 arr[1] = 10; // 요소값의 갱신 console.log(arr); // [0, 10]인덱스는 요소에 접근할 때 항상 정수를 사용해야 한다. 정수 이외의 값을 인덱스처럼 사용할 경우 요소가 생성되는 것이 아니라 프로퍼티가 생성된다. 이때 추가된 프로퍼티는 length 프로퍼티값에 영향을 주지 않는다.배열 요소의 삭제배열은 객체이기 때문에 delete 연산자를 사용할 수 있다. 하지만 delete 연산자로 배열의 요소를 삭제할 경우 배열은 희소 배열이 되므로 delete 연산자는 사용하지 않는 것이 좋다.희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 Array.property.splice 메서드를 사용하면 된다. 이때 length 프로퍼티 값은 자동으로 갱신된다. const arr = [1, 2, 3]; arr.splice(1, 1); // arr[1]부터 1개의 요소를 제거 console.log(arr); // [1, 3] console.log(arr.length); // 2" }, { "title": "Javascript Array_01", "url": "/posts/array-01/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-20 00:00:00 +0900", "snippet": "배열배열은 여러 개의 값을 순차적으로 나열한 자료구조이다. 자바스크립트에서는 배열을 다루기 위한 유용한 메서드를 다수 제공한다. 배열이 가지고 있는 값은 요소라 부른다. 자바스크립트에서는 원시값, 객체, 함수, 배열 등 자바스크립트에서 값으로 인정한는 모든 것은 배열의 요소가 될 수 있다. 배열의 요소는 자신의 위치를 나타내는 0 이상의 정수인 인덱스를 가진다. const arr = [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;]; console.log(arr[0]); // apple console.log(arr[1]); // banana console.log(arr[2]); // orange또한 배열은 요소의 개수를 나타내는 length 프로퍼티를 갖는다. 자바스크립트에는 배열이라는 타입이 존재하지 않는다. 배열은 객체 타입이다. console.log(arr.length); // 3배열을 배열 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다. 배열의 생성자 함수는 Array이며, 배열의 프로토타입 객체는 Array.prototype이다.배열과 일반객체의 차이는 아래와 같다. 구분 객체 배열 구조 프로퍼티 키와 프로퍼티 값 인덱스와 요소 값의 참조 프로퍼티 키 인덱스 값의 순서 X O length 프로퍼티 X O 값의 순서와 length 프로퍼티는 일반객체와 배열의 가장 큰 차이이다. 두 특성으로 인해 배열은 반복문에 적합한 자료구조를 가진다.자바스크립트에서의 배열자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 연속적으로 나열된 자료구조를 말한다. 배열은 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이런 배열을 밀집 배열 이라 한다.일반적인 의미의 배열은 각 요소가 동일한 크기를 가지고, 연속적으로 이어져 있어 인덱스를 통해 단 한번의 연산으로 임의의 요소에 접근할 수 있다. 이는 매우 효율적이고 고속으로 동작할 수 있는 구조이다.이러한 밀집 배열은 특정 요소를 검색하는 경우 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색해야 하며, 요소를 삽입하거나 삭제할 경우 요소들을 이동시켜야하는 단점이 있다.자바스크립트의 배열은 일반적인 배열과 다르다. 메모리 공간은 동일한 크길를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 이러한 배열을 희소 배열 이라 한다.자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체이다. 자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, length 프로퍼티를 갖는 특수한 객체다.자바스크립트에서 사용할 수 있는 모든 값은 객체 프로퍼티 값이 될 수 있으므로 어떤 타입의 값이라도 배열의 요소가 된다.length 프로퍼티와 희소 배열length 프로퍼티는 요소의 개수를 나타낸다. length 프로퍼티는 빈 배열의 경우 0이며, 빈 배열이 아닌 경우 가장 큰 인덱스에 1을 더한 것과 같다.length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제하면 자동 갱신된다. const arr = [1, 2, 3]; console.log(arr.length); // 3 arr.push(4); console.log(arr); // [1, 2, 3, 4] console.log(arr.length); // 4 arr.pop(); console.log(arr); // [1, 2, 3] console.log(arr.length); // 3length 프로퍼티는 배열의 길이를 바탕으로 결정되지만 임의의 숫자 값을 명시적으로 할당할 수 있다. 현재 length 프로퍼티 값보다 작은 숫자를 할당하면 배열의 길이가 줄어든다.length 프로퍼티 값보다 큰 숫자를 할당할 경우 length 값은 변경되지만 실제로 배열의 길이가 늘어나지 않는다. 자바스크립트에서는 이 경우 값이 비어 있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다. const arr_1 = [1, 2, 3, 4, 5]; // 배열의 길이가 5에서 3으로 줄어들고 넘치는 값은 삭제된다. arr_1.length = 3; console.log(arr_1); // [1, 2, 3] const arr_2 = [1]; // length 프로퍼티 값은 3이 되지만 실제로 배열의 길이가 늘어나진 않는다. // 비어있음 x 2 는 실제로 추가된 배열의 요소가 아니다. arr_2.length = 3; console.log(arr_2.length); // 3 console.log(arr_2); // [1, 비어있음 x 2]이처럼 배열의 요소가 연속되지 않고 일부가 비어있는 배열을 희소 배열 이라 한다. 자바스크립트는 희소 배열을 문법적으로 허용한다. 하지만 희소 배열은 사용하지 않는 것이 좋다. 희소 배열은 배열의 기본 개념에 맞지 않다.배열을 생성할 때 희소 배열을 생성하지 않도록 하자. 배열은 동일한 타입의 요소를 연속적으로 위치시키는 것이 가장 좋다." }, { "title": "Javascript ES6", "url": "/posts/javascript-13/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-17 00:00:00 +0900", "snippet": "함수의 구분ES6 이전의 자바스크립트 함수는 사용 목적에 따라 명확히 구분되지 않는다. 다시말해 callable이면서 constructor이다. 이는 실수를 유발시킬 수 있으며 성능 면에서도 손해다. var foo = function () { return 1; } // 일반적인 함수로서 호출 foo(); // 생성자 함수로서 호출 new foo(); // 메서드로서 호출 var obj = { foo: foo }; obj.foo();이처럼 ES6 이전의 모든 함수는 사용 목적에 따라 명확한 구분이 없으므로 호출 방식에 특별한 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성한다.이는 실수를 유발할 가능성이 있고 성능에도 좋지 않다.ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 구분한다. ES6 함수의 구분 constructor prototype super arguments 일반 함수 O O X O 메서드 X X O O 화살표 함수 X X X X 메서드ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다. const obj = { x: 1, // foo는 메서드 foo() { return this.x; } // bar에 바인딩된 함수는 일반함수 bar: function() { return this.x; } }; console.log(obj.foo()); // 1 console.log(obj.bar()); // 1ES6 사양에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor다. 따라서 ES6 메서드는 생성자 함수로서 호출할 수 없다. ES6 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다. super 참조는 내부 슬롯 [[HomeObject]]를 사용하여 수퍼클래스의 메서드를 참조하므로 ES6 메서드는 super 키워드를 사용할 수 있다. const base = { name: &#39;Roy&#39;, printName() { return `${this.name}`; } }; const derived = { __proto__: base, // printName의 [[HomeObject]]는 printName이 바인딩된 derived를 가리키고 // super는 printName의 [[HomeObject]]의 프로토타입인 base를 가리킨다. printName() { return `${super.printName()}`; } }ES6 메서드가 아닌 함수는 내부 슬롯 [[HomeObject]]를 갖지 않기 때문에 super 키워드를 사용할 수 없다. ES6 메서드는 본연의 기능(super)을 추가하고 의미적으로 맞지 않는 기능(constructor)은 제거했다.화살표 함수화살표 함수는 function 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다. 내부 동작도 기존의 함수보다 간략하다. 특히 화살표 함수는 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다. const foo () =&amp;gt; { ... }화살표 함수에서 함수의 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호를 생략할 수 있다. 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다. const power = x =&amp;gt; x ** 2; // { return x ** 2; } 와 동일 power(2); // 4객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호로 감싸 주어야 한다. 그러지 않으면 객체 리터럴의 중괄호를 함수 몸체로 잘못 해석한다. const foo = (id, content) =&amp;gt; ({ id, content }); foo(1, &#39;Javascript&#39;); // {id: 1, content: &quot;Javascript&quot;} const bar = (id, content) =&amp;gt; { id, content }; bar(1, &#39;Javascript&#39;); // undefined화살표 함수와 일반 함수의 차이는 어떤 것이 있을까?1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor 이다.화살표 함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.2. 중복된 매개변수 이름을 선언할 수 없다.3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.화살표 함수에서의 this화살표 함수는 다른 함수의 인수로 전달되어 콜백 함수로 사용되는 경우가 많다. 화살표 함수의 this는 일반 함수의 this와 다르게 동작한다. 이는 “콜백 함수 내부의 this 문제”를 해결하기 위해 의도적으로 설계된 것이다.“콜백 함수 내부의 this 문제”란 콜백 함수의 this와 외부 함수의 this가 서로 다른 값을 가리키고 있기 때문에 TypeError가 발생하는 것을 말한다. class Prefixer { constructor(prefix) { this.prefix = prefix; } add(arr) { return arr.map(function(item) { return this.prefix + item; // TypeError: Cannot read property &#39;prefix&#39; of undefined }) } }ES6에서는 화살표 함수를 사용하여 “콜백 함수 내부의 this 문제”를 해결할 수 있다. class Prefixer { constructor(prefix) { this.prefix = prefix; } add(arr) { return arr.map(item =&amp;gt; this.prefix + item); } }화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.화살표 함수에서의 super화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다. class Base { constructor(name) { this.name = name; } printName() { reutnr `${this.name}`; } } class Derived extends Base { printName = () =&amp;gt; `${super.printName()}`; } const derived = new Derived(&#39;Roy&#39;); console.log(derived.printName()); // Roy화살표 함수에서의 arguments화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 arguments를 참조하면 this와 마찬가지로 상위 스코프의 arguments를 참조한다. (function () { // 화살표 함수 foo의 arguments는 상위 스코프인 즉시 실행 함수의 arguments를 가리킨다. const foo = () =&amp;gt; console.log(arguments); // [Arguments] {&#39;0&#39;: 1, &#39;1&#39;: 2} foo(3, 4); }(1, 2));Rest 파라미터Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. function foo(....rest) { console.log(rest); } foo(1, 2, 3, 4, 5) // [ 1, 2, 3, 4, 5 ] function bar(param, ...rest) { console.log(param); // 1 console.log(rest); // [ 2, 3, 4, 5 ] } foo(1, 2, 3, 4, 5);Rest 파라미터는 일반 매개변수와 함께 사용할 수 있다. 이때 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당된다. Rest 파라미터는 반드시 마지막 파라미터이어야 한다. 그리고 Rest 파라미터는 단 하나만 선언할 수 있다.ES6 이전에는 함수를 정의할 때 매개변수의 개수를 확장할 수 없는 가변 인자 함수의 경우 매개변수를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받았다. 하지만 arguments의 경우 유사 배열 객체라서 배열 메서드를 사용하려면 Function.prototype.call 이나 Function.prototype.apply 메서드를 사용해 arguments 객체를 배열로 변환하는 번거로움이 있었다.ES6에서는 Rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직업 전달받을 수 있다. ES6에서는 arguments와 Rest 파라미터를 모두 사용할 수 있다. 하지만 화살표 함수에서는 함수 자체의 arguments 객체를 갖지 않으므로 반드시 Rest 파라미터를 사용해야 한다." }, { "title": "Javascript 클래스_02", "url": "/posts/javascript-12/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-15 00:00:00 +0900", "snippet": "클래스의 인스턴스 생성과정new 연사자와 함께 클래스를 호출하면 다음과 같은 과정을 거쳐 인스턴스가 생성된다.1. 인스턴스 생성과 this 바인딩new 연산자와 함께 클래스를 호출하면 constructor 내부 코드가 실행되기 앞서 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 클래스가 생성한 인스턴스이다. 이때 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다. 그리고 암묵적으로 생성된 빈 객체는 this에 바인딩된다. 즉 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다.2. 인스턴스 초기화constructor 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 다시말해 this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화한다.3. 인스턴스 반환클래스의 모든 처리가 끝나면 인스턴스가 바인딩된 this가 암묵적으로 반환된다.프로퍼티 class Person { constructor(name) { this.name = name; // name 프로퍼티는 public 하다 } } const me = new Person(&#39;Lee&#39;); console.log(me); // Person { name: &quot;Lee&quot; }인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다. 생성자 함수에서 생성할 인스턴스의 프로퍼티를 정희하는 것과 마찬가지로 constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다. 이로써 인스턴스에 프로퍼티가 추가되어 인스턴스가 초기화된다.ES6 클래스는 다른 객체지향 언어처럼 private, public, protected 키워드와 같이 접근 제한자를 지원하지 않는다. 인스턴스 프로퍼티는 언제나 public 하다. 다만 private한 프로퍼티를 정의할 수 있는 사양이 현재 제안 중에 있다.접근자 프로퍼티접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다. 접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수, 즉 getter와 setter 함수로 구성되어 있다. class Person { constructor(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; } // getter 함수 get fullName() { return `${this.firstName} ${this.lastName}`; } // setter 함수 set fullName(name) { [this.firstName, this.lastName] = name.split(&#39; &#39;); } } const me = new Person(&#39;Roy&#39;, &#39;Seo&#39;); // 데이터 프로퍼티를 통한 프로퍼티 값 저장 console.log(`${me.firstName} ${me.lastName}`); // Roy Seo // 접근자 프로퍼티를 통한 프로퍼티 값 저장 // 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수 호출 me.fullName = &#39;Roy Park&#39;; console.log(me); // {firstName: &quot;Roy&quot;, lastName: &quot;Park&quot;} // 접근자 프로퍼티를 통한 프로퍼티 값 참조 // 접근자 프로퍼티 fullName에 접근하면 getter 함수 호출 console.log(me.fullName); // Roy Parkgetter은 인스턴스 프로퍼티에 접근할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용한다. setter는 프로퍼티에 값을 할당할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용한다. 이때 getter와 setter 이름은 인스턴스 프로퍼티처럼 사용된다. 즉, getter와 setter는 호출하는 것이 아니라 프로퍼티처럼 참조하는 형식으로 사용하며, 참조 시 내부적으로 getter와 setter가 호출된다.클래스의 메서드는 기본적으로 프로토타입 메서드가 된다. 따라서 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.클래스 필드 정의 제안클래스 필드는 자바스크립트에서 프로퍼티를 말한다. 자바스크립트의 클래스에서는 인스턴스 프로퍼티를 참조하려면 반드시 this를 사용해서 참조해야 한다. 또한 자바스크립트 클래스 몸체에는 메서드만 선언할 수 있다.~하지만 자바스크립트에서도 클래스 기반 객체지향 언어처럼 클래스 필드를 정의할 수 있는 새로운 표준 사양이 제안되었다. 이 부분은 사용하기 전에 다시한번 공식 사이트에서 확인할 것~ class Person { // 클래스 필드 정의 name = &quot;Seo&quot;; } const me = new Person(); console.log(me); // Person {name: &quot;Seo&quot;}클래스 몸체에서 클래스 필드를 정의할 경우 this를 바인딩해서는 안된다. this는 클래스 constructor와 메서드 내에서만 유효하다. 또한 클래스 필드를 참조하는 경우 자바와 같은 클래스 기반 객체지향 언어에서는 this를 생략할 수 있으나 자바스크립트에서는 this를 반드시 사용해야 한다. class Person { name = &quot;Seo&quot;; constructor() { console.log(name); // ReferenceError: name is not defined } } new Person();상속에 의한 클래스 확장상속에 의한 클래스 확장은 지금까지 살펴본 프로토타입 기반 상속과는 다른 개념이다. 프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다. 클래스와 생성자 함수는 인스턴스를 생성할 수 있는 함수라는 점에서 유사하지만, 클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 제공되고 생성자 함수는 그렇지 않다. class Animal { constructor(age, weight) { this.age = age; this.weight = weight; } eat() { return &#39;eat&#39;; } move() { return &#39;move&#39;; } } class Bird extends Animal { fly() { return &#39;fly&#39;; } } const bird = new Bird(1, 5); console.log(bird); // Bird {age: 1, weight: 5} console.log(bird instanceof Bird); // true console.log(bird instanceof Animal); // trueextends 키워드 // 수퍼(베이스/부모) 클래스 class Base {} // 서브(파생/자식) 클래스 class Derived extends Base {}extends 키워드의 역할은 수퍼클래스와 서브클래스 간의 상속 관계를 설정하는 것이다. 클래스도 프로토타입을 통해 상속 관계를 구현한다. 수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인뿐 아니라 클래스 간의 프로토타입 체인도 생성한다. 프로토타입 체인을 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.동적 상속extends 키워드는 클래스뿐만 아니라 생성자 함수, [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다. 이를 통해 동적으로 상속받을 대상을 결정할 수 있다. function Base1() {} class Base2 {} let condition = true; class Derived extends (condition ? Base1 : Base2) {} const derived = new Derived(); console.log(derived); // Derived {} console.log(derived instanceof Base1); // true console.log(derived instanceof Base2); // false서브클래스의 constructor서브클래스에서 constructor를 생략하면 클래스에 다음과 같은 constructor가 암묵적으로 정의된다. constructor(...args) { super(...args); }args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트다.super 키워드super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드다. super를 호출하면 수퍼클래스의 constructor를 호출한다. super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다. - super 호출new 연산자와 함께 서브클래스를 호출하면서 전달된 인수는 모두 서브클래스에 암묵적으로 정의된 constructor의 super 호출을 통해 수퍼클래스의 constructor에 전달된다. // 수퍼클래스 class Base { constructor(a, b) { this.a = a; this.b = b; } } // 서브클래스 class Derived extends Base { // 생략할 경우 암묵적으로 constructor 생성 // constructor(...args) { super(...args); } } const derived = new Derived(1, 2); console.log(derived); // Derived {a: 1, b: 2}만약 서브클래스에서 추가한 프로퍼티를 갖는 인스턴스를 생성한다면 서브클래스의 constructor를 생략할 수 없다. 이때 new 연산자와 함께 서브클래스를 호출하면서 전달한 인수 중에서 수퍼클래스의 constructor에 전달할 필요가 있는 인수는 서브클래스의 constructor에서 호출하는 super를 통해 전달한다. // 수퍼클래스 class Base { constructor(a, b) { this.a = a; this.b = b; } } // 서브클래스 class Derived extends Base { constructor(a, b, c) { super(a, b); this.c = c; } } const derived = new Derived(1, 2, 3); console.log(derived); // Derived {a: 1, b: 2, c: 3}super를 호출할 때 주의할 사항은 다음과 같다. 서브클래스에서 constructor를 생략하지 않는 겨우 서브클래스의 constructor에서는 반드시 super를 호출해야 한다. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다. super는 반드시 서브클래스의 constructor에서만 호출한다. 서브클래스가 아닌 클래스의 constructor나 함수에서 super를 호출하면 에러가 발생한다. - super 참조메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다. // 수퍼클래스 class Base { constructor(name) { this.name = name; } printName() { return `${this.name}`; } } // 서브클래스 class Derived extends Base { printName() { return `${super.printName()}`; } } const derived = new Derived(&#39;Roy&#39;); console.log(derived.printName()); // Roy상속 클래스의 인스턴스 생성 과정 // 수퍼클래스 class Rectangle { constructor(width, height) { this.width = width; this.height = height; } getArea() { return this.width * this.height; } toStrign() { return `width = ${this.width}, height = ${this.height}`; } } // 서브클래스 class ColorRectangle extends Rectangle { constructor(width, height, color) { super(width, height); this.color = color; } //메서드 오버라이딩 toString() { return super.toString() + `, color =${this.color}`; } } const colorRectangle = new ColorRectangle(2, 4, &#39;red&#39;); console.lg(colorRectangle); // ColorRectangle {width: 2, height: 4, color: &quot;red&quot;} // 상속을 통해 getArea 메서드를 호출 console.log(colorRectangle.getArea()); // 8 // 오버라이딩된 toString 메서드를 호출 console.log(colorRectangle.toString()); // width = 2, height = 4, color = red서브클래스 ColorRectangle이 new 연산자와 호출되면 다음 과정을 통해 인스턴스가 생성된다.1. 서브클래스 super 호출자바스크립트 엔진은 클래스를 평가할 때 “base” 또는 “derived”를 값으로 갖는 내부 슬롯 [[ConstructorKind]]를 통해 수퍼클래스와 서브클래스를 구분한다. 다른 클래스를 상속받지 않는 클래스는 new 연산자와 함께 호출되었을 때 암묵적으로 빈 객체인 인스턴스를 생성하고 이를 this에 바인딩한다. 하지만 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 이것이 서브클래스의 constructor에서 반드시 super를 호출해야하는 이유다.2. 수퍼클래스 인스턴스 생성과 this 바인딩수퍼클래스의 constructor 내부의 코드가 실행되기 이전에 암묵적으로 빈 객체가 생성된다. 이 객체는 아직 완성되지 않았지만 클래스가 생성할 인스턴스다. 그리고 이 인스턴스는 this에 바인딩된다. 즉 수퍼클래스 constructor 내부의 this는 생성된 인스턴스를 가리킨다. 인스턴스는 수퍼클래스가 생성한 것이다. 하지만 new 연산자로 호출된 클래스가 서브클래스일 경우 new.target은 서브클래스를 가리킨다. 따라서 인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리된다.3. 수퍼클래스의 인스턴스 초기화수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.4. 서브클래스 constructor로의 복귀와 this 바인딩super의 호출이 종료되고 제어 흐름이 서브클래스의 constructor로 돌아온다. 이때 super가 반환한 인스턴스가 this에 바인딩된다. 서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그래도 사용한다.5. 서브클래스 인스턴스 초기화super 호출 이후 서브클래스의 constructor에 기술되어 있는 인스턴스 초기화가 실행된다.6. 인스턴스 반환클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환한다." }, { "title": "Javascript 클래스_01", "url": "/posts/javascript-11/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-14 00:00:00 +0900", "snippet": "1. Javascript에서의 클래스자바스크립트는 프로토타입 기반 객체지향 언어이다. ES5에서는 클래스 없이도 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다. // ES5 생성자 함수 var Person = (function () { // 생성자 함수 function Persion(name) { this.name = name; } // 프로토타입 메서드 Person.prototype.sayHi = function () { console.log(this.name); }; // 생성자 함수 반환 return Person; }()); // 인스턴스 생성 var me = new Person(&#39;Lee&#39;); me.sayHi();ES6에서 도입된 클래스는 기존의 클래스 기반 객체지향 프로그램과 매우 비슷한 새로운 객체 생성 메커니즘을 제시한다. 하지만 ES6의 클래스는 기존의 프로토타입 기반 객체지향 모델을 폐지한 것은 아니다. 사실 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 것 뿐이다.클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다. 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다. 클래스와 생성자 함수의 차이점은 다음과 같다. 클래스를 new 연자사 없이 호출하면 에러가 발생한다. 하지만 생성자 함수는 new 연산자 없이 호출하면 일반 함수로서 호출된다. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 하지만 생성자 함수는 extends와 super 키워드를 지원하지 않는다. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 ㅎ마수는 변수 호이스팅이 발생한다. 클래스 내의 모든 코드에는 암묵적으로 stric mode가 지정되어 실행되며 stric mode를 해제할 수 없다. 생성자 함수는 암묵적으로 stric mode가 지정되지 않는다. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]] 값이 false이다. 이는 열거되지 않는다. 2. 클래스의 정의클래스는 class 키워드를 사용하여 정의한다. 일반적이지 않지만 함수와 마찬가지로 표현식으로 클래스를 정의할 수도 있다. // 익명 클래스 표현식 const Person = class {}; // 기명 클래스 표현식 const Person = class MyClass {};클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 일급 객체라는 것을 의미한다. 클래스는 일급 객체로서 다음과 같은 특징을 갖는다. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 변수나 자료구조에 저장할 수 있다. 함수의 매개변수에게 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다. 클래서 몸체에서 정의할 수 있는 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드 세 가지가 있다. class Person { // 생성자 constructor(name) { this.name = name; } // 프로토타입 메서드 sayHi() { console.log(this.name); } // 정적 메서드 static sayHello() { console.log(&#39;Hello&#39;); } } // 인스턴스 생성 const me = new Person(&#39;Lee&#39;); // 인스턴스 프로퍼티 참조 console.log(me.name); // 프로토타입 메서드 호출 me.sayHi(); // 정적 메서드 호출 Person.sayHello();3. 클래스 호이스팅글래스는 함수로 평가된다. 그리고 클래스는 클래스 정의 이전에 참조할 수 없다. const Person = &#39;&#39;; { console.log(Person); // ReferenceError: CAnnot access &#39;Person&#39; before initialization class Person {} }클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생한다. 단, 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅 된다. 따라서 클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.var, let, const, function, function*, class 키워드를 사용하여 선언된 모든 식별자는 호이스팅된다.4. 인스턴스의 생성클래스는 new 연산자와 함께 호출되어 인스턴스를 생성한다. class Person {} // 인스턴스 생성 const me = new Person(); console.log(me);클래스는 일반 함수와 다르게 인스턴스를 생성하는 것을 유일한 목적으로 사용하므로 반드시 new 연산자와 함께 호출해야 한다. 만약 new 연산자 없이 class를 호출하면 타입 에러가 발생한다. class Person {} const me = Person(); // TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;5. 메서드클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다. 클래스 몸체에서 정의할 수 있는 메서드는 contructor, 프로토타입 메서드, 정적 메서드가 있다.5-1. constructorconstructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드다. constructor는 이름을 변경할 수 없다. class Person { constructor(name) { this.name = name; } }클래스 몸체에 정의한 constructor는 단순한 메서드가 아니다. constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다. constructor는 생성자 함수와 유사하지만 몇 가지 차이가 있다. constructor는 클래스 내에 최대 한 개만 존재할 수 있다. 2개 이상일 경우 문법 에러가 발생한다. constructor는 생략 가능하다. 생략된 constructor는 빈 constructor가 암묵적으로 정의된다. 인스턴스를 초기화 하려면 constructor를 생략해서는 안된다. constructor 내에서는 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스의 초기화를 실행한다. constructor는 별도의 반환문을 갖지 않아야 한다. new 연산자와 함께 클래스를 호출하면 생성자 함수와 동일하게 암묵적으로 this, 즉 인스턴스를 반환한다. 다른 객체를 명시적으로 반환하면 명시된 객체를 반환하겠지만 이는 클래스의 기본 동작에 맞지 않다. 5-2. 프로토타입 메서드클래스 몸체에서 정의한 메서드는 클래스의 protytype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다. class Person { // 생성자 constructor(name) { this.name = name; } // 프로토타입 메서드 sayHi() { console.log(`${this.name}`); } } const me = new Person(&#39;Lee&#39;); me.sayHi();생성자 함수와 마찬가지로 클래스가 생성한 이스턴스는 프로토타입 체인의 일원이 된다. 결국 클래스는 생성자 함수와 같이 인스턴스를 생성하는 하나의 프로토타입 기반의 객체 생성 메커니즘이다.5-3. 정적 메서드정적 메서드는 인스턴스를 생성하지 않나도 호출할 수 있는 메서드를 말한다. 클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드가 된다. class Person { // 생성자 constructor(name) { this.name = name; } static sayHi() { console.log(&#39;Hi&#39;); } }클래스는 클래스 정의가 평가되는 시점에 함수 객체가 되므로 인스턴스와 달리 별다른 생성 과정이 필요 없다. 따라서 정적 메서드는 클래스 정의 이후 인스턴스를 생성하지 않아도 호출할 수 있다. 정적 메서드는 인스턴스로 호출할 수 없다. 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인상에 존재하지 않기 때문이다. 즉, 인스턴스의 프로토타입 체인 상에는 클래스가 존재하지 않기 때문에 인스턴스로 클래스의 메서드를 상속받을 수 없다.5-4. 클래스에서 정의한 메서드들…정적 메서드와 프로토타입 메서드의 차이는 다음과 같다. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다. 메서드 내부의 this는 메서드를 소유한 객체가 아니라 메서드를 호출한 객체에 바인딩된다. 프로토타입 메서드는 인스턴스로 호출해야 하므로 프로토타입 메서드 내부의 this는 프로토타입 메서드를 호출한 인스턴스를 가리킨다. 정적 메서드는 클래스로 호출해야 하므로 정적 메서드 내부의 this는 인스턴스가 아닌 클래스를 가리킨다. 즉, 프로토타입 메서드와 정적 메서드 내부의 this 바인딩이 다르다.클래스에서 정의한 메서드는 다음과 같은 특징을 가진다. function 키워드를 생략한 메서드 축약 표현을 사용한다. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때 콤마가 필요 없다. 암묵적으로 strict mode로 실행된다. for…in 문이나 Object.keys메서드 등으로 열거할 수 없다. 내부 [[Construct]]를 갖지 않는 non-constructor다. 따라서 new 연산자와 함께 호출할 수 없다. " }, { "title": "배송 API 테스트", "url": "/posts/tracking-api/", "categories": "ETC", "tags": "html, ajax", "date": "2022-06-10 00:00:00 +0900", "snippet": "오늘은 택배 배송조회를 이야기 하려한다. 회사에서 준비 중인 서비스에서 택배 배송조회를 구현해야 해서 택배 배송조회에 대해서 알아보고 직접 API 테스트를 간단히 해보았다.테스트 코드는 HTML, AJAX를 통해서 구현했다. API 서버로 https://tracker.delivery/guide 이 곳을 이용했다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./memo.css&quot; /&amp;gt; &amp;lt;title&amp;gt;TEST&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class=&quot;Box&quot;&amp;gt; &amp;lt;div class=&quot;InputBox&quot;&amp;gt; &amp;lt;h3&amp;gt;배송 API TEST&amp;lt;/h3&amp;gt; &amp;lt;form id=&quot;searchForm&quot; class=&quot;InputForm&quot;&amp;gt; &amp;lt;input id=&quot;trackNum&quot; type=&quot;number&quot; placeholder=&quot;송장번호&quot;&amp;gt; &amp;lt;select id=&quot;carrierList&quot;&amp;gt;&amp;lt;/select&amp;gt; &amp;lt;button id=&quot;searchButton&quot; type=&quot;button&quot;&amp;gt;조회&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;OutputBox&quot;&amp;gt; &amp;lt;textarea id=&quot;responseData&quot; cols=&quot;20&quot; rows=&quot;10&quot;&amp;gt;&amp;lt;/textarea&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const selectBox = document.getElementById(&quot;carrierList&quot;); const responseData = document.getElementById(&quot;responseData&quot;); $.ajax({ type: &quot;get&quot;, url: &quot;https://apis.tracker.delivery/carriers&quot;, data: &quot;&quot;, dataType: &#39;json&#39;, success: function(data) { console.log(data); for(let i = 0; i &amp;lt; data.length; i++){ let carrierData = document.createElement(&quot;option&quot;); carrierData.text = data[i].name; carrierData.value = data[i].id; selectBox.options.add(carrierData); } }, error: function(request, status, error) { console.log(&quot;code:&quot; + request.status + &quot;\\n&quot; + &quot;message:&quot; + request.responseText + &quot;\\n&quot; + &quot;error:&quot; + error); } }); $(function(){ $(&#39;#searchButton&#39;).on(&quot;click&quot;,function(){ let selectedCarrier = document.getElementById(&quot;carrierList&quot;).value; let trackNum = document.getElementById(&quot;trackNum&quot;).value; console.log(selectedCarrier); console.log(trackNum); $.ajax({ type: &quot;get&quot;, url: &quot;https://apis.tracker.delivery/carriers/&quot; + selectedCarrier + &quot;/tracks/&quot; + trackNum, data: &quot;&quot;, dataType: &#39;json&#39;, success: function(data) { console.log(data); let string = &#39;&#39;; string += &quot;From:&quot; + JSON.stringify(data.from.name) + &quot;\\r\\n&quot;; string += &quot;State:&quot; + JSON.stringify(data.state.text) + &quot;\\r\\n&quot;; string += &quot;To:&quot; + JSON.stringify(data.to.name) + &quot;\\r\\n&quot;; console.log(string); responseData.innerHTML = string; }, error: function(request, status, error) { console.log(&quot;code:&quot; + request.status + &quot;\\n&quot; + &quot;message:&quot; + request.responseText + &quot;\\n&quot; + &quot;error:&quot; + error); } }); }); }); &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;처음에는 몇 가지 택배사만 직접 구현을 해보려 했다. 하지만 생각보다 많이 귀찮았다. 직접 구현을 한다면 해당 택배사의 API 요청, 개발자 가입, CORS 등등 이슈가 좀 있었다. 그래서 무료로 사용할 수 있는 API 서버를 통해 테스트를 진행했다.테스트는 무료 API 서버를 이용했지만 서비스에 적용한다면 스마트택배 API 라는 좋은 유료 서비스가 있다. 유료 서비스니 서버 안정성이나 개발 중 기술지원에 유리하지 않을까? 싶다." }, { "title": "Javascript 클로저", "url": "/posts/javascript-10/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-09 00:00:00 +0900", "snippet": "MDN에서는 클로저에 대해 다음과 같이 정의하고 있다. “A closure is the combination of a function and the lexical environment within which that function was declared.”핵심 키워드는 함수가 선언된 렉시컬 환경이다.렉시컬 스코프자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다. const x = 1; function foo() { const x = 10; bar(); } function bar() { console.log(x); } foo(); // 1 bar(); // 1함수의 상위 스코프는 함수를 어디서 정의했느냐에 따라 결정된다. 함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 주지 못한다. 즉, 함수의 상위 스코프는 함수를 정의한 위치에 의해 정적으로 결정되고 변하지 않는다.렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수의 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다. 이것이 렉시컬 스코프다.클로저와 렉시컬 환경 const x = 1; function outer() { const x = 10; const inner = function() { console.log(x); }; return inner; } const innerFunc = outer(); innerFunc(); // 10위 예제에서 outer 함수를 호출하면 중첩함수인 inner를 반환하고 outer 함수는 생명 주기를 마감한다. 즉, outer 함수의 실행이 종료되면 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다. 이때 outer 함수의 실행 컨텍스트가 제거되었으니 outer 함수의 지역 변수 x 또한 생명 주기를 마감한다.그러나 위 코드의 결과는 outer 함수의 지역 변수 x의 값인 10이다. 실행 컨텍스트 스택에서 제거된 outer 함수의 지역 변수 x는 정상적으로 동작하고 있다.이처럼 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라 부른다.예제에서 outer 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거되어도 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다. outer 함수의 렉시컬 환경은 inner 함수의 Environment 내부 슬롯에 의해 참조되고 있고 inner 함수는 전역 변수 innerFunc에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않기 때문이다. 가비지 컬렉터는 누군가 참조하고 있는 메모리 공간을 함부로 해제하지 않는다.자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다. 하지만 모든 함수를 클로저라 하지 않는다. 다음 예제들을 통해 클로저를 좀 더 확실히 구분할 수 있을 것이다. function foo() { const x = 1; const y = 2; function bar() { const z = 3; console.log(z); } return bar; } const bar = foo(); bar();중첩 함수 bar는 외부 함수 foo보다 더 오래 유지되지만 상위 스코프의 어떤 식별자도 참조하지 않는다. 이런 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다. 따라서 bar 함수는 클로저라 할 수 없다. function foo() { const x = 1; function bar() { console.log(x); } bar(); } foo();위 예제에서는 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 있으므로 클로저다. 하지만 foo의 외부로 중첩 함수 bar가 반환되지 않는다. 즉, 외부 함수 foo보다 중첩 함수 bar의 생명 주기가 짧다. 이 경우 중첩 함수 bar는 클로저지만 외부 함수보다 일찍 소멸되기 때문에 생명 주기가 종료된 외부 함수의 식별자를 참조할 수 있다는 클로저의 본질에 부합하지 않는다. 따라서 중첩 함수 bar는 일반적으로 클로저라 하지 않는다. function foo() { const x = 1; const y = 2; function bar() { console.log(x); } return bar; } const bar = foo(); bar();위 예제의 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 있으므로 클로저다. 그리고 외부 함수의 외부로 반환되어 외부 함수보다 더 오래 살아 남는다. 이처럼 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라 부른다. 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다. 그리고 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수라고 부른다. 클로저란 자유 변수에 묶여있는 함수이다.클로저의 활용클로저는 State를 안전하게 변경하고 유지하기 위해 사용한다. State가 의도치 않게 변경되지 않도록 State를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다. let num = 0; const increase = function () { return ++num; }; console.log(increase()); // 1 console.log(increase()); // 2 console.log(increase()); // 3위 코드는 잘 동작하지만 오류를 발생기킬 가능성을 내포하고 있다. 그 이유는 다음과 같다. 카운트 상태(num의 값)는 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다. 카운트 상태는 increase 함수만이 변경할 수 있어야 한다. 예제에서는 num이 전역 변수라 누구나 접근이 가능하다. 따라서 num을 increase 함수의 지역 변수로 변경해야 한다. const increase = function () { let num = 0; return ++num; }; console.log(increase()); // 1 console.log(increase()); // 1 console.log(increase()); // 1이제 num은 increase를 통해서만 접근이 가능하다. 하지만 지금의 num은 increase가 호출될 때 마다 0으로 초기화되기 때문에 언제나 1이 출력된다. 여기서 이전 상태를 유지할 수 있도록 클로저를 사용한다. const increase = (function () { let num = 0; return function () { return ++num; }; }()); console.log(increase()); // 1 console.log(increase()); // 2 console.log(increase()); // 3 위 코드가 실행되면 즉시 실행 함수가 호출되고 즉시 실행 함수가 반환한 함수가 increase 변수에 할당된다. increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저 함수다.즉시 실행 함수는 호출된 이후 소멸되지만 즉시 실행 함수가 반환한 클로저는 increase 변수에 할당되어 호출된다. 이때 즉시 실행 함수가 반환한 클로저는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하고 있다. 따라서 즉시 실행 함수가 반환한 클로저는 카운트 상태를 유지하기 위한 자유 변수 num을 참조하고 변경할 수 있다.클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.클로저 사용 시 주의할 점 var funcs = []; for (var i = 0; i &amp;lt; 3; i++) { funcs[i] = function () { return i; }; } for (var j = 0; j &amp;lt; funcs.length; j++) { console.log(funcs[j]()); }for 문의 변수 선언에서 var 키워드로 선언한 i 변수는 블록 레벨 스코프가 아닌 함수 레벨 스코프를 갖기 때문에 전역 변수다. 따라서 funcs 배열의 요소로 추가된 3개의 함수가 0, 1, 2를 반환할 것으로 예상하지만 i의 값 3이 세 번 출력된다. funcs 배열에 추가되는 함수가 클로저로 사용되기 위해서는 for 문이 반복될 때 마다 독립적인 렉시컬 환경을 생성하여 식별자 값을 유지해야 한다.위 예제의 문제는 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상이다. 이 문제는 ES6의 let 키워드를 사용하면 해결할 수 있다. const funcs = []; for (let i = 0; i &amp;lt; 3; i++) { funcs[i] = function () { return i; }; } for (let i = 0; i &amp;lt; funcs.length; i++) { console.log(funcs[i]()); }이처럼 let 이나 const 키워드를 사용하는 반복문(for, for…in, for…of, while 등)은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 마치 스탭샷처럼 저장한다. 단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 후 아무도 사용하지 않기 때문에 가비지 컬렉션의 대상이 된다." }, { "title": "Javascript this", "url": "/posts/javascript-09/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-06 00:00:00 +0900", "snippet": "객체는 상태(state)를 나타내는 프로퍼티와 동작(behavior)을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료구조이다. 동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다. 이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.1. this 키워드this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. this는 자바스크립트 엔진에 의해 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. 단, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다. // 객체 리터럴 const circle = { radius: 5, getDiameter() { // this는 메서드를 호출한 객체를 가리킨다. return 2 * this.radius; } }; console.log(circle.getDiameter()); // 10 // 생성자 함수 function Circle(radius) { // this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; } Circle.prototype.getDiameter = function () { // this는 생성자 함수가 생성할 인스턴스를 가리킨다. return 2 * this.radius; }; // 인스턴스 생성 const circle = new Circle(5); console.log(circle.getDiameter()); // 10자바나 C++ 같은 클래스 기반 언어에서 this는 언제나 클래스가 생성하는 인스턴스를 가리킨다. 하지만 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다. //전역에서 this는 전역 객체 window를 가리킨다. console.log(this); // window function square(number) { // 일반 함수 내부에서 this는 전역 객체 window를 가리킨다. console.log(this); // window return number * number; } square(2); const person = { name: &#39;Lee&#39;, getName() { // 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다. console.log(this); // { name: &quot;Lee&quot;, getName: f } return this.name; } }; console.log(person.getName()); // Lee function Person(name) { this.name = name; // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다. console.log(this); // Person { name: &quot;Lee&quot; } } const me = new Person(&quot;Lee&quot;);2. 함수 호출 방식에 따른 this 바인딩this 바인딩은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 일반 함수 호출 메서드 호출 생성자 함수 호출 Funtion.prototype.apply/call/bind 메서드에 의한 간접 호출 // this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다. const foo = function() { console.dir(this); }; // 1. 일반 함수 호출 // this는 전역 객체 window를 가리킨다. foo(); // window // 2. 메서드 호출 // this는 메서드를 호출한 객체 obj를 가리킨다. const obj = { foo }; obj.foo(); // obj // 3. 생성자 함수 호출 // this는 생성자 함수가 생성한 인스턴스를 가리킨다. new foo(); // foo {} // 4. Funtion.prototype.apply/call/bine 메서드에 의한 간접 호출 // this는 인수에 의해 결정된다. const bar = { name: &#39;bar&#39; }; foo.call(bar); // bar foo.apply(bar); // bar foo.bind(bar)(); // bar 함수 호출 방식 this 바인딩 일반 함수 호출 전역 객체 메서드 호출 메서드를 호출한 객체 생성자 함수 호출 생성자 함수가 생성할 인스턴스 Funtion.prototype.apply/call/bind 메서드에 의한 간접 호출 Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 " }, { "title": "Javascript 빌트인 객체", "url": "/posts/javascript-08/", "categories": "Javascript", "tags": "javascript", "date": "2022-06-03 00:00:00 +0900", "snippet": "자바스크립트 객체 분류 표준 빌트인 객체 : ECMAScript 사양에 정의되어 있는 객체로, 자바스크립트 실행환경과 관계없이 언제나 사용할 수 있다. 표준 빌트인 객체는 전역 객체의 프로퍼티로 제공되어 별도의 선언 없이 전역 변수처럼 사용이 가능하다. 호스트 객체 : 자바스크립트 실행 환경(브라우저 또는 Node.js 같은)에서 추가로 제공되는 객체를 말한다. 사용자 정의 객체 : 사용자가 직접 정의한 객체를 말한다. 표준 빌트인 객체자바스크립트는 Object, String, Number… 등의 40여 개의 표준 빌트인 객체를 제공한다. Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다. 생성자 함수 객체인 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다. // Number 생성자 함수에 의한 Number 객체 생성 const numObj = new Number(1.5); // toFixed는 Number.prototype의 프로토 타입 메서드 console.log(numObj.toFixed()); // 2 // isInteger는 Number 정적 메서드 console.log(Number.isInteger(0.5)); // false원시값과 래퍼 객체원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 객체처럼 동작한다. const str = &#39;hello&#39;; console.log(str.length); // 5 console.log(str.toUpperCase()); // HELLO원시값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법으로 접근하면, 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 준다. 원시값을 객체처럼 접근하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다.ES6에 새로 도입된 Symbol도 래퍼 객체를 생성한다. 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용할 수 있어 String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출해서 인스턴스를 생성할 필요가 없고, 권장되지 않는다.문자열, 숫자, 불리언, 심벌 이외의 원시값인 null과 undefined는 래퍼 객체를 생성하지 않는다. 따라서 null과 undefined 값을 객체처럼 사용하면 에러가 발생한다.전역 객체전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않는 최상위 객체이다.전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 전역 객체의 특징은 다음과 같다. 전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다. 전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다. // var 키워드로 선언한 전역 변수 var foo = 1; console.log(window.foo); // 1 // bar는 전역 변수가 아니라 전역 객체 프로퍼티 bar = 2; console.log(window.bar); // 2 // 전역 함수 function baz() { return 3; } console.log(window.baz()); // 3var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. let foo = 123; console.log(window.foo); // undefinedlet이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다.빌트인 전역 프로퍼티빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다. 주로 앱 전역에서 사용하는 값을 제공한다. Infinity : 무한대를 나타내는 숫자값 Infinity를 갖는다. console.log(window.Infinity === Infinity); // true console.log(typeof Infinity); // number NaN : 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. console.log(window.NaN); // NaN console.log(Number(&#39;aaa&#39;)); // NaN console.log(typeof NaN); // number undefined : 원시타입 undefined를 값으로 갖는다. console.log(window.undefined); // undefined var foo; console.log(foo); // undefined console.log(typeof undefined); // undefined빌트인 전역 함수빌트인 전역 함수는 앱 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 매서드이다. eval : 자바스크립트 코드를 나타내는 문자열을 인수로 전달받는다. /** * 주어진 문자열 코드를 런타임에 평가 또는 실행 * @param {string} code - 코드를 나타내는 문자열 * @returns {*} - 문자열 코드를 평가/실행한 결과값 */ // 표현식인 문 eval(&#39;1 + 2;&#39;); // 3 // 표현식이 아닌 문 eval(&#39;var x = 5;&#39;); // undefinedeval 함수를 통해 사용자로부터 입력받은 컨텐츠를 실행하는 것은 보안에 매우 취약하다. 또한 eval 함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드 실행에 비해 처리 속도가 느리다. 따라서 eval 함수의 사용은 금지해야 한다. isFinite : 전달받은 인수가 유한수면 true, 무한수면 false를 반환하고, 인수가 숫자타입이 아니면 숫자로 변환 후 검사를 수행한다. 이때 인수가 NaN으로 평가되면 false를 반환한다. /** * 전달받은 인수가 유한수인지 확인하고 그 결과를 반환한다. * @param {number} testValue - 검사 대상 값 * @returns {boolean} - 유한수 여부 확인 결과 */ isFinite(0); // true isFinite(2e53); // true isFinite(&#39;10&#39;); // true isFinite(Infinity); // false isFinite(NaN); // false isNaN : 전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다. 전달받은 인수가 숫자가 아닌 경우 숫자로 타입을 변환하여 검사를 수행한다. /** * 주어진 숫자가 NaN인지 확인하고 그 결과를 반환 * @param {number} testValue - 검사 대상 값 * @returns {boolean} - NaN 여부 확인 결과 */ isNaN(NaN); // true inNaN(10); // false isNaN(&#39;10&#39;); // false isNaN(&#39;&#39;); // false &#39;&#39; =&amp;gt; 0 isNaN(true); // false true =&amp;gt; 1 isNaN(null); // false null =&amp;gt; 0 parseFloat : 전달받은 문자열 인수를 부동 소숫점으로 반환한다. 실수로 변환할 수 없다면 NaN을 반환한다. parseInt : 전달받은 문자열 인수를 정수로 반환한다. " }, { "title": "Javascript 일급 객체", "url": "/posts/javascript-07/", "categories": "Javascript", "tags": "javascript", "date": "2022-04-22 00:00:00 +0900", "snippet": "일급 객체일급 객체는 다음 조건을 만족하는 객체를 말한다. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 변수나 자료구조에 저장할 수 있다. 함수의 매개변수에 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 자바스크립트의 함수는 위 조건을 만족하므로 일급 객체이다. 따라서 함수는 함수의 매개변수로 전달할 수 있고, 반환값으로도 사용할 수 있다. 이러한 특징은 함수형 프로그래밍을 가능하게 한다.함수는 객체이지만 일반 객체와는 차이가 있다. 함수는 호출할 수 있으며 일반 객체에는 없는 고유의 프로퍼티를 소유한다.함수 객체의 프로퍼티 function foo() { var x = &#39;local&#39;; console.log(x); } console.log(Object.getOwnPropertyDescriptors(foo)); /* { arguments: { value: null, writable: false, enumerable: false, configurable: false }, caller: { value: null, writable: false, enumerable: false, configurable: false }, length: { value: 0, writable: false, enumerable: false, configurable: true }, name: {value: &#39;foo&#39;, writable: false, enumerable: false, configurable: true}, prototype: {value: {…}, writable: true, enumerable: false, configurable: false} } */함수는 arguments, caller, length, name, prototype이라는 프로퍼티를 가진다. 이 프로퍼티는 일반 객체에는 없는 고유의 프로퍼티이다. arguments 프로퍼티arguments 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용된다. arguments 객체는 함수의 인수를 프로퍼티 값으로 소유하며 arguments 객체의 length 프로퍼티는 인수의 개수를 가리킨다.자바스크립트에서 함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined 또는 초기화된 이후 인수가 할당된다. 만약 함수에 인수를 적게 전달하면 인수가 전달되지 않은 매개변수는 undefined로 초기화된 상태를 유지한다. 그리고 매개변수보다 인수를 더 많이 전달할 경우 초과된 인수는 무시한다.선언된 매개변수의 개수와 함수를 호출할 때 전달하는 인수의 개수를 확인하지 않는 자바스크립트의 특성 때문에 함수가 호출되면 인수 개수를 확인하고 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다. arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 용의하다. // ES6 이전 function sum() { let res = 0; for (let i =0; i &amp;lt; arguments.length; i++) { res += arguments[i]; } return res; } console.log(sum()); // 0 console.log(sum(1, 2)); // 3 console.log(sum(1, 2, 3)); // 6arguments 객체는 유사 배열 객체이지 배열이 아니다. 따라서 배열 메서드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용해 간접 호출해야 한다. 이런 번거로움을 해결하기 위해 ES6에서는 Rest 파라미터를 도입했다. // ES6 Rest parameter function sum(...args) { return args.reduce((pre, cur) =&amp;gt; pre + cur, 0); } console.log(sum(1, 2)); // 3 console.log(sum(1, 2, 3)); // 6 length 프로퍼티함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다. 여기서 arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티는 다를 수 있음에 주의하자.arguments 객체의 length 프로퍼티는 인자의 개수를 가리키고, 함수 객체의 length 프로퍼티는 매개 변수의 개수를 가리킨다. name 프로퍼티함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. name 프로퍼티는 ES6에서 정식 표준이 되었다. 익명 함수에 있어서 ES5에서 name 프로퍼티는 빈 문자열을 값으로 가지지만 ES6에서는 함수 객체를 가리키는 식별자를 값으로 가진다. var anonymousFunc = function() {}; console.log(anonymousFunc.name); // anonymousFunc" }, { "title": "Javascript 생성자 함수", "url": "/posts/javascript-06/", "categories": "Javascript", "tags": "javascript", "date": "2022-04-20 00:00:00 +0900", "snippet": "자바스크립트에서는 객체를 생성하는 다양한 방법을 제공한다. 객체를 생성할 때 객체 리터럴을 통해 생성하는 것이 일반적이지만 생성자 함수를 통해 객체를 생성하는 방법도 있다. // 빈 객체 생성 const person = new Object(); // 프로퍼티 추가 person.name = &#39;Lee&#39;; person.sayHello = function () { console.log(&#39;Hello&#39; + this.name); }; console.log(person); // { name: &quot;Lee&quot;, sayHello: f } person.sayHello(); // Hello Lee생성자 함수를 통해 생성된 객체는 인스턴스(Instance)라 한다. 자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 생성자 함수를 제공한다.생성자 함수객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하지만 단 하나의 객체만 생성하기 때문에 동일한 프로퍼티를 가지는 객체를 여러 개 생성할 경우 매번 같은 프로퍼티를 기술해야 한다. const circle1 = { radius: 5, getDiameter() { return 2 * this.radius; } }; const circle2 = { radius: 10, getDiameter() { return 2 * this.radius; } }; console.log(circle1.getDiameter()); // 10 console.log(circle2.getDiameter()); // 20생성자 함수로 객체를 생성할 경우 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. // 생성자 함수 function Circle(radius) { // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function() { return 2 * radius; }; } // 인스턴스 생성 const circle1 = new Circle(5); const circle2 = new Circle(10); console.log(circle1.getDiameter()); // 10 console.log(circle2.getDiameter()); // 20this 키워드는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 *자기 참조 변수 이다. this가 가리키는 값은 함수 호출 방식에 따라 동적으로 결정된다. 함수 호출 방식 this가 가리키는 값 일반 함수로서 호출 전역 객체 메서드로서 호출 메서드를 호출한 객체(마침표 앞의 객체) 생성자 함수로서 호출 생성자 함수가 생성할 인스턴스 생성자 함수는 객체를 생성하는 함수이다. 자바스크립트는 클래스 기반 객체 지향 언어와 다르게 생성자의 형식이 정해져 있지 않고, 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.인스턴스 생성 과정생성자 함수의 동작은 인스턴스 생성과 인스턴스 초기화로 구분할 수 있다. 자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. function Circle(radius) { // 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; }; // 3. 암묵적으로 this를 반환한다. } const circle = new Circle(1); console.log(circle); // 2인스턴스를 반환할 때 this가 아닌 다른 객체를 명시적으로 반환하면 this가 아닌 명시된 객체가 반환된다. 하지만 명시적으로 원시 값을 반환할 경우 원시 값은 무시되고 this가 반환된다.생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손하는 행위이다. 따라서 생성자 함수에서는 반드시 return문을 생략해야 한다." }, { "title": "Javascript 스코프", "url": "/posts/javascript-05/", "categories": "Javascript", "tags": "javascript", "date": "2022-04-19 00:00:00 +0900", "snippet": "스코프란?모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 스코프는 식별자가 유효한 범위를 말한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 코드의 문맥을 고려하여 결정한다. var x = &#39;global&#39;; function foo() { var x = &#39;local&#39;; console.log(x); } foo(); // local console.los(x); // global var 키워드의 중복 선언var 키워드는 같은 스코프 내에서 중복 선언이 허용된다. 이때는 변수값이 재할당되어 변경된다. function foo() { var x = 1; var x = 2; // var 키워드가 없는 것처럼 동작한다. console.log(x); } foo(); // 2 function bar() { let x = 1; let x = 2; // SyntaxError: Identifier &#39;x&#39; has already been declared } bar();스코프 체인스코프는 전역과 지역으로 나누어 진다. 전역은 코드의 가장 바깥 영역을 말한다. 전역에 선언한 변수는 전역 변수가 된다. 전역 변수는 어디서든 참조할 수 있다. 지역은 함수 몸체 내부를 말한다. 지역에 선언한 변수는 지역 변수가 되어 자신의 지역 스코프와 하위 지역 스코프에서 참조할 수 있다.함수는 전역에서 정의할 수도 있고 함수 내부에서 정의할 수도 있다. 이것을 함수의 중첩이라 한다. 함수가 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다. 이 말은 스코프가 계층 구조를 갖는다 는 의미이다. 스코프가 계층적으로 연결된 것을 스코프 체인 이라 한다.자바스크립트 엔진은 스코프 체인을 통해서 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프로 이동하면서 선언된 변수를 검색한다. 따라서 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수는 상위 스코프에서 참조할 수 없다.함수 레벨 스코프스코프에서 지역은 함수 몸체 내부를 말한다. 즉 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 뜻이다. C나 Java의 경우 코드 블록이 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프라 한다. 하지만 자바스크립트에서 var로 선언된 변수는 오로지 함수의 코드 블록에서만 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라 한다. var i = 10; // i는 중복 선언이 되어 값이 재할당 된다. for(var i = 0; i &amp;lt; 5; i++) { console.log(i); } console.log(i); //5var 키워드는 오로지 함수의 코드 블록만을 지역 스코프로 인정하지만 ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원한다. var 쓰지말자…렉시컬 스코프 var x = 1; function foo() { var x = 10; bar(); } function bar() { console.log(x); } foo(); // 1 bar(); // 1bar()의 실행 결과는 bar 함수의 상위 스코프에 따라 결정된다. 동적 스코프 : 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정 렉시컬 스코프(정적 스코프) : 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 어떤 영향도 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다." }, { "title": "Javascript 함수", "url": "/posts/javascript-04/", "categories": "Javascript", "tags": "javascript", "date": "2022-04-17 00:00:00 +0900", "snippet": "함수함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것 이다. Javascript에서 함수는 객체 타입의 값이며, 함수 리터럴로 생성할 수 있다. var f = function add(x, y) { return x + y; };함수는 객체지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 Javascript의 중요한 특징이다. 나중에 일급 객체를 포스팅할 때 자세히 알아보자.함수의 정의Javascript에서는 함수를 4가지 방법으로 정의할 수 있다. 함수 선언문 function add(x, y) { return x + y; }함수 선언문은 함수의 이름을 생략할 수 없다. 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. 이 말은 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다는 의미다. 그렇다면 함수를 호출할 때 함수명으로 호출하는 경우는 무엇일까? Javascript 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵저으로 생성하고, 거기에 함수 객체를 할당한다. 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출되는 것이다. 함수 표현식 var add = function(x, y) { return x + y; };Javascript 함수는 객체 타입의 값이다. 즉, 값처럼 변수에 할당할 수 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 일급 객체 라 한다. 함수 리터럴의 함수는 이름을 생략할 수 있으며, 이런 함수를 익명 함수라 한다. Function 생성자 함수 var add = new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;); 화살표 함수(ES6) var add = (x, y) =&amp;gt; x + y;함수 생성 시점과 함수 호이스팅함수 선언문과 함수 표현식은 비슷하게 보이지만 중요한 차이가 있다. 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다는 점이다. // 함수 참조 console.dir(add); // f add(x, y) console.dir(sub); // undefined // 함수 호출 console.log(add(2,5)); // 7 console.log(sub(2,5)); // TypeError: sub in not a function // 함수 선언문 function add(x, y) { return x + y; } // 함수 표현식 var sub = function(x, y) { return x - y; }모든 선언문이 그렇듯 함수 선언문도 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 즉, 함수 선언문으로 만들어진 함수는 함수 선언문 이전에 함수를 참조하거나 호출할 수 있다. 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 특징을 함수 호이스팅이라 한다.함수 호이스팅과 변수 호이스팅도 차이가 있다. var 키워드로 선언된 변수의 경우 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다. 따라서 var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만 함수 선언문으로 정의된 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.함수 표현식은 변수에 할당되는 값이 함수 리터럴이다. 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다는 점을 주의하자.콜백 함수함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차함수라 한다.콜백 함수는 외부에서 고차 함수 내부로 주입되는 구조이기 때문에 자유록게 교체할 수 있다는 장점이 있다.콜백 함수는 함수형 프로그래밍뿐만 아니라 비동기 처리(이벤트, Ajax, 타이머 등)에 활용되는 중요한 패턴이다. document.getElementById(&#39;myButton&#39;).addEventListener(&#39;click&#39;, function(){ console.log(&#39;button clicked!&#39;); }); setTimeout(function(){ console.log(&#39;1초 경과&#39;); }, 1000);순수 함수와 비순수 함수함수형 프로그래밍에서 함수는 어떤 외부 상태에 의존하지도 않는 순수 함수와 외부 상태에 의존하거나 외부 상태를 변경하는 비순수 함수로 구분된다. var count = 0; // 순수 함수 function increase(n) { return ++n; } // 비순수 함수 function decrease() { return count--; }함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 최대한 비수순 함수를 지양해야 한다. 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다. 로직 내 조건문과 반복문을 제거해서 복잡성을 낮추고, 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다." }, { "title": "Javascript 원시 값과 객체", "url": "/posts/javascript-03/", "categories": "Javascript", "tags": "javascript", "date": "2022-04-15 00:00:00 +0900", "snippet": "Javascript에서의 객체Javascript에서 데이터 타입은 크게 두 가지로 구분할 수 있다. 원시타입 : number, string, boolean, undefined, null, symbol(ES6에서 추가됨) 객체타입 : 객체, 함수, 배열 등Javascript에서는 원시 값을 제외한 나머지 값은 모두 객체다. 원시 타입은 단하나의 값만 나타내지만 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조이다.객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키(key)와 값(value)으로 구성된다. Javascript에서 사용하는 모든 값은 프로퍼티가 될 수 있다. 따라서 함수도 프로퍼티 값으로 사용할 수 있으며, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다. var counter = { // 객체 리터럴 num: 0, // 프로퍼티 increase: function () { // 메서드 this.num++; } }원시 값과 객체의 비교원시 값과 객체는 크게 세 가지 측면에서 다르다.1. 원시 값은 변경 불가능한 값이다. 객체 타입의 값은 변경 가능한 값이다.2. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체는 변수에 할당하면 변수에는 참조 값이 저장된다.3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 객체는 원본의 참조 값이 복사되어 전달된다.한번 생성된 원시 값은 읽기 전용 값으로서 변경할 수 없다. 이 말은 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 뜻이 아니다. 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다. 변수가 재할당되는 과정을 생각해 보자. 새로운 값이 재할당될 때 값은 새로운 메모리 영역에 저장되고 변수명, 즉 식별자가 새로운 메모리 영역에 연결이된다. 따라서 처음 생성된 원시 값은 그대로 있다. 이러한 원시 값의 불변성은 데이터의 신뢰성을 보장한다. var score = 80; // copy 변수에는 score 변수의 값 80이 복사되어 할당된다. var copy = score; console.log(score, copy); // 80 80 console.log(score === copy); // true score = 100; console.log(score, copy); // 100 80 console.log(score === copy); // false이때 score 변수와 copy 변수는 숫자 값 80을 갖는다는 점에서 동일하지만, score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다. 즉, score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.객체의 경우는 어떨까? 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가/삭제가 가능하다. 또 프로퍼티의 값에는 제약이 없다. 따라서 객체는 원시 값과 다르게 메모리 공간을 사전에 정해 둘 수 없다. 이러한 객체의 특성상 객체는 변경 가능한 값을 가진다. 객체는 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체이다.객체는 메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되었다. 이러한 구조적 특성으로 인해 주의할 점이 있다. 객체는 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다. var person = { name : &#39;Lee&#39; }; var copy = person; // 참조 값을 복사(shallow copy) console.log(copy === person); // true copy.name = &#39;Kim&#39;; person.address = &#39;Seoul&#39;; console.log(person); // {name: &#39;Kim&#39;, address: &#39;Seoul&#39;} console.log(copy); // {name: &#39;Kim&#39;, address: &#39;Seoul&#39;}copy와 person은 각각의 식별자로 동일한 객체를 가리킨다. 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.얕은 복사(shallow copy)와 깊은 복사(deep copy)객체의 경우 얕은 복사와 깊은 복사가 있다. const o = { x: { y : 1 }}; //shallow copy const c1 = { ...o }; // 스프레드 연산자 console.log(c1 === o); // false console.log(c1.x === o.x); // true //deep copy const _ = require(&#39;loadsh&#39;); const c2 = _.cloneDeep(o); console.log(c2 === o); // false console.log(c2.x === o.x); // false얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.얕은 복사와 깊은 복사는 스레레드 연산자를 공부할 때 좀더 깊이 알아보자." }, { "title": "Javascript 타입 변환과 단축 평가", "url": "/posts/javascript-02/", "categories": "Javascript", "tags": "javascript", "date": "2022-04-14 00:00:00 +0900", "snippet": "타입 변환값 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅 이라 한다. var x = 10; // 명시적 타입 변환 var str = x.toString(); console.log(typeof str, str); // string 10 console.log(typeof x, x) // number 10Javascript에서는 개발자의 의도와 상관없이도 암묵적으로 타입이 변환되기도 한다. 이를 암묵적 타입 변환 또는 타입 강제 변환 이라 한다. var x = 10; // 암묵적 타입 변환 var str = x + &#39;&#39;; console.log(typeof str, str); // string 10 console.log(typeof x, x); // number 10위 코드에서 암묵적 타입 변환이 일어나는 과정에서 변수 x의 값은 숫자 10에서 문자 ‘10’으로 새로운 값을 만든 후 표현식 ‘10’ + ‘‘를 평가한다. 이때 새로 만들어진 ‘10’은 변수 x에 재할당되지 않는다.즉, 암묵적 타입 변환은 새로운 타입의 값을 만들어 표현식을 평가하고 버린다.단축 평가단축 평가는 표현식을 평가하는 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다. &#39;Cat&#39; &amp;amp;&amp;amp; &#39;Dog&#39;; // &#39;Dog&#39; &#39;Cat&#39; || &#39;Dog&#39;; // &#39;Cat&#39;논리곱 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 논리곱 연산자에서 ‘Cat’이 먼저 true로 평가된다. 그 후 ‘Dog’에서도 true로 평가가 되어 표현식의 평가 결과는 true가 된다. 이때 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자, 즉 문자열 ‘Dog’를 그대로 반환한다.논리합 연산자는 두 개의 피연산자 중 하나라도 true로 평가될 때 true를 반환한다. 논리합 연산자에서도 논리곱 연산자와 마찬가지로 ‘Cat’이 먼저 true로 평가된다. 이때 논리합 연산자는 우항을 평가하지 않아도 표현식을 평가할 수 있다. 논리합 연산자는 논리 연산의 결과를 결정하고 첫 번째 피연산자인 ‘Cat’을 그대로 반환한다.우리는 단축 평가를 이용해서 if문을 대신할 수 있다. var done = true; var message = &#39;&#39;; // if문으로 message 할당 if (done) message = &#39;Complete&#39;; // 논리곱 연산자로 message 할당 message = done &amp;amp;&amp;amp; &#39;Complete&#39;; console.log(message);옵셔널 체이닝 연산자ES11에서 도입된 옵셔널 체이닝 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 undefined을 반환하고, 그렇지 않을 경우 우항의 프로퍼티 참조를 이어간다. var elem = null; var value = elem?.value; console.log(value); // undefined옵셔널 체이닝 연산자가 도입되기 전에는 논리 연산자를 통해서 변수가 null 또는 undefined 인지를 확인했다. 논리 연산자에서 0이나 ‘‘인 경우 false로 평가된다. 하지만 개발자의 의도에 따라 0이나 ‘‘는 객체로 평가될 때도 있다. 이 경우 옵셔널 체이닝 연산자는 유용하다.옵셔널 체이닝 연산자도 한계는 있다. 피연산자가 false로 평가되는 값이라도 null 또는 undefined가 아니면 프로퍼티의 참조를 이어간다.null 병합 연산자옵셔널 체이닝 연산자와 마찬가지로 ES11에서 도입된 연산자로 좌항 피연산자가 null 또는 undefined 인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다. var foo = null ?? &#39;default string&#39;; console.log(foo); // &#39;default string&#39;null 병합 연산자는 변수에 기본값을 설정할 때 유용하다. ES11 이전에는 논리합 연산자를 사용하여 기본값을 설정했다. 하지만 좌항의 피연산자가 false로 평가될 경우 예기치 않은 동작이 발생할 수 있다는 단점이 있었다. 이제는 null 병합 연산자를 사용하자." }, { "title": "Javascript 변수", "url": "/posts/javascript-01/", "categories": "Javascript", "tags": "javascript", "date": "2022-04-13 00:00:00 +0900", "snippet": "변수 선언변수 선언은 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간을 연결해서 값을 저장할 수 있도록 준비하는 것이다. Javascript에서는 변수를 선언할 때 var, let, const 키워드를 사용한다. let, const는 ES6에서 도입된 키워드이다. ES6 이전에는 var만 사용했지만 var 키워드는 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 단점으로 인해 let, const가 도입되었다.Javascript에서 변수 선언은 2가지 단계를 거쳐 수행된다. 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해서 초기화 한다.var 키워드를 사용해서 변수를 선언할 경우 초기화 값을 지정하지 않으면 undefined을 암묵적으로 할당하게 된다.변수 호이스팅(Variable hoisting) console.log(score); // undefined var score; // 변수 선언 score = 80; // 값의 할당 console.log(score); // 80Javascript는 한 줄씩 실행되는 인터프리터 언어이다. 그래서 위 코드를 실행하면 오류가 발생할 것으로 예상했지만 console에서 “undefined”으로 log가 찍히는 것을 확인할 수 있다. 그 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임에서 실행되는 것이 아니라 그 이전 단계에서 먼저 실행되기 때문이다. Javascript는 소스코드를 한 줄씩 순차적으로 실행하기 전에 소스코드의 평가 과정에서 소스코드를 실행하기 위한 준비를 한다. 이때 Javascript 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. 따라서 변수 선언이 어디에 있든 변수를 참조할 수 있다. 이처럼 변수 선언문이 코드의 실행보다 앞서 제일 먼저 실행되는 특징을 변수 호이스팅이라 한다. 값의 할당은 런타임에서 실행이되어 위 코드의 첫 번째 console.log에서는 undefined이 출력된다.가비지 콜렉터(Garbage collector)Javascript는 변수를 선언하면 메모리에 변수를 저장할 공간을 확보하고 undefined으로 초기화 한다. 선언된 변수에 값을 할당하면 변수를 선언할 때 잡아놓은 메모리에 값을 넣는 것이 아니라 새로운 메모리에 값을 넣고 변수와 연결한다. 그럼 선언할 때 연결한 메모리는 어떻게 처리할까? 아무도 사용하고 있지 않으니 필요없는 메모리이다. 이런 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동으로 해제된다. 단, 언제 해제될지는 알 수 없다.가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용하지 않는 메모리를 해제하는 기능을 말한다. Javascript는 가비지 콜렉터를 통해 메모리 누수를 방지한다." }, { "title": "Spring boot로 JWT 사용하기", "url": "/posts/springboot-jwt/", "categories": "Spring boot", "tags": "spring boot, JWT", "date": "2022-04-05 00:00:00 +0900", "snippet": "JWT 프로젝트 세팅JWT를 사용하기 위해서 JWT 라이브러리를 먼저 추가한다. JWT 토큰을 직접 만들 수도 있지만 라이브러리를 활용해서 편하게 사용할 수 있다.Maven &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.auth0&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;java-jwt&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.19.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;Gradle implementation &#39;com.auth0:java-jwt:3.19.1&#39;JWT Security 세팅Security에서 제공하는 formLogin은 x-www-form-urlencoded의 Context-type으로 데이터를 받는다. JSON을 받아서 로그인 처리를 하려면 해당 기능을 비활성화 해줘야 하고 JWT는 세션을 사용하지 않기 때문에 서버를 stateless로 설정해야 한다. //SecurityConfig.java @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable(); http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 세션을 사용하지 않는다 .and() .formLogin().disable() .httpBasic().disable() .authorizeRequests() .antMatchers(&quot;/api/v1/user/**&quot;) .access(&quot;hasRole(&#39;ROLE_USER&#39;) or hasRole(&#39;ROLE_MANAGER&#39;) or hasRole(&#39;ROLE_ADMIN&#39;)&quot;) .antMatchers(&quot;/api/v1/manager/**&quot;) .access(&quot;hasRole(&#39;ROLE_MANAGER&#39;) or hasRole(&#39;ROLE_ADMIN&#39;)&quot;) .antMatchers(&quot;/api/v1/admin/**&quot;) .access(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;) .anyRequest().permitAll(); } }httpBasic 방식은 header에 Authorization 키 값에 유저를 식별할 수 있는 정보를 담아서 서버에 요청을 하는 방식이다. 이 경우 유저를 매 요청 시 확인하므로 쿠키/세션이 필요하지 않다. 다만 http 방식은 header 정보를 암호화가 안되서 https 방식으로 사용해야 한다.JWT를 사용할 경우 httpBasic을 disable로 처리하고 Authorization 키 값에 JWT 토큰을 담아서 보낸다. 이 방식을 Bearer 인증 방식이라 한다.이제 Security에서 CORS 문제를 해결해 줘야 한다. CORS Filter를 만들어서 Security Filter Chain에 추가한다. //CorsConfig.java @Configuration public class CorsConfig { @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); // 내 서버가 응답할 때 josn을 자바스크립트에서 처리할 수 있게 할지를 설정하는 것 config.addAllowedOrigin(&quot;*&quot;); // 모든 ip에 응답을 허용하겠다 config.addAllowedHeader(&quot;*&quot;); // 모든 header에 응답을 허용하겠다 config.addAllowedMethod(&quot;*&quot;); // 모든 post, get, put, delete, patch 요청을 허용하겠다 source.registerCorsConfiguration(&quot;/api/**&quot;, config); return new CorsFilter(source); } } //SecurityConfig.java @Configuration @EnableWebSecurity @RequiredArgsConstructor public class SecurityConfig extends WebSecurityConfigurerAdapter { private final CorsConfig corsConfig; @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable(); http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 세션을 사용하지 않는다 .and() .addFilter(corsFilter) // @CrossOrigin(인증X), 시큐리티 필터에 등록 인증(O) .formLogin().disable() ... } }JWT 사용하기Spring Filter 등록Spring Boot로 서버를 사용하면 클라이언트의 요청이 왔을때 Filter Chain으로 요청이 넘어가서 각 Filter에서 요청에 맞는 작업을 진행해서 요청을 처리한다. Filter를 만들때는 Filter 를 구현화해서 사용한다. //MyFilter1.java public class MyFilter1 implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;MyFilter1&quot;); chain.doFilter(request, response); } }chain.doFilter(reauset, response) 를 하지 않으면 해당 필터에서 작업이 종료된다. 해당 라인을 통해 다음 필터로 요청을 넘길 수 있다.필터를 등록하려면 Filter Config파일을 설정해서 커스텀 필터를 등록할 수 있다. //FilterConfig.java @Configuration public class FilterConfig { @Bean public FilterRegistrationBean&amp;lt;MyFilter1&amp;gt; filter1() { FilterRegistrationBean&amp;lt;Myfilter1&amp;gt; filter1() { FilterRegistrationBean&amp;lt;MyFilter1&amp;gt; bean = new FilterRegistrationBean&amp;lt;&amp;gt;(new MyFilter1()); bean.addUrlPatterns(&quot;/*&quot;); // 필터가 동작할 Url 패턴 bean.setOrder(0); // 필터 동작 순서 return bean; } } }Filter Config에 등록한 필터는 Security Filter Chain이 끝난 후 필터가 동작한다. Security Filter Chain 사이 또는 먼저 필터를 등록하기 위해서는 Security Filter Chain에 사용할 필터를 등록해야 한다. Security Filter Chain에 필터를 등록하는 방법은 아래와 같다. //SecurityConfig.java @Configuration @EnableWebSecurity @RequiredArgsConstructor public class SecurityConfig extends WebSecurityConfigurerAdapter { private final CorsConfig corsConfig; @Override protected void configure(HttpSecurity http) throws Exception { http.addFilterBefore(new MyFilter(), BasicAuthenticationFilter.class); http.csrf().disable(); http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 세션을 사용하지 않는다 ... } }Security Filter에 등록할 경우 addFilterBefore() 또는 addFilterAfter() 를 사용한 한다. Security Filter Chain에서 어떤 필터 전후로 등록할지 명시해 줘야한다.JWT를 위한 로그인 처리JWT를 발행하기위해 먼저 로그인 처리를 해야한다. 현재 SecurityConfig에서 Security Login을 비활성화로 설정해뒀기 때문에 클라이언트가 Login요청을 보내면 직접 로그인 처리를 해야한다. 스프링 시큐리티에서는 Login요청이 오면 UsernamePasswordAuthenticationFilter 에서 로그인 처리를 한다. 따라서 직접 로그인 처리를 하려면 UsernamePasswordAuthenticationFilter를 상속받은 JWTAuthenticationFilter를 만들어서 처리해야 한다.JWTAuthenticationFilter에서는 attemptAuthentication 메소드를 오버라이드해서 클라이언트의 요청을 받아 로그인을 처리한다. 로그인 완료 후 Authentication 객체를 리턴하면 Authentication이 시큐리티 세션에 저장된다. attemptAuthentication 메소드가 정상적으로 종료되면 successfulAuthentication 메소드가 실행된다. successfulAuthentication 메소드도 오버라이드해서 이 메소드에서 JWT 토큰을 만들고, response의 header에 담아주면 된다. //JwtAuthenticationFilter.java // 클라이언트가 username, password를 담아 Login 요청을 함 // UsernamePasswordAuthenticationFilter 동작 @RequiredArgsConstructor public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter { private final AuthenticationManager authenticationManager; // /login 요청을 하면 로그인 시도를 위해서 실행되는 함수 @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { // 1. username, password 받아서 try { ObjectMapper om = new ObjectMapper(); User user = om.readValue(request.getInputStream(), User.class); UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()); // Longin을 위해 토큰 생성 // PrincipalDetailsService의 loadUserByUsername() 함수가 실행됨 // authenticationManager를 통해 로그인 인증을 진행하고 // authentication에 로그인한 정보가 담긴다. Authentication authentication = authenticationManager.authenticate(authenticationToken); // 로그인 완료된 건지 확인 // PrincipalDetails principalDetails = (PrincipalDetails) authentication.getPrincipal(); // System.out.println(principalDetails.getUser().getUsername()); // authentication 객체가 세션에 저장됨 =&amp;gt; 로그인 되었다는 뜻 // authentication 리턴을 하면 세션에 저장되고 security가 권한관리를 해주게 된다. return authentication; } catch (IOException e) { e.printStackTrace(); } reutnr null; } // attemptAuthentication 실행 후 인증이 정상적으로 되었으면 successfulAuthentication 함수가 실행됨 // JWT 토큰을 만들어서 request 요청한 사용자에게 JWT토큰을 respose 해주면 됨 @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException { System.out.println(&quot;successfulAuthentication 실행됨: 인증이 완료되었다는 뜻&quot;); PrincipalDetails principalDetails = (PrincipalDetails) authResult.getPrincipal(); // RSA방식은 아니고 Hash 암호방식 String jwtToken = JWT.create() .withSubject(&quot;cos Token&quot;) .withExpiresAt(new Date(System.currentTimeMillis() + (600000 * 10))) .withClaim(&quot;id&quot;, principalDetails.getUser().getId()) .withClaim(&quot;username&quot;, principalDetails.getUser().getUsername()) .sign(Algorithm.HMAC512(&quot;cos&quot;)); // 서버만 가지고 있는 ScreteKey response.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + jwtToken); } }클라이언트가 로그인 후 서버에게 받은 response의 header에 Authorization이 들어있으면 제대로 JWT 토큰을 받아온 것이다.이제 SecurityConfig에서 JWTAuthenticationFilter를 등록하자. //SecurityConfig.java @Configuration @EnableWebSecurity @RequiredArgsConstructor public class SecurityConfig extends WebSecurityConfigurerAdapter { private final CorsConfig corsConfig; @Override protected void configure(HttpSecurity http) throws Exception { http.addFilterBefore(new MyFilter(), BasicAuthenticationFilter.class); http.csrf().disable(); http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 세션을 사용하지 않는다 .and() .formLogin().disable() .httpBasic().disable() .addFilter(new JwtAuthenticationFilter(authenticationManager())) ... } }JwtAuthenticationFilter는 UsernamePasswordAuthenticationFilter를 상속받았기 때문에 바로 Security Filter Chain에 등록할 수 있다. 그리고 UUsernamePasswordAuthenticationFilter는 AuthenticationManager를 파라미터로 받기 때문에 JwtAuthenticationFilter를 생성할 때 authenticationManager()를 호출해 준다.(authenticationManger()는 WebSecurityConfigurerAdapter에 들어있다.)JWT 검증하기로그인이 완료된 클라이언트가 권한이 필요한 페이지를 요청할 때 서버는 클라이언트의 JWT를 확인해서 해당 리소스에 접근할 권한이 있는지 확인해야 한다.따라서 JWT 검증을 하기 위한 JWTAuthorizationFilter가 필요하다. //JwtAuthrizationFilter.java // 권한이나 인증이 필요한 주소에대한 요청이 오면 // BasicAuthenticationFilter를 거치게 된다. public class JwtAuthorizationFilter extends BasicAuthenticationFilter { private UserRepository userRepository; public JwtAuthorizationFilter(AuthenticationManager authenticationManager, UserRepository userRepository) { super(authenticationManager); this.userRepository = userRepository; } @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException { String jwtHeader = request.getHeader(&quot;Authorization&quot;); System.out.println(&quot;jwtHeader: &quot; + jwtHeader); // header가 있는지 확인 if(jwtHeader == null || !jwtHeader.startsWith(&quot;Bearer&quot;)) { chain.doFilter(request, response); return; } // JWT 토큰을 검증해서 권한이 있는지 확인 String jwtToken = request.getHeader(&quot;Authorization&quot;).replace(&quot;Bearer &quot;,&quot;&quot;); String username = JWT.require(Algorithm.HMAC512(&quot;cos&quot;)).build().verify(jwtToken).getClaim(&quot;username&quot;).asString(); // 서명이 정상적으로 됬다면 if(username != null) { User userEntity = userRepository.findByUsername(username); PrincipalDetails principalDetails = new PrincipalDetails(userEntity); // JWT 서명을 통해서 서명이 정상일 경우 Authentication 객체를 만들어 준다. Authentication authentication = new UsernamePasswordAuthenticationToken(principalDetails, null, principalDetails.getAuthorities()); // 강제로 시큐리티 세션에 접근하여 Authentication 객체를 저장 SecurityContextHolder.getContext().setAuthentication(authentication); } chain.doFilter(request, response); } }JWT를 전달받은 서버는 이 토큰이 유효한지를 확인해야 한다. JWT 서명을 통해 토큰의 유효성을 검증할 수 있으며, 코드에서 JWT.require(Algorithm.HMAC512(“cos”)).build().verify(jwtToken) 이 부분이 된다. 검증이 성공하면 username을 통해 유저정보를 조회할 수 있다. 조회된 유저 정보를 토대로 Authentication 객체를 만들어 주고, 해당 객체를 SecurityContextHolder에 넣어주면 해당 유저에 대한 인증이 끝나게 된다.이후 chain.doFilter()를 통해 다음 SecurityFilter로 요청을 넘겨주면 시큐리티에 의해 권한을 확인하고 응답을 보내준다.이제 JwtAuthorizationFilter를 Security Filter Chain에 등록해 주면 된다. //SecurityConfig.java @Configuration @EnableWebSecurity @RequiredArgsConstructor public class SecurityConfig extends WebSecurityConfigurerAdapter { private final CorsConfig corsConfig; private final UserRepository userRepository; @Override protected void configure(HttpSecurity http) throws Exception { http.addFilterBefore(new MyFilter(), BasicAuthenticationFilter.class); http.csrf().disable(); http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 세션을 사용하지 않는다 .and() .formLogin().disable() .httpBasic().disable() .addFilter(new JwtAuthenticationFilter(authenticationManager())) .addFilter(new JwtAuthorizationFilter(authenticationManager(), userRepository)) ... } }JWT의 장점은 역시 Stateless에 있는 것 같다. 서버는 유저가 로그인이 된건지 안된건지 별도로 세션에 ID를 저장하지 않는다. 다만 클라이언트가 API 요청을 할 경우 서버에서 발급받은 JWT를 같이 보내고, 서버는 JWT의 유효성을 서명이라는 것을 통해 확인한다. 서버는 Security를 통해서 해당 클라이언트의 권한 처리를 하며, 이 때 JWT Claim에 들어있는 클라이언트의 username을 통해 Authentication을 만들어 주고 SecurityContextHoler에 Authentication을 넣어줌으로써 해당 요청은 인증된 요청으로 처리된다.Youtube 메타코딩 선생님 JWT 강의내용 정리 (Inflearn으로도 볼 수 있음)" }, { "title": "Session and JWT", "url": "/posts/session-jwt/", "categories": "ETC", "tags": "Session, JWT", "date": "2022-03-31 00:00:00 +0900", "snippet": "웹 서비스는 서비스를 이용하는 클라이언트와 서비스를 제공하는 서버로 이루어 진다. 클라이언트는 서버에 요청을 보내고 서버는 클라이언트에게 응답을 보낸다. 서버는 클라이언트가 요청한 모든 요청에 응답을 보낼까? 서버는 클라이언트를 식별해서 해당 클라이언트의 요청을 처리해야 한다. 이 과정을 Authentication(인증) 이라 한다.인증을 위해서 클라이언트는 로그인을 한다. 로그인 과정에서 쿠키와 세션을 이용한다. 왜 쿠키와 세션이 나왔는지 이해하려면 HTTP의 특성을 알아야한다.미리 알아둘 것HTTPHTTP는 HyperText Transfer Protocol의 약자로 통신 규약이다. HTTP의 특징에는 무상태(stateless), 비연결성(connectionless) 가 있다. 무상태 : stateful은 서버가 클라이언트의 이전 상태를 보존한다는 의미이다. stateless는 서버가 클라이언트의 이전 상태를 보존하지 않는다는 의미다. 비연결성 : 클라이언트가 서버에 요청을 하고 응답을 받으면 TCP/IP 연결을 끊는다. 이를 통해 서버의 자원을 효율적으로 관리하게 된다.무상태 특성에서 문제가 발생한다. 로그인한 사용자의 상태를 유지시켜야하는데 무상태 특성상 서버는 클라이언트의 상태를 보존하지 않는다.이 문제를 해결하기 위해 쿠키(Cookie)와 세션(Session)을 사용한다.Cookie쿠키란 클라이언트가 어떤 웹사이트를 방문할 때 그 사이트가 사용하는 서버를 통해 클라이언트 컴퓨터에 설치되는 작은 기록 정보 파일을 말한다. 이 기록 파일에 담긴 정보는 클라이언트가 사이트를 방문할 때마다 읽히고 새로운 정보로 바뀐다.인증하는 과정에서 최초로 서버는 쿠키를 생성해서 클라이언트에게 보내고, 클라이언트는 쿠키를 key-value 형식으로 저장한다. 이후 클라이언트가 데이터를 요청할 때 헤더에 쿠키를 담아 서버에 보낸다. 서버는 무상태이지만 인증에 대한 정보가 쿠키에 담겨있으니 더이상 클라이언트에 대한 인증이 필요하지 않다.Session세션도 클라이언트의 인증 상태정보를 저장한다. 세션은 서버에 저장된다. 서버는 클라이언트의 요청이 오면 세션ID를 클라이언트에 전달하고, 세션ID를 서버 DB에 저장하게 된다. 이후 클라이언트는 세션ID를 쿠키에 저장하고 서버에 다음 요청부터 헤더에 세션ID를 담아 보내면 서버는 DB에서 세션ID를 확인해서 클라이언트를 식별한다.Session을 이용한 로그인 및 인증① 클라이언트가 최초로 서버에 요청을 보낸다.② 서버는 세션ID를 만들어 세션 저장소에 저장한다.③ 서버는 헤더에 세션ID를 담아 클라이언트에게 응답을 한다.④ 클라이언트는 쿠키에 세션ID를 저장한다.⑤ 클라이언트는 헤더에 세션ID를 담아 서버에 요청을 보낸다.⑥ 서버는 DB에서 유저정보를 조회한다.⑦ 유저정보가 조회된다면 클라이언트가 보낸 세션ID를 확인하고 해당 세션에 유저정보를 저장하고 로그인이 처리가 완료된다.⑧ 유저가 다시 인증이 필요한 요청을 보낸다. 이때도 세션ID를 헤더에 실어 요청한다.⑨ 서버는 세션ID를 확인하고, 해당 세션에 유저정보가 있는지 확인한다.⑩ 서버는 인증이 완료되면 클라이언트의 요청에 응답한다.그럼 세션은 언제 사라지는가? 서버가 세션을 날렸을 경우 사용자가 브라우저를 종료했을 경우(쿠키는 웹 브라우저 저장소니까) 만료 시간이 지날 경우(기본 시간 30분) 세션의 단점은 무엇인가?클라이언트가 너무 많아서 로드밸런싱을 위해 서버를 여러개 만들면 문제가 발생한다. 세션은 서버마다 가지기 때문에 서버가 여러개일 경우 세션의 데이터를 공유할 수 없다. 이 문제를 해결하기 위해서 각 서버들이 공유하는 세션 저장소를 사용하는 방법이 있다.JWT 이란?JWT(JSON Web Token)는 Json 포맷을 이용하여 사용자에 대한 정보를 저장하는 Claim 기반의 Web Token이다. JWT는 사용자 인증을 위해 사용하는 암호화된 토큰이다.JWT는 아래의 경우 유용하게 사용된다. Authorization: 권한부여는 JWT가 가장 일반적으로 사용되는 경우이다. 로그인 이후 클라이언트는 JWT를 헤더에 담아 서버에 후속 요청을 하게되고, 서버는 클라이언트가 접근할 수 있는 경로, 서비스, 자원에 대한 권한이 있는지 JWT를 통해 확인한다. Information Exchange: JWT는 클라이언트와 서버 사이에서 정보를 안전하게 전송하는 방법이 된다. 공개키/개인키 쌍을 이용해서 JWT에 서명을 할 수 있어 클라이언트에 대한 식별이 가능하고, 헤더와 페이로드를 사용하여 컨텐츠가 변조되었는지 확인이 가능하다. JWT 구조JWT는 세 부분으로 구성되어 있으며 각 부분은 점으로 구분되어진다.xxxx.yyyy.zzzzHeader(XXXX 부분)Header는 일반적으로 두 부분으로 나누어 진다. 하나는 토큰의 타입, 다른 하나는 사인을 만든 알고리즘으로 어떤 것을 사용했는지를 나타낸다.{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}Payload(yyyy 부분)Payload는 claims을 포함하고 있는 부분이다. claims은 클라이언트 정보와 추가적인 데이터를 가진다. claims은 세 부분으로 나누어지며 각각 registered, public, private claims으로 구성된다. Registered claims: Registered claims는 필수적으로 요구되진 않지만 사용할 것을 권고하고 있다. 해당 claims는 미리 정의된 claim의 집합으로 iss(발급자), exp(만료시간), sub(제목), aud(대상) 등으로 구성된다. Public claims: Public claims는 마음대로 정의할 수 있다. 다만 충돌이 일어나지 않게 주의해야 한다. Private claims: 해당 claims도 사용자 정의 claims이며, 클라이언트와 서버가 공유하기 위한 데이터를 담고 있다. { &quot;sub&quot;: &quot;title&quot;, &quot;name&quot;: &quot;user&quot;, &quot;admin&quot;: true }Signature(zzzz 부분)서명을 생성하려면 인코딩된 헤더, 인코딩된 페이로드, 비밀 키, 헤더에서 지정된 알고리즘을 사용한다.예를 들어 HMAC SHA256 알고리즘을 사용한다면, 다음과 같은 방식으로 생성한다. HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret_key )" }, { "title": "Spring Security 02. Login", "url": "/posts/security-02/", "categories": "Spring boot", "tags": "spring boot, security", "date": "2022-03-31 00:00:00 +0900", "snippet": "Security 설정Spring Security는 WebSecurityConfigurerAdapter 를 상속받아 Security 설정을 할 수 있다. @Configuration @EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록됨 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable(); http.authorizeRequests() .antMatchers(&quot;/user/**&quot;).authenticated() .antMatchers(&quot;/manager/**&quot;).access(&quot;hasRole(&#39;ROLE_ADMIN&#39;) or hasRole(&#39;ROLE_MANAGER&#39;)&quot;) .antMatchers(&quot;/admin/**&quot;).access(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;) .anyRequest().permitAll() .and() .formLogin() .loginPage(&quot;/loginForm&quot;) .loginProcessingUrl(&quot;/login&quot;) .defaultSuccessUrl(&quot;/&quot;); } }HttpSecurity.csrf()CSRF(Cross-Site Request Forgery) 보호를 활성화한다. CSRF 취약점은 공격자가 사용자가 의도하지 않은 요청을 수행하게 하는 취약점이다. 사용자의 권한 범위 내에서 사용자의 쿠키와 세션을 이용해서 공격할 수 있다. 만약 REST api를 이용할 서버라면 세션 기반 인증과 다르게 stateless하기 때문에 유저 정보를 세션에 저장하지 않고, JWT 같은 토큰을 사용해서 인증하기 때문에 CSRF 취약점에 대해서 어느정도 안전하다. 따라서, REST api 서버라면 HttpSecurity.csrf()를 disable 해도 된다.HttpSecurity.authorizeRequests()RequestMatcher 구현체를 사용하는 HttpServletRequest 기반으로 권한을 제한한다.HttpSecurity.antMatchers()특정 url에 대한 접근 조건을 지정한다. denyAll(), permitAll(), hasRoll(), authenticated() 메소드를 이용해 조건을 정해준다.Httpsecurity.anyRequest()antMatchers에서 지정한 url 이외의 모든 url에 대한 접근 조건을 지정한다.Httpsecurity.formLogin()스프링 시큐리티는 로그인 페이지를 지정해주지 않으면 시큐리티에서 제공하는 로그인 페이지로 넘어간다. 그래서 loginPage()로 로그인 페이지 url을 지정해 줘야한다. loginProcessingUrl()은 유저의 이름과 암호를 제출할 url이다. 시큐리티 사용 시 기본값으로 “/login”이 설정되어 있다. defaultSuccessUrl()은 로그인 성공 후 이동할 url을 지정한다.UserDetails 구현체 생성로그인 진행이 완료되면 SecurityContextHolder가 만들어 진다. 이 세션안에 Authentication 객체가 저장되며 Authentication 안에 유저 정보가 있다. public class PrincipalDetails implements UserDetails { private User user; public PrincipalDetails(User user) { this.user = user; } @Override public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() { Collection&amp;lt;GrantedAuthority&amp;gt; collect = new ArrayList&amp;lt;&amp;gt;(); collect.add(new GrantedAuthority() { @Override public String getAuthority() { return user.getRole(); } }); return collect; } @Override public String getPassword() { return user.getPassword(); } @Override public String getUsername() { return user.getUsername(); } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; } }UserDetailsService 구현체 생성유저 정보를 담을 UserDetails 구현체를 만들고 UserDetailsService를 통해서 유저 정보를 DB에서 불러와야 한다. 로그인 요청이 오면 자동으로 UserDetailsService 타입으로 IoC되어 있는 loadUserByUsername 함수가 실행된다. @Service public class PrincipalDetailsService implements UserDetailsService { private final UserRepository userRepository; public PrincipalDetailsService(UserRepository userRepository) { this.userRepository = userRepository; } @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User userEntity = userRepository.findByUsername(username); if(userEntity != null) { return new PrincipalDetails(userEntity); } return null; } }로그인 객체 사용하기정리하자면, 로그인 요청이 들어오면 스프링 시큐리티가 로그인 처리를 진행하면서 PrincipalDetailsService의 loadUserByUsername을 호출한다. loadUserByUsername은 DB에서 유저정보를 조회하고, 그 유저정보를 PrincipalDetails에 담아서 반환한다.그럼 시큐리티 인증 후 우리는 어떻게 로그인 객체의 정보에 접근할까? Bean을 통해 사용자 정보를 가져온다. Controller에서 사용자 정보를 얻어온다. @Authentication Principal을 사용한다. Bean을 통해 사용자 정보 가져오기 Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); UserDetails userDetails = (UserDetails)principal; String username = principal.getUsername();Controller에서 사용자 정보 가져오기 @Controller public class SecurityController { @GetMapping(&quot;/username&quot;) @ResponseBoby public String currentUserName(Principal principal) { return principal.getName(); } }@Authentication Principal해당 방법은 CustomUser 객체가 있을 때 사용한다. @Controller public class SecurityController { @GetMapping(&quot;/username&quot;) @ResponseBody public String currentUserName(@AuthenticationPrincipal CustomUser customUser) { return customUser.getUsername(); } }" }, { "title": "Spring Security 01. 스프링 시큐리티 아키텍처", "url": "/posts/security-01/", "categories": "Spring boot", "tags": "spring boot, security", "date": "2022-03-30 00:00:00 +0900", "snippet": "Spring Security는 인증, 인가에 대한 커스텀이 가능한 access-control framework 이다. Spring Security는 Spring 기반 어플리케이션을 보호하기 위한 표준 framework이다.Spring Security를 사용하는 방법은 SecurityConfig 클래스를 통해 인증 및 인가에 대한 내용을 커스텀하고, 해당 클래스를 빈으로 등록하고 스프링 필터체인에 Spring Security Fliter를 등록하면 된다.Filter?Filter란 객체의 형태로 클라이언트로부터 오는 요청과 최종자원 사이에 위치하여 클라이언트의 요청 정보를 변경하거나, 서버의 응답을 요청 결과에 맞게 변강하는 기능을 한다. Filter는 여러개가 모여서 Filter Chain을 형성할 수 있다.Spring Security Filters Chains스프링 시큐리티는 서블릿 필터를 기반으로 동작한다. 클라이언트가 서버로 요청을 보내면, DispatcherServlet이 하나의 HttpServletRequest를 받아서 요청을 처리하고 HttpServletResponse 응답을 클라이언트로 보낸다. 여기에 필터가 포함되면, 클라이언트와 서버 사이에서 요청과 응답은 필터를 거치게 된다.DelegatingFilterProxyDelegatingFilterProxy는 Servlet 컨테이너의 라이프 사이클과 Spring Application Context 사이에서 다리 역할을 하는 필터이다. Servlet 컨테이너에서는 Spring 컨테이너에 등록된 빈을 인식할 수 없다. 그래서 Spring Security에서는 DelegatingFilterProxy라는 서블릿 필터 구현체를 제공한다. DelegatingFilterProxy는 서블릿 매커니즘을 통해 서블릿의 필터로 등록될 수 있으며 스프링에 등록된 빈을 가져와 의존성을 주입할 수 있다.FilterChainProxyDelegatingFilterProxy의 내부에는 FilterChainProxy라는 것이 있으며, 이것은 Spring Security에서 제공하는 필터이다.FilterChainProxy는 DelegatingFilterProxy를 통해 받은 요청과 응답을 Spring Security Filters Chains에 전달하고 작업을 위임하는 역할을 한다. FilterChainProxy는 DelegatingFilterProxy 필터에 의해 시작된다.SecurityFilterChainSecurityFilterChain은 인증을 처리하는 여러 개의 시큐리티 필터를 담는 필터 체인이다. FilterChainProxy를 통해 서블릿 필터와 연결되고 어떤 시큐리티 필터를 통해 인증을 수행할지 결정한다. 여러 개의 SecurityFilterChain을 구성하여 URL에 따라 다른 SecurityFilterChain이 사용되도록 할 수 있다.Spring Security ArchitectureSpring Security는 “/login” 요청이 오면 로그인을 진행시킨다. 로그인 진행이 완료되면 Security는 Session을 만들어 준다. 그 Session이 SecurityContextHolder이다. Session 안에는 SecurityContext가 저장되어 있고 저장되는 내용은 Authentication 타입의 객체로 존재한다.Authentication 객체는 principal, credentials, authorities로 구성된다.SecurityContextHolderSpring Security authentication model의 핵심은 SecurityContextHoler 이다.SecurityContextHolder는 인증된 유저의 세부 정보를 저장하는 곳이다.AuthenticationAuthentication은 Spring Security에서 두개의 주요 목적을 가진다. 유저의 자격증명을 위한 AuthenticationManager 입력값 현재 인증된 사용자의 정보 Authentication의 구성 객체는 아래와 같다. principal : 유저를 식별한다. username/password를 인증할 때 UserDetails의 인스턴스이다. credentials : 비밀번호이다. 많은 케이스에서 유저의 인증 이후 이것은 지워진다. authorities : 유저의 권한이다. UserDetails 인터페이스는 핵심 유저 정보를 제공한다.GrantedAuthorityGrantedAuthority는 Authentication.getAuthorities() 함수를 통해 획득할 수 있다. 이 함수는 GrantedAuthority 객체의 Collection을 제공한다. GrantedAuthority는 유저의 권한이다. 유저의 username/password에 기반한 인증을 사용할 경우 GrantedAuthority는 일반적으로 UserDetailsService에 의해 로드된다.UserDetailsService는 loadUserByUsername() 메소드를 가지고 있으며, DB에서 유저 정보를 가져오는 역할을 한다." }, { "title": "Node.js 앱 프로세스 관리도구 PM2", "url": "/posts/PM2/", "categories": "Deployment", "tags": "pm2, deploy", "date": "2022-03-29 00:00:00 +0900", "snippet": "PM2PM2는 node.js로 만들어진 앱에 대한 프로세스 관리 도구이다. 서버 인스턴스들에 대한 로드 밸런싱과 node.js의 스케일 업 / 스케일 다운을 돕는다. 그리고 프로세스들이 계속해서 실행할 수 있는 환경을 제공한다.PM2 명령어설치PM2는 NPM 또는 Yarn으로 설치가 가능하다. $ npm install pm2@latest -g #or $ yarn global add pm2앱 시작 $ pm2 start app.jsCLI에 전달할 수 있는 옵션은 다음과 같다. # Specify an app name --name &amp;lt;app_name&amp;gt; # Watch and Restart app when files change --watch # Set memory threshold for app reload --max-memory-restart &amp;lt;200MB&amp;gt; # Specify log file --log &amp;lt;log_path&amp;gt; # Pass extra arguments to the script -- arg1 arg2 arg3 # Delay between automatic restarts --restart-delay &amp;lt;delay in ms&amp;gt; # Prefix logs with time --time # Do not auto restart app --no-autorestart # Specify cron for forced restart --cron &amp;lt;cron_pattern&amp;gt; # Attach to application log --no-daemon프로세스 관리 $ pm2 restart app_name $ pm2 reload app_name $ pm2 stop app_name $ pm2 delete app_nameapp_name 대신 ‘all’ 모든 프로세스에 대한 조치 / ‘id’ 특정 프로세스 ID에 대한 조치를 할 수 있다.상태, 로그, 측정항목의 확인PM2로 관리되는 앱 리스트 확인하기 $ pm2 [list|ls|status]PM2로 로그 확인하기 $ pm2 logs $ pm2 logs --lines 200PM2 대쉬보드 모니터 실행 $ pm2 monit $ pm2 plus # 웹 기반 대쉬보드PM2 Cluster ModeCluster Mode는 코드 수정없이 Node.js 앱을 사용 가능한 모든 CPU에 확장할 수 있다. Cluster Mode는 사용 가능한 CPU 수에 따라 앱의 성능과 안정성을 향상시킬 수 있다. Cluster Mode 사용법은 아래와 같다. $ pm2 start app.js -i maxmax 옵션은 PM2가 자동으로 사용가능한 CPU를 감지하여 가능한 프로세스를 모두 사용하는 것을 의미한다.또는 JS Configuration File을 통해서 Cluster Mode를 사용할 수 있다. module.exports = { apps: [{ script: &quot;api.js&quot;, instances: &quot;max&quot;, exec_mode: &quot;cluster&quot; }] } Config File을 사용할 경우 PM2가 각 인스턴스 사이에서 로드 밸런싱을 원한다는 것을 알리기 위해 Cluster Mode를 설정해줘야 한다.그리고 Config File을 통해서 프로세스를 실행할 수 있다. $ pm2 start processes.json" }, { "title": "NGINX란", "url": "/posts/NGINX/", "categories": "Deployment", "tags": "nginx", "date": "2022-03-29 00:00:00 +0900", "snippet": "NGINXNGINX는 경량화된 웹 서버이다. 웹 서버는 무엇인가? 웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 서버이다. 즉, NGINX는 HTTP 서버로서 정적 파일을 반환해 준다.NGINX는 Reverse Proxy Server로 활용되어 서버의 부하를 줄이는 로드 밸런서이기도 하다.Apache VS NGINXApache 웹서버는 클라이언트로부터 받은 요청을 처리할 때 새로운 프로세스를 생성하여 처리한다. 따라서 CPU와 메모리의 자원 소모가 커져서 요청이 많아지면 부하가 심해진다.Nginx는 Event-Driven 구조로 고정된 프로세스만 생성하고, 요청은 비동기 방식으로 처리한다. 따라서 자원의 효율적인 운용이 가능하다.Reverse proxy??클라이언트가 서버로 요청을 보내면 서버는 요청에 대한 응답으로 클라이언트에게 리소스를 반환한다. Proxy server는 클라이언트와 서버의 징검다리가 된다. 클라이언트의 요청을 서버가 직접 받는 것이 아니라 Proxy server가 대신 받아주고, Proxy server는 그 요청을 다시 서버에게 보낸다. 서버는 클라이언트에게 리소스를 직접 전달하는 것이 아니라 Proxy server에게 전달하고, Proxy server는 전달받은 리소스를 클라이언트에게 전달한다.이런 짓을 왜하냐? Proxy Server는 Forword Proxy와 Reverse Proxy로 구분된다.Forword Proxy는 내부망에서 외부 인터넷의 연결을 요청하는 형태로, 정해진 사이트만 연결이 가능하게 설정하여 보안이 중요한 환경에서 사용한다.서버의 앞에서 클라이언트의 요청을 받을 수 있어서 로드 밸런서로 사용할 수 있다. 또 클라이언트에게 실제 서버의 IP주소를 감출 수 있어 실제 서버로 들어오는 외부의 공격을 막을 수 있다.NGINX 구조NGINX는 하나의 Master Process와 다수의 Worker Process로 구성되어 실행된다. Master Process는 configuration을 읽고, 유효한지 평가를 한다. 그리고 Worker Process를 관리한다. Worker Process는 클라이언트의 요청을 실제로 처리하는 역할을 하며, Worker Process의 개수는 configuration을 통해 정의하거나 CPU 코어에 맞게 자동으로 조정된다." }, { "title": "React 13. useRef 와 forwardRef", "url": "/posts/react-13/", "categories": "React", "tags": "react, hooks", "date": "2022-03-22 00:00:00 +0900", "snippet": "useRef const refContainer = useRef(initialValue);useRef는 전달된 인수(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다. HTML 문서에서 Javascript를 이용해서 element를 제어했듯이 useRef를 통해서 React에서는 element를 제어할 수 있다. function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =&amp;gt; { // `current` points to the mounted text input element inputEl.current.focus(); }; return ( &amp;lt;&amp;gt; &amp;lt;input ref={inputEl} type=&quot;text&quot; /&amp;gt; &amp;lt;button onClick={onButtonClick}&amp;gt;Focus the input&amp;lt;/button&amp;gt; &amp;lt;/&amp;gt; ); }useRef는 element의 property를 변경하는 것이기에 리렌더링이 일어나지 않는다. 이것에 주의하자.forwardRefuseRef의 한계는 바로 HTML Tag에서만 적용할 수 있다는 점이다. 그러면 사용자가 정의한 Component는 어떻게 property에 접근할 수 있을까?그때 사용하는 것이 ForwardRef이다. const FancyButton = React.forwardRef((props, ref) =&amp;gt; ( &amp;lt;button ref={ref} className=&quot;FancyButton&quot;&amp;gt; {props.children} &amp;lt;/button&amp;gt; )); const ref = React.createRef(); &amp;lt;FancyButton ref={ref}&amp;gt;Click me!&amp;lt;/FancyButton&amp;gt;;useRef를 사용하고 싶은 Component를 React.forwardRef로 감싸면 해당 Component의 property에 접근할 수 있다. 하지만, 코드를 보면 결국 Component가 받는 ref를 Component 안에 있는 element로 전달하는 것일 뿐이다." }, { "title": "React 12. Hooks API(Additional Hooks)", "url": "/posts/react-12/", "categories": "React", "tags": "react, hooks", "date": "2022-03-22 00:00:00 +0900", "snippet": "useReducer const [state, dispatch] = useReducer(reducer, initialArg, init);리액트 공식문서에 의하면 useState의 대체 함수라고 설명한다. reducer는 (state, action) =&amp;gt; newState 형태의 함수이다. 그리고 reducer는 현재의 State(initialState)와 쌍으로 dispatch 메서드를 반환한다.개인적으로 리액트를 처음 공부할때부터 참 잘 이해가 가지 않는 부분이 Reducer였다.이해가 잘 안될때는 코드가 오히려 더 편할 때가 있다. 카운터 예제 코드를 보자. const initialState = { count: 0 }; function reducer(state, action) { switch(action.type) { case: &#39;increment&#39; : return { count: state.count + 1 }; case: &#39;decrement&#39; : return { count: state.count - 1 }; default: throw new Error(); } } function Counter() { const [ state, dispatch ] = useReducer(reducer, initialState); return ( &amp;lt;&amp;gt; Count: { state.count } &amp;lt;button onClick={() =&amp;gt; dispatch({type: &#39;decrement&#39;})}&amp;gt;-&amp;lt;/button&amp;gt; &amp;lt;button onClick={() =&amp;gt; dispatch({type: &#39;increment&#39;})}&amp;gt;+&amp;lt;/button&amp;gt; &amp;lt;/&amp;gt; ); }reducer함수는 초기의 state값을 받아서, action.type에 따라 state를 새로운 state로 만들어 준다. useReducer는 이 reducer함수(action.type에 따라 어떤 연산을 할 것인지…)와 초기 state 값을 인자로 받아서 state와 dispatch를 쌍으로 반환한다.여기서 반환된 state는 아직 reducer가 실행되지 않았으니 초기 state 값이 들어있다. dispatch 함수는 action 오브젝트를 인자로 받으며, action.type을 reducer함수에 전달한다.그러니까 dispatch함수는 reducer 함수를 불러오는 놈이구나…추가적으로 reducer함수를 만들 때 주의할 점이 있다. 벨로퍼트 선생님의 “리액트를 다루는 기술”에서 참조한다. 리듀서 함수는 이전 상태와 객체를 파라미터로 받는다. 파라미터 외의 값에는 의존하면 안된다. 이전 상태는 절대로 건드리지 않고, 변화를 준 새로운 상태 객체를 만들어서 반환한다. 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환해야 한다. 내일은 useRef와 ForwardRef를 정리해야겠다. 얼른 Hooks를 정리하고 Redux를 정리하고 싶다." }, { "title": "React 11. Context", "url": "/posts/react-11/", "categories": "React", "tags": "react, hooks", "date": "2022-03-21 00:00:00 +0900", "snippet": "When to use ContextContext는 데이터는 제공하는 방법이다. 리액트 컴포넌트에서 데이터를 전달하기 위해서는 사용하고자 하는 데이터가 필요한 컴포넌트를 먼저 구분하고, 그 컴포넌트들의 공통 부모가 되는 컴포넌트를 찾아 그곳에서 useState를 통해 데이터를 관리하고, 필요한 컴포넌트까지 각 단계의 컴포넌트들에게 props를 통해 전달해서 사용했다. 상당히 복잡하고 귀찮은 일이다. 이 귀찮은 일을 간단하게 처리하기 위해 사용하는 것이 Context다.Context는 “Global” 하게 데이터를 관리할 수 있다. 따라서, 어떤 컴포넌트에서나 필요할 수 있는 유저 인증정보와 같은 것들을 관리하기 좋다.Context 사용 시 고려할 사항이거 참 편하네라고 생각하고 막쓰려던 참이였는데, 조심해서 쓰란다. 리액트 공식 홈페이지에 보면 Context를 사용할 때 첫번째 고려사항은 해당 데이터가 필요한 많은 컴포넌트들이 복잡하게 얽혀있는가? 이다. 하지만, Context 사용은 컴포넌트 재사용을 힘들게 하기 때문에 최대한 자제해야 한다고 말한다. 때때로 Context 사용보다 Component Composition이 더 간단한 방법일 때가 있다고 한다.Context 관련 API 정리React.createContext const MyContext = React.createContext(defaultValue);Context 객체를 만든다. Context 객체를 구독하고 있는 컴포넌트를 렌더링할 때 React는 가장 가까이 있는 Provider로 부터 값을 읽는다. defaultValue는 컴포넌트 트리에서 적절한 Provider를 찾지 못했을 경우 쓰이는 값이다. 이 값은 컴포넌트를 독립적으로 테스트할 때 유용한 값이다.Context.Provider &amp;lt;MyContext.Provider value={}&amp;gt;Provider는 Context 오브젝트에 포함된 React 컴포넌트이며, Provider는 context를 구독하는 컴포넌트들에게 context의 변화를 알려준다. 즉, Provider를 구독하는 모든 검포넌트들은 context의 변화가 생기면 리렌더링 된다. Provider 컴포넌트는 value prop을 받아서 하위 컴포넌트에 전달하며, 값을 전달받는 하위 컴포넌트의 수는 제한이 없다. Provider 하위에 또 다른 Provider를 배치하는 것이 가능하며, 이 경우 하위 Provider 값이 우선된다.Class.contextType class MyClass extends React.Component { static contextType = MyContext; render() { let value = this.context; } } class의 contextType에 Context 객체를 할당하고, this.context로 Context Value를 참조할 수 있다.Context.Consumer &amp;lt;MyContext.Consumer&amp;gt; {value =&amp;gt; ()} &amp;lt;/MyContext.Consumer&amp;gt;Consumer는 context 변화를 구독하는 컴포넌트이다. Context.Consumer의 자식은 함수여야 한다. 이 함수는 context의 현재값을 받고 React 노드를 반환한다.useContext const value = useContext(MyContext);useContext는 context객체를 받아 그 context의 현재 값을 반환한다. 이 때 context 현재 값은 트리 안에서 Hook을 호출하는 컴포넌트에 가장 가까이 있는 Provider에 의해 결정된다." }, { "title": "React 10. Hooks API(Basic HOOK)", "url": "/posts/react-10/", "categories": "React", "tags": "react, hooks", "date": "2022-03-08 00:00:00 +0900", "snippet": "useState const [state, setState] = useState(initialState);useState는 값, 그리고 업데이트 함수를 반환한다. 최초 렌더링 시, useState의 인자로 전달받은 초기값을 렌더링한다.setState함수는 state 값을 업데이트하며, state가 업데이트되면 state를 출력하는 컴포넌트들이 리렌더링 된다.setState는 비동기적으로 동작하며, useState의 state는 가장 최근의 업데이트 값이 된다.만약 setState가 현재 값과 동일한 값을 리턴할 경우, 컴포넌트들의 리렌더링은 완전히 스킵된다.useEffect useEffect(didUpdate);useEffect는 함수를 인자로 가진다. 이 함수는 화면이 렌더링된 후 실행된다. useEffect는 기본적으로 렌더링이 완료될 때 마다 실행된다. 그러나 특정 값이 변경된 경우에만 실행되도록 선택할 수 있다. Cleaning up an effect 종종 useEffect는 컴포넌트가 사라질 때 정리할 필요가 있다.(예를들면 subscription 또는 timerID)이때 필요한 함수를 clean up 함수라 부르며, useEffect가 리턴될 때 clean up 함수를 호출하면 된다. useEffect(() =&amp;gt; { const subscription = props.source.subscribe(); return () =&amp;gt; { // Clean up the subscription subscription.unsubscribe(); }; });clean up 함수는 메모리 누수를 방지하기 위해 UI로부터 컴포넌트가 사라지기 전에 실행된다. 추가로 컴포넌트가 여러번 렌더링 될 때, 이전 effect는 다음 effect가 실행되기 전에 정리된다.useEffect를 조건부로 동작하려면 두 번째 인수를 전달하면 된다. 두 번째 인수는 useEffect의 의존성을 결정한다. useEffect(() =&amp;gt; { const subscription = props.source.subscribe(); return () =&amp;gt; { // Clean up the subscription subscription.unsubscribe(); }; },[props.source];위 코드의 경우 props.source가 변경될 때만 useEffect는 실행되게 된다. 두 번째 인자에 빈 배열을 넣을 경우는 의존성이 없으므로 컴포넌트가 최초 렌더링될 때 한 번만 실행된다.그 외..기본 Hook에는 useState, useEffect 외 useContext가 있다. useContext는 React Context로 따로 포스팅할 예정이다." }, { "title": "React 09. Hooks", "url": "/posts/react-09/", "categories": "React", "tags": "react, hooks", "date": "2022-03-07 00:00:00 +0900", "snippet": "Hooks는 React 16.8버전에 새로 추가되었다. Hooks은 React class 없이 state를 사용할 수 있다.State Hook import React, { useState } from &#39;react&#39;; function Example() { const [const, setCount] = useState(0); return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;{count}&amp;lt;/p&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count +1)}&amp;gt; Click me &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); }useState는 Hook의 하나이다. Hook을 통해 함수형 컴포넌트 안에서 state를 추가했다. useState는 현재 값과 업데이트하는 함수를 쌍으로 제공한다.위 코드에서 useState는 비구조화 할당을 이용한 방법이다. 비구조화 할당은 별로도 내용을 정리해서 포스팅하자useState는 초기값을 인자로 받아 state와 setState() 함수를 반환한다. useState의 반환값을 비구조화 할당을 통해 state는 const에 담고, setState()는 setCount에 담는다.Hook은 함수 컴포넌트에서 React state와 생명주기를 연동할 수 있게 해주는 함수이다.Hook은 class 안에서는 동작하지 않는다. 대신 class 없이 React를 사용할 수 있게 해주는 것이다.Effect HookReact 컴포넌트 안에서 데이터를 가져오거나 구독하고, DOM을 직접 조작하는 작업.. 이런 모든 동작을 side effects라고 한다. 이런 동작이 다른 컴포넌트에 영향을 줄 수도 있고, 렌더링 과정에서는 구현할 수 없는 작업이기 때문이다.useEffect는 함수 컴포넌트 내에서 이런 side effects를 수행할 수 있게 해준다. React class의 componentDidMount나 componentDidUpdate, componentWillUnmount와 같은 목적으로 제공되지만, 하나의 API로 통합된 것이다. import React, { useState, useEffect } from &#39;react&#39;; function Example() { const [count, setCount] = useState(0); useEffect(() =&amp;gt; { document.title = `${count} times`; }); return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;{count} times&amp;lt;/p&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; Click me &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); }useEffect를 사용하면, React는 DOM을 바꾼 뒤에 “effect”함수를 실행한다. useState에서 state가 변하면 컴포넌트가 리렌더링되고, 컴포넌트가 리렌더링되면 useEffect가 실행되는 것이다.기본적으로 React는 매 렌더링 이후에 effects를 실행한다. 첫 번째 랜더링을 포함해서…Effect를 해제할 필요가 있다면, 해제하는 함수를 반환해주면 된다. 해제하는 함수는 “clean up”함수라 한다. function FriendStatusWithCounter(props) { const [count, setCount] = useState(0); useEffect(() =&amp;gt; { document.title = `${count} times`; }); const [isOnline, setIsOnline] = useState(null); useEffect(() =&amp;gt; { ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); // 요게 clean up 함수 return () =&amp;gt; { ChatAPI.unscribeToFriendStatus(props.friend.id, handleStatusChange); }; }); function handleStatusChange(status) { setIsOnline(status.isOnline); } }Hook을 사용하면 서로 관련있는 코드를 한군데 모아 작성할 수 있다. 반면 class 컴포넌트에서는 lifecycle methods 각각에 쪼개서 넣어야 한다.Hook 사용 규칙Hook은 Javascript 함수이지만, 두 가지 규칙을 준수해야 한다. 최상위에서만 Hook을 호출해야 한다. 반목문, 조건문, 중첩함수 내에서는 Hook을 실행하지 말 것 React 함수 컴포넌트 내에서만 Hook을 호출해야 한다.Hook 만들기개발 중 상태 관련 로직을 컴포넌트 간에 재사용하고 싶을 경우 전통적으로 higher-order components와 render props를 이용해서 해결한다. Custom Hook은 이 둘과 달리 컴포넌트 트리에 새 컴포넌트를 추가하지 않고 해결할 수 있다.위 코드에서 친구 접속상태를 확인하는 로직을 재사용한다는 가정을 하고 해당 로직을 useFriendStatus로 만들어보자. import React, { useState, useEffect } from &#39;react&#39;; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() =&amp;gt; { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =&amp;gt; { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; }위 코드는 friendID를 받아서 친구의 접속상태를 반환한다. 이것을 여러 컴포넌트에서 사용할 수 있다. function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return &#39;Loading...&#39;; } return isOnline ? &#39;Online&#39; : &#39;Offline&#39;; } function FriendListItem(props) { const isOnline = useFriendStatus(props.friend.id); return ( &amp;lt;li style=&amp;gt; {props.friend.name} &amp;lt;/li&amp;gt; ); }위 코드에서 각 컴포넌트의 state는 완전히 독립적이다. Hook은 state 그 자체가 아니라, 상태 관련 로직을 재사용하는 방법이다. 따라서 각각의 Hook 호출은 독립된 state를 가진다. 그래서 한 컴포넌트 내에서 같은 custom Hook을 두 번 쓸 수도 있다.Custom Hook은 별도로 한번 공부해 보자." }, { "title": "React 08. State와 Props", "url": "/posts/react-08/", "categories": "React", "tags": "react", "date": "2022-03-03 00:00:00 +0900", "snippet": "What is the difference between state and props?State와 Props는 어떻게 다른가? state와 props는 둘 다 Javascript 객체이다. props는 component에 전달되는 객체이며 (함수 매개변수와 유사), state는 component 내부에서 관리되는 객체 (함수 내에 선언된 변수와 유사) 이다.Why is setState giving me the wrong value?리액트에서 this.props와 this.state는 둘 다 렌더링된 값을 나타낸다. props는 상위 컴포넌트에서 전달받은 값이지만 state는 컴포넌트 내부에서 관리되기 때문에 해당 컴포넌트에서 변경할 수 있다.주의할 점은 setState는 비동기(asynchronous)적으로 동작하기 때문에 새로운 값이 즉시 반영되게 코드를 작성해서는 안된다. incrementCount() { this.setState({count: this.state.count + 1}); } handleSomething() { this.incrementCount(); this.incrementCount(); this.incrementCount(); }this.state.count가 0에서 시작한다고 생각하자.state값 변경으로 컴포넌트가 리렌더링 될 때, 우리의 기대와 달리 this.state.count는 1로 렌더링 될 것이다. 리액트는 컴포넌트를 리렌더링할 때 까지 this.state.count를 업데이트 하지 않는다. 그래서 this.incrementCount()는 항상 0을 받아 1로 변경하게 된다.How do I update state with values that depend on the current state?그래서 어떻게 고칠껀데?? setState 호출이 항상 최신 버전의 상태를 사용하도록 하기위해 객체 대신 함수를 전달하면 된다. incrementCount() { this.setState((state) =&amp;gt; { return { count: state.count + 1 } }); } handleSomething() { this.incrementCount(); this.incrementCount(); this.incrementCount(); }When is setState asynchronous?setState는 이벤트 핸들러 내부에서 비동기적이다. 예를 들어 부모와 자식 모두 이벤트 중 setState를 호출할 경우 자식은 두번 리렌더링되지 않는다. 대신 이벤트가 끝날 때 state 업데이트를 flushed 한다.Why doesn’t React update this.state synchronously?왜 리액트는 업데이트를 동기적으로 하지 않는가? 리액트는 의도적으로 모든 컴포넌트의 setState()가 호출될 때 까지 기다린다. 결론적으로 퍼포먼스를 향상시키기 위해 불필요한 리렌더링을 피하는 것이다." }, { "title": "React 07. React 프로젝트 개발", "url": "/posts/react-07/", "categories": "React", "tags": "react", "date": "2022-03-03 00:00:00 +0900", "snippet": "1. UI 컴포넌트 계층 구조 나누기가장 먼저 디자인 시안을 보면서 컴포넌트를 나누어야 한다. 컴포넌트를 나눌때는 단일 책임 원칙을 고려한다. 하나의 컴포넌트는 한 가지 일을 하도록 설계하자!!2. React로 정적인 버전 만들기컴포넌트를 나누고 나면 UI 렌더링만 되고 동작은 없는 버전을 먼저 만들어 보자. 데이터 모델을 렌더링하는 정적 버전을 만들고 props를 이용해서 데이터를 전달한다. 정적 버전을 만들기 위해서 state를 사용하지 말자!! state는 오직 상호작용을 위해.. 데이터가 바뀌는 것에 사용한다.앱을 만들때는 top-down 또는 bottom-up 방식으로 만들 수 있다. 간단한 프로젝트는 top-down으로 만드는 것이 쉽고, 프로젝트가 클 경우 bottom-up으로 진행하는 것이 더 쉽다.3. UI state 찾아내기앱에서 필요로 하는 변경 가능한 state의 최소 집합을 생각해 보자. 핵심은 중복배제 원칙이다.최소한의 state를 찾아야 한다. 각 data가 state인지 결정할 경우 고려할 사항은 세 가지다. 부모로부터 props를 통해 전달되는가? 시간이 지나도 변하지 않는가? 컴포넌트 내부의 다른 state나 props를 통해 계산 가능한가?4. State가 위치해야 할 곳최소한의 state를 찾아낸 다음은 어떤 컴포넌트가 state를 소유할지 찾아야 한다. state를 가질 컴포넌트를 결정할 때는 다음 과정을 따라보자. state를 기반으로 렌더링하는 모든 컴포넌트를 찾는다. state를 공동으로 소유해야하는 컴포넌트를 찾는다. 공동으로 소유해야하는 컴포넌트들의 상위 컴포넌트에 state를 위치시킨다. 적절한 컴포넌트를 찾지 못하였다면, state를 소유하는 상위 컴포넌트를 추가한다.5. 역방향 데이터 흐름 추가하기마지막으로 각 컴포넌트의 이벤트 처리를 통해 state 값을 업데이트 한다.마치며..리액트 공식 홈페이지에서 DOC &amp;gt; 주요개념을 읽어봤다. 개념에 관한 이야기라 좀 어렵게 다가오기도 했고, class 타입의 예제코드라 좀 피로감이 느껴졌다. 얼른 Hook을 정리해야겠다. 그리고 Hook에서는 예제코드를 직접 만들어봐야겠다." }, { "title": "React 06. Forms", "url": "/posts/react-06/", "categories": "React", "tags": "react", "date": "2022-03-01 00:00:00 +0900", "snippet": "HTML form 요소들은 React의 다른 DOM 요소와 다르게 작동한다. form 요소는 자연스럽게 내부 상태를 가지게 되고, React에서는 form 요소의 내부 상태를 State로 관리할 수 있다.Controlled ComponentsHTML form 요소들은 사용자 입력을 기반으로 내부 상태를 업데이트 한다. React에서는 오직 setState()를 통해서 내부 상태를 업데이트 한다.React는 form 요소의 내부 상태를 제어하고, 변경이 감지되면 렌더링한다.이처럼 React에서 값을 제어하는 form 요소를 Controlled Components라 한다. class NameForm extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(e) { this.setState({ value: event.target.value}); } handleSubmit(e) { e.preventDefault(); // Submit 이 후 새 페이지로 넘어가는 것 을 방지함 alert(&#39;A name was submitted: &#39; + this.state.value); } render() { return ( &amp;lt;form onSubmit={this.handleSubmit}&amp;gt; &amp;lt;label&amp;gt; Name: &amp;lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt; &amp;lt;/form&amp;gt; ); } }Controlled Component를 사용하면 입력 값은 항상 React State에 의해 결정된다.select TagReact에서는 selected 값을 State를 통해서 지정한다. HTML &amp;lt;select&amp;gt; &amp;lt;option value=&quot;grapefruit&quot;&amp;gt;Grapefruit&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;lime&quot;&amp;gt;Lime&amp;lt;/option&amp;gt; &amp;lt;option selected value=&quot;coconut&quot;&amp;gt;Coconut&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;mango&quot;&amp;gt;Mango&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; React class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;coconut&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;Your favorite flavor is: &#39; + this.state.value); event.preventDefault(); } render() { return ( &amp;lt;form onSubmit={this.handleSubmit}&amp;gt; &amp;lt;label&amp;gt; Pick your favorite flavor: &amp;lt;select value={this.state.value} onChange={this.handleChange}&amp;gt; &amp;lt;option value=&quot;grapefruit&quot;&amp;gt;Grapefruit&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;lime&quot;&amp;gt;Lime&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;coconut&quot;&amp;gt;Coconut&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;mango&quot;&amp;gt;Mango&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&amp;gt; &amp;lt;/form&amp;gt; ); } }" }, { "title": "React 05. Lists and Keys", "url": "/posts/react-05/", "categories": "React", "tags": "react", "date": "2022-03-01 00:00:00 +0900", "snippet": "반복되는 객체 RenderingJavascript의 Map() 함수를 활용하여 반복되는 렌더링 작업을 처리할 수 있다.Map() 함수는 Array 리스트를 받아 새로운 리스트를 반환하는 함수이다. const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x =&amp;gt; x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32]React에서도 Map() 함수를 이용해서 반복되는 component를 렌더링 할 수 있다. function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&amp;gt; &amp;lt;li&amp;gt;{number}&amp;lt;/li&amp;gt; ); return ( &amp;lt;ul&amp;gt;{listItems}&amp;lt;/ul&amp;gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &amp;lt;NumberList numbers={numbers} /&amp;gt;, document.getElementById(&#39;root&#39;) );해당 코드를 실행시키면 Key값이 없다는 Warning이 뜬다. Key값은 list element를 생성할 때 각 element에 포함되어야 하는 특수한 속성이다.KeysKeys는 React itmes의 변화, 추가, 제거와 같은 상태변화를 식별하는 것을 도와준다. Keys는 Array 내부 요소에 주어진다.Key를 선택하는 가장 좋은 방법은 Object property 중 고유 식별 ID를 사용하는 것이다. const todoItems = todos.map((todo) =&amp;gt; &amp;lt;li key={todo.id}&amp;gt; {todo.text} &amp;lt;/li&amp;gt; ); 만약 Object property에 식별을 위한 ID가 없을 경우, Map함수의 두 번째 인자로 index를 넣어주면 Key 값을 할당할 수 있다. const todoItems = todos.map((todo, index) =&amp;gt; // Only do this if items have no stable IDs &amp;lt;li key={index}&amp;gt; {todo.text} &amp;lt;/li&amp;gt; );하지만, 항목의 순서가 변경될 수 있는 경우는 index를 사용하지 않는 것이 좋다.또한, Keys는 Siblings 사이에서 반드시 Unique한 값이여야 한다. 하지만 Globally unique할 필요는 없다." }, { "title": "React 04. Conditional Rendering", "url": "/posts/react-04/", "categories": "React", "tags": "react", "date": "2022-02-27 00:00:00 +0900", "snippet": "React에서 조건에 따라 Components를 다르게 렌더링할 수 있다. 조건부 렌더링을 하는 방법은 세 가지가 있다. 요소 변수 논리 연산자 ‘&amp;amp;&amp;amp;’ 삼항 연산자요소 변수 function LoginButton(props) { return ( &amp;lt;button onClick={props.onClick}&amp;gt; Login &amp;lt;/button&amp;gt; ); } function LogoutButton(props) { return ( &amp;lt;button onClick={props.onClick}&amp;gt; Logout &amp;lt;/button&amp;gt; ) } class LoginControl extends React.Component { constructor(props) { super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = {isLoggeIn: false}; } handleLoginClick() { this.setState({isLoggedIn: true}); } handleLogoutClick() { this.setState({isLoggedIn: false}); } render() { const isLoggedIn = this.state.isLoggedIn; let button; if (isLoggedIn) { button = &amp;lt;LogoutButton onClick={this.handleLogoutClick} /&amp;gt;; } else { button = &amp;lt;LoginButton onClick={this.handleLoginClick} /&amp;gt;; } return ( &amp;lt;div&amp;gt; &amp;lt;Greeting&amp;gt; isLoggedIn={isLoggedIn} /&amp;gt; {button} &amp;lt;/div&amp;gt; ); } } ReactDOM.render( &amp;lt;LoginControl /&amp;gt;, document.getElementById(&#39;root&#39;) );isLoggedIn 의 상태에 의존하여 렌더링하는 Component가 달라진다.‘&amp;amp;&amp;amp;’ 논리 연산자Javascript &amp;amp;&amp;amp; 논리 연산자를 이용하면 Inline 방식으로 조건부 렌더링이 가능하다. function Mailbox(props) { const unreadMessages = props.unreadMessages; return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Hello!&amp;lt;/h1&amp;gt; {unreadMessages.length &amp;gt; 0 &amp;amp;&amp;amp; &amp;lt;h2&amp;gt; You have {unreadMessages.length} unread messages. &amp;lt;/h2&amp;gt; } &amp;lt;/div&amp;gt; ); } const messages = [&#39;React&#39;, &#39;Re: React&#39;, &#39;Re:Re: React&#39;]; ReactDOM.render( &amp;lt;Mailbox unreadMessages={messages} /&amp;gt;, document.getElementById(&#39;root&#39;) );&amp;amp;&amp;amp; 논리 연산자는 treu &amp;amp;&amp;amp; 값일 경우 항상 값으로 계산이 되고, false &amp;amp;&amp;amp; 값일 경우 항상 false로 계산된다. 또한 0 &amp;amp;&amp;amp; 값일 경우 항상 0으로 계산된다.삼항 연산자삼항 연산자는 ** 조건 ? true : false ** 의 구조로 이루어 진다. render() { const isLoggedIn = this.state.isLoggedIn; return ( &amp;lt;div&amp;gt; The user is &amp;lt;b&amp;gt;{isLoggedIn ? &#39;currently&#39; : &#39;not&#39;}&amp;lt;/b&amp;gt; logged in. &amp;lt;/div&amp;gt; ); }isLoggedIn이 true일 경우 ‘currently’를, false일 경우 ‘not’을 출력한다.렌더링 방지렌더링된 component를 특정 경우에 따라 숨기고 싶을 때, null을 반환해서 숨길 수 있다. function WarningBanner(props) { if (!props.warn) { return null; } return ( &amp;lt;div className=&quot;warning&quot;&amp;gt; Warning; &amp;lt;/div&amp;gt; ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true}; this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(state =&amp;gt; ({ showWarning: !state.showWaring })); } render() { return ( &amp;lt;div&amp;gt; &amp;lt;WarningBanner warn={this.state.showWarning} /&amp;gt; &amp;lt;button onClick={this.handleToggleClick}&amp;gt; {this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;} &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); } } ReactDOM.render( &amp;lt;Page /&amp;gt;, document.getElementById(&#39;root&#39;) );WarningBanner component는 warn prop 값에 따라 렌더링 된다. warn이 false일 경우 null값을 반환하며, 렌더링 되지 않는다." }, { "title": "React 03. Handling Events", "url": "/posts/react-03/", "categories": "React", "tags": "react", "date": "2022-02-27 00:00:00 +0900", "snippet": "React에서의 Handling event는 DOM elements에서의 Handling evnet와 유사하다.다만 React에서는 아래의 몇 가지 주의할 점을 정리해보자.Handling Event 사용법 React events는 camelCase 표기법으로 나타낸다. event handler를 넘길 때 JSX 문법으로 넘긴다. HTML &amp;lt;button onclick=&quot;activateLasers()&quot;&amp;gt; Activate Lasers &amp;lt;/button&amp;gt; React &amp;lt;button onClick={activateLasers}&amp;gt; Activate Lasers &amp;lt;/button&amp;gt; 또 하나 주의할 점은 React에서는 default behavior을 방지하기 위해 ‘false’를 return 할 수 없다. HTML &amp;lt;form onsubmit=&quot;console.log(&#39;submit&#39;); reutrn false&quot;&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; React function Form() { function handleSubmit(e) { e.preventDefault(); // Form이 Submit 되는 default behavior를 방지한다. console.log(&#39;submit&#39;); } return( &amp;lt;form onSubmit={handleSubmit}&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;Submit&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; ) } React에서는 일반적으로 DOM element에 listener를 붙이기 위해 addEventListener를 호출할 필요가 없다. React에서는 element가 최초로 그려질 때 listener를 제공한다.Function Bounding in JavascriptJavascript에서 Class method는 기본적으로 바운딩 되지 않는다. 만약 onClick={this.handleClick}과 같이 뒤에 ()가 없는 method를 참조할 경우 반드시 바인딩이 되어야 한다. class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: ture}; this.handleClick = this.handleClick.bind(this); } handleCilck() { this.setState(prevState =&amp;gt; ({ isToggleOn: !prevState.isToggleOn })); } render() { return ( &amp;lt;button onClick={this.handleClick}&amp;gt; {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;} &amp;lt;/button&amp;gt; ) } } ReactDOM.render( &amp;lt;Toggle /&amp;gt;, document.getElementById(&#39;root&#39;) );" }, { "title": "React 02. State and Lifecycle", "url": "/posts/react-02/", "categories": "React", "tags": "react", "date": "2022-02-24 00:00:00 +0900", "snippet": "참고로 React 정리를 어떻게 할까 고민하다가 React 공식 사이트의 Docs를 읽어보고 정리하기로 정했다. 누군가가 내 글을 보고 부족함을 느낀다면 React 공식 Docs를 찾아보길 권한다.StateState를 공부하기 위해 Clcok 컴포넌트를 만들어 보자.function Clock(props) { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{new Date().toLocaleTimeString()}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );}function tick() { ReactDOM.render( &amp;lt;Clock date={new Date()} /&amp;gt;, document.getElementById(&#39;root&#39;) );}setInterval(tick, 1000);위 코드에서 매 초마다 tick 함수를 호출하고 Clock에 새로운 시간을 props로 넘겨서 다시 렌더링한다.이상적인 Clock은 시간을 스스로 업데이트하는 방법일 것이다. 그러기 위해서 props로 받는 시간을 Clock 내부에서 state로 만들어야 한다. state는 props와 유사하지만 state는 private하고, 철저히 component에 의해 통제되어야 한다.state를 Clock 내부에 만들기 위해 function을 class로 바꿔보자.class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{this.state.date.toLocaleTimeString()}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; ); }}ReactDOM.render( &amp;lt;Clock /&amp;gt;, document.getElementById(&#39;root&#39;));render 함수는 업데이트가 발생할 때 마다 호출된다. 하지만 동일한 DOM node 내부에서 그려지는 Clock은 단 하나의 객체로 사용된다.Lifecycle MethodsClock이 처음 그려질 때 타이머가 설정이 되고, Clock이 지워질 때 타이머도 지워져야 한다. React에서 이것을 “mounting” / “unmounting” 이라 한다.class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () =&amp;gt; this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;It is {this.state.date.toLocaleTimeString()}.&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; ); }}ReactDOM.render( &amp;lt;Clock /&amp;gt;, document.getElementById(&#39;root&#39;));여기서 componentDidMount()와 componentWillUnmount()를 “lifecycle method”라고 한다.componentDidMount() method는 component 결과가 렌더링 된 후에 실행된다.componentWillUnmount() method는 component가 제거될 때 실행된다.State 사용 시 주의사항1. Do Not Modify State Directly(State를 직접 변경하지 말 것)state는 setState() 함수를 사용해서 변경해야하며, class형 컴포넌트에서는 오직 constructor의 this.state에서 할당할 수 있다.2. State Updates May Be Asynchronous(State Update는 비동기적으로 동작한다.)얼마전 React 공부 중 만났던 오류의 내용이였다. React를 쓰다보면 하나의 업데이트 함수 내부에서 여러 개의 State를 변경해야 하는 경우가 생긴다.그 때 만약 그 State들이 서로 영향을 주는 관계가 있다면, 원하는 대로 렌더링 되지 않을 것이다. 하지만 실제로 State 업데이트는 제대로 이루어 진 것을 확인할 수 있다!!그 원인이 State Update가 비동기적으로 이루어지기 때문이다.3. State Updates are Merged(State Update는 병합된다.)constructor(props) { super(props); this.state = { posts: [], comments: [] };}componentDidMount() { fetchPosts().then(response =&amp;gt; { this.setState({ posts: response.posts }); }); fetchComments().then(response =&amp;gt; { this.setState({ comments: response.comments }); });}state의 각 요소를 독립적으로 업데이트 할 수 있다." }, { "title": "React 01. Components and Props", "url": "/posts/react-01/", "categories": "React", "tags": "react", "date": "2022-02-23 00:00:00 +0900", "snippet": "ElementsElements는 React app의 최소 단위이다. Element와 Component를 혼동해서는 안된다. Component는 Elements(요소들)로 이루어 진다.ComponentsComponents는 UI를 독립적으로 나눌 수 있게하고, 코드 재사용을 통해 생산성을 높힌다. 잘 할때 말이지…Components는 Javascript function과 비슷하다. 또한 임의의 입력값을 받을 수 있으며 이 입력값은 “props”라 부른다. 그리고 Elements가 어떻게 화면에서 나타날지 return한다.Components를 만드는 방법은 Function / Class 두 가지 방법이 있다. function type function Welcome(props) { return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;} class type class Welcome extends React.Component { render() { return &amp;lt;h1&amp;gt;Hello, {this.props.name}&amp;lt;/h1&amp;gt;; }} 우리가 정의한 Component를 Element로 표현할 때, 이 Element는 JSX attributes, 또는 children(Single object)를 넘겨 받을 수 있다. 이것을 우리는 “props”라고 부른다.function Welcome(props) { return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;}const element = &amp;lt;Welcome name=&quot;Roy&quot; /&amp;gt;;ReactDOM.render( element, document.getElementById(&#39;root&#39;)); 주의: Component name은 항상 대문자로 시작해야 한다. 소문자로 시작하면 DOM tag로 인식한다.Propsprops는 Read-Only다. 아래의 코드를 보자.function sum(a, b) { return a + b;}sum 함수는 “pure” 하다. “pure” 한 함수는 input을 변경하지 않는다. 그리고 같은 input값에 대해서 항상 같은 output값을 가진다.모든 React Components는 반드시 props에 대해서 “pure function” 과 같이 동작해야 한다.물론 Components 내부에서 동적인 동작이 필요할 때가 있을 것이다. React에서는 그런 동작을 위해 “state”를 사용한다.이건 내일 정리해야겠다." }, { "title": "JSX", "url": "/posts/jsx/", "categories": "React", "tags": "react, jsx", "date": "2022-02-22 00:00:00 +0900", "snippet": "Why JSX?React를 공부하기 전에 JSX를 정리해 보자. JSX는 뭘까? 리액트 공식 페이지에서는 아래와 같이 JSX를 소개하고 있다. This funny tag syntax is neither a string nor HTML. It is called JSX, and it is a syntax extension to JavaScript. We recommend &amp;gt;using it with React to describe what the UI should look like. JSX may remind &amp;gt;you of a template language, but it comes with the full power of JavaScript.확장된 JavaScript 문법이며, React를 사용할 때 추천한다 뭐 이런 내용인 것 같다.구글에서 What is a JSX 라고 검색해서 나온 reactenlightenment.com 사이트에서 왜 JSX인가에 대한 답을 찾았다. By using JSX one can write the following JSX/JavaScript code: var nav = ( &amp;lt;ul id=&quot;nav&quot;&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;Home&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;About&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;Clients&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;Contact Us&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;); And Babel will transform it into this: var nav = React.createElement( &quot;ul&quot;, { id: &quot;nav&quot; }, React.createElement( &quot;li&quot;, null, React.createElement( &quot;a&quot;, { href: &quot;#&quot; }, &quot;Home&quot; ) ), React.createElement( &quot;li&quot;, null, React.createElement( &quot;a&quot;, { href: &quot;#&quot; }, &quot;About&quot; ) ), React.createElement( &quot;li&quot;, null, React.createElement( &quot;a&quot;, { href: &quot;#&quot; }, &quot;Clients&quot; ) ), React.createElement( &quot;li&quot;, null, React.createElement( &quot;a&quot;, { href: &quot;#&quot; }, &quot;Contact Us&quot; ) )); 결론..JSX 문법 공부하고 리액트 열심히 공부하자!!JSX 문법 감싸인 요소(하나의 부모 요소) 컴포넌트는 반드시 하나의 부모 요소로 감싸야 한다. const component = () =&amp;gt; { return ( &amp;lt;Fragment&amp;gt; &amp;lt;h1&amp;gt;First item&amp;lt;/h1&amp;gt; &amp;lt;h1&amp;gt;Second item&amp;lt;/h1&amp;gt; &amp;lt;/Fragment&amp;gt; ); } 부모 요소의 태그는 관계없이 단 하나의 부모 요소이기만 하면 된다. 자바스크립트 표현 JSX 안에서 자바스크립트 표현식을 사용하려면 JSX 내부에서 { }로 감싸준다. const component = () =&amp;gt; { const text = &quot;TEXT&quot;; return ( &amp;lt;&amp;gt; &amp;lt;h1&amp;gt;{text}&amp;lt;/h1&amp;gt; &amp;lt;/&amp;gt; ); } 조건문 처리 JSX 내부에서는 자바스크립트의 if문을 사용할 수 없다. 조건문을 사용해야 할 경우 삼항 연산자 또는 논리연산을 통해 조건부 렌더링을 처리한다. const component = () =&amp;gt; { const text = &quot;TEXT&quot;; return ( &amp;lt;&amp;gt; {text === &quot;TEXT&quot; ? (&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;) : (&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;)} &amp;lt;/&amp;gt; ) } 마치며..그 외 undefined를 렌더링하지 않는 것, 주석처리, 인라인 스타일링, 태그 properties 는 카멜케이스 방식으로 써야한다는 점이 있었다. 필요하면 찾아보고 얼른 JSX와 React에 적응하고 싶다~~~" }, { "title": "GitBlog 시작", "url": "/posts/post/", "categories": "ETC", "tags": "gitblog", "date": "2022-02-21 00:00:00 +0900", "snippet": "GitHub Blog 시작..항상 찾아보고 정리는 하지 않았는데자꾸 까먹는다." }, { "title": "Markdown 문법정리", "url": "/posts/markdown/", "categories": "ETC", "tags": "markdown, gitblog", "date": "2022-02-21 00:00:00 +0900", "snippet": "Git Blog 포스팅을 위해 Markdown 문법을 알아야겠다.Headings’#’의 개수에 따라 Heading level이 달라진다. ‘#’과 Text 사이에는 공백이 반드시 있어야 한다. Markdown HTML # Heading level 1 &amp;#60;h1&amp;#62;&amp;#60;/h1&amp;#62; ## Heading level 2 &amp;#60;h2&amp;#62;&amp;#60;/h2&amp;#62; ### Heading level 3 &amp;#60;h3&amp;#62;&amp;#60;/h3&amp;#62; #### Heading level 4 &amp;#60;h4&amp;#62;&amp;#60;/h4&amp;#62; ##### Heading level 5 &amp;#60;h5&amp;#62;&amp;#60;/h5&amp;#62; ###### Heading level 6 &amp;#60;h6&amp;#62;&amp;#60;/h6&amp;#62; Alternative Syntax간단하게 제목을 나타내는 방법으로 문자 아래 라인을 넣을 수 있다. Markdown HTML # Heading level 1———————— &amp;#60;h1&amp;#62;&amp;#60;/h1&amp;#62; ## Heading level 2============== &amp;#60;h2&amp;#62;&amp;#60;/h2&amp;#62; Line BreakLine Break… 즉 개행이다. 개행의 경우 enter 또는 HTML 태그인 &amp;#60;Br&amp;#62; 을 사용하면 된다.이 경우는 어떤 쓰는게 좋을까?? Markdown 공식 페이지에서는You can use two or more spaces (commonly referred to as “trailing whitespace”) for line breaks in nearly every Markdown application, but it’s controversial. It’s hard to see trailing whitespace in an editor, and many people accidentally or intentionally put two spaces after every sentence. For this reason, you may want to use something other than trailing whitespace for line breaks. If your Markdown application supports HTML, you can use the &amp;#60;Br&amp;#62; HTML tag.라고한다. 그냥 &amp;#60;Br&amp;#62; 쓰자.Bold and ItalicBold 와 Italic은 asterisk(*) 또는 underscore(_)로 표현할 수 있다. 하지만 Markdown 공식 페이지에서 Markdown application에서는 underscore를 허용하지 않는다고 한다. 그냥 asterisk만 쓰도록 하자. Syntax Markdown Bold * TEXT * Italic ** TEXT ** Bold and Italic ** TEXT ** Blockquotes인용구는 기호 &amp;#62; 를 사용한다. 인용구는 이런 모양… Blockquotes!!!ListList는 OrderList와 UnorderList로 나눌 수 있다. OrderList는 숫자와 .을 이용해서 연결하면 된다. First Item Second Item Third Item UnorderList는 Item 앞에 하이픈(-)과 공백으로 나타낼 수 있다. First Item Second Item Third Item Code Block코드블럭은 백틱을 세번 중첩해서 만들 수 있다. 그리고 코드블럭에 언어를 표기하면 해당 언어의 예약어에 Highlight 효과를 줄 수 있다.{ &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25}그 외 Syntax Markdown Horizontal Rule — Link [title](https://www.example.com) Image ![alt text](image.jpg) 마치며…해당 포스팅은 Markdown 공식 홈페이지를 보면서 작성했다. 공식 홈페이지를 보니 포스팅한 내용보다 훨씬 자세하고 많은 내용이 있었다. 필요한 내용이 있다면 공식 홈페이지를 참고하도록 하자..한가지 포스팅에 포함되지 않았지만 주의할 점은 Markdown에서 특수문자는 HTML 코드값으로 입력해야 한다는 점.. 특수문자를 쓸 일이 있다면 HTML 코드를 찾아보자." } ]
